<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1"/>
<meta name="generator" content="pdoc ???"/>
<title>ida_typeinf API documentation</title>
<meta name="description" content="IDA Plugin SDK API wrapper: typeinf"/>
<link rel="preload stylesheet" as="style" href="assets/sanitize.min.css"/>
<link rel="preload stylesheet" as="style" href="assets/typography.min.css"/>
<link rel="stylesheet preload" as="style" href="assets/github.min.css"/>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar &amp;gt; *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl &amp;gt; dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:-webkit-fill-available}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name &amp;gt; span:first-child{white-space:nowrap}.name.class &amp;gt; span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary &amp;gt; *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content: ',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width: 700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content padding:3em 4em;border-left:1px solid #ddd;lid #ddd;}pre code{font-size:1em}.item .name{font-size:1em}main{/* display:flex; *//* flex-direction:row-reverse; *//* justify-content:flex-end; */}.toc ul ul,#index ul{padding-left:1.5em}.toc &gt; ul &gt; li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer="defer" src="assets/highlight.min.js"/>
<script>window.addEventListener('DOMContentLoaded', () =&gt; hljs.initHighlighting())</script>
<style>
#section-intro .epy_par
{
margin-top: 18px;
}
</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ida_typeinf</code></h1>
</header>
<section id="section-intro">
<div class="epy_par">
IDA Plugin SDK API wrapper: typeinf</div>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="ida_typeinf.ADDTIL_ABORTED"><code class="name">var <span class="ident">ADDTIL_ABORTED</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
til was not loaded (incompatible til rejected by user)</div></div>
</dd>
<dt id="ida_typeinf.ADDTIL_COMP"><code class="name">var <span class="ident">ADDTIL_COMP</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
ok, but til is not compatible with the current compiler</div></div>
</dd>
<dt id="ida_typeinf.ADDTIL_DEFAULT"><code class="name">var <span class="ident">ADDTIL_DEFAULT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
default behavior</div></div>
</dd>
<dt id="ida_typeinf.ADDTIL_FAILED"><code class="name">var <span class="ident">ADDTIL_FAILED</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
something bad, the warning is displayed</div></div>
</dd>
<dt id="ida_typeinf.ADDTIL_INCOMP"><code class="name">var <span class="ident">ADDTIL_INCOMP</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
load incompatible tils</div></div>
</dd>
<dt id="ida_typeinf.ADDTIL_OK"><code class="name">var <span class="ident">ADDTIL_OK</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
ok, til is loaded</div></div>
</dd>
<dt id="ida_typeinf.ADDTIL_SILENT"><code class="name">var <span class="ident">ADDTIL_SILENT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
do not ask any questions</div></div>
</dd>
<dt id="ida_typeinf.ALOC_CUSTOM"><code class="name">var <span class="ident">ALOC_CUSTOM</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
ALOC_CUSTOM = 7</div></div>
</dd>
<dt id="ida_typeinf.ALOC_DIST"><code class="name">var <span class="ident">ALOC_DIST</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
ALOC_DIST = 2</div></div>
</dd>
<dt id="ida_typeinf.ALOC_NONE"><code class="name">var <span class="ident">ALOC_NONE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
ALOC_NONE = 0</div></div>
</dd>
<dt id="ida_typeinf.ALOC_REG1"><code class="name">var <span class="ident">ALOC_REG1</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
ALOC_REG1 = 3</div></div>
</dd>
<dt id="ida_typeinf.ALOC_REG2"><code class="name">var <span class="ident">ALOC_REG2</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
ALOC_REG2 = 4</div></div>
</dd>
<dt id="ida_typeinf.ALOC_RREL"><code class="name">var <span class="ident">ALOC_RREL</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
ALOC_RREL = 5</div></div>
</dd>
<dt id="ida_typeinf.ALOC_STACK"><code class="name">var <span class="ident">ALOC_STACK</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
ALOC_STACK = 1</div></div>
</dd>
<dt id="ida_typeinf.ALOC_STATIC"><code class="name">var <span class="ident">ALOC_STATIC</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
ALOC_STATIC = 6</div></div>
</dd>
<dt id="ida_typeinf.ARGREGS_BY_SLOTS"><code class="name">var <span class="ident">ARGREGS_BY_SLOTS</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
ARGREGS_BY_SLOTS = 3</div></div>
</dd>
<dt id="ida_typeinf.ARGREGS_FP_CONSUME_GP"><code class="name">var <span class="ident">ARGREGS_FP_CONSUME_GP</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
ARGREGS_FP_CONSUME_GP = 4</div></div>
</dd>
<dt id="ida_typeinf.ARGREGS_GP_ONLY"><code class="name">var <span class="ident">ARGREGS_GP_ONLY</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
ARGREGS_GP_ONLY = 1</div></div>
</dd>
<dt id="ida_typeinf.ARGREGS_INDEPENDENT"><code class="name">var <span class="ident">ARGREGS_INDEPENDENT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
ARGREGS_INDEPENDENT = 2</div></div>
</dd>
<dt id="ida_typeinf.ARGREGS_MIPS_O32"><code class="name">var <span class="ident">ARGREGS_MIPS_O32</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
ARGREGS_MIPS_O32 = 5</div></div>
</dd>
<dt id="ida_typeinf.ARGREGS_POLICY_UNDEFINED"><code class="name">var <span class="ident">ARGREGS_POLICY_UNDEFINED</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
ARGREGS_POLICY_UNDEFINED = 0</div></div>
</dd>
<dt id="ida_typeinf.BADORD"><code class="name">var <span class="ident">BADORD</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BADORD = 4294967295</div></div>
</dd>
<dt id="ida_typeinf.BADSIZE"><code class="name">var <span class="ident">BADSIZE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BADSIZE = 18446744073709551615</div></div>
</dd>
<dt id="ida_typeinf.BFA_FUNC_EXT_FORMAT"><code class="name">var <span class="ident">BFA_FUNC_EXT_FORMAT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BFA_FUNC_EXT_FORMAT = 128</div></div>
</dd>
<dt id="ida_typeinf.BFA_FUNC_MARKER"><code class="name">var <span class="ident">BFA_FUNC_MARKER</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BFA_FUNC_MARKER = 15</div></div>
</dd>
<dt id="ida_typeinf.BFA_HIGH"><code class="name">var <span class="ident">BFA_HIGH</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BFA_HIGH = 4</div></div>
</dd>
<dt id="ida_typeinf.BFA_NORET"><code class="name">var <span class="ident">BFA_NORET</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BFA_NORET = 1</div></div>
</dd>
<dt id="ida_typeinf.BFA_PURE"><code class="name">var <span class="ident">BFA_PURE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BFA_PURE = 2</div></div>
</dd>
<dt id="ida_typeinf.BFA_STATIC"><code class="name">var <span class="ident">BFA_STATIC</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BFA_STATIC = 8</div></div>
</dd>
<dt id="ida_typeinf.BFA_VIRTUAL"><code class="name">var <span class="ident">BFA_VIRTUAL</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BFA_VIRTUAL = 16</div></div>
</dd>
<dt id="ida_typeinf.BTE_ALWAYS"><code class="name">var <span class="ident">BTE_ALWAYS</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BTE_ALWAYS = 128</div></div>
</dd>
<dt id="ida_typeinf.BTE_BITFIELD"><code class="name">var <span class="ident">BTE_BITFIELD</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BTE_BITFIELD = 16</div></div>
</dd>
<dt id="ida_typeinf.BTE_CHAR"><code class="name">var <span class="ident">BTE_CHAR</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BTE_CHAR = 32</div></div>
</dd>
<dt id="ida_typeinf.BTE_HEX"><code class="name">var <span class="ident">BTE_HEX</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BTE_HEX = 0</div></div>
</dd>
<dt id="ida_typeinf.BTE_OUT_MASK"><code class="name">var <span class="ident">BTE_OUT_MASK</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BTE_OUT_MASK = 96</div></div>
</dd>
<dt id="ida_typeinf.BTE_RESERVED"><code class="name">var <span class="ident">BTE_RESERVED</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BTE_RESERVED = 8</div></div>
</dd>
<dt id="ida_typeinf.BTE_SDEC"><code class="name">var <span class="ident">BTE_SDEC</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BTE_SDEC = 64</div></div>
</dd>
<dt id="ida_typeinf.BTE_SIZE_MASK"><code class="name">var <span class="ident">BTE_SIZE_MASK</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BTE_SIZE_MASK = 7</div></div>
</dd>
<dt id="ida_typeinf.BTE_UDEC"><code class="name">var <span class="ident">BTE_UDEC</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BTE_UDEC = 96</div></div>
</dd>
<dt id="ida_typeinf.BTF_BOOL"><code class="name">var <span class="ident">BTF_BOOL</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BTF_BOOL = 8</div></div>
</dd>
<dt id="ida_typeinf.BTF_BYTE"><code class="name">var <span class="ident">BTF_BYTE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BTF_BYTE = 17</div></div>
</dd>
<dt id="ida_typeinf.BTF_CHAR"><code class="name">var <span class="ident">BTF_CHAR</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BTF_CHAR = 50</div></div>
</dd>
<dt id="ida_typeinf.BTF_DOUBLE"><code class="name">var <span class="ident">BTF_DOUBLE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BTF_DOUBLE = 25</div></div>
</dd>
<dt id="ida_typeinf.BTF_ENUM"><code class="name">var <span class="ident">BTF_ENUM</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BTF_ENUM = 45</div></div>
</dd>
<dt id="ida_typeinf.BTF_FLOAT"><code class="name">var <span class="ident">BTF_FLOAT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BTF_FLOAT = 9</div></div>
</dd>
<dt id="ida_typeinf.BTF_INT"><code class="name">var <span class="ident">BTF_INT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BTF_INT = 7</div></div>
</dd>
<dt id="ida_typeinf.BTF_INT128"><code class="name">var <span class="ident">BTF_INT128</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BTF_INT128 = 22</div></div>
</dd>
<dt id="ida_typeinf.BTF_INT16"><code class="name">var <span class="ident">BTF_INT16</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BTF_INT16 = 19</div></div>
</dd>
<dt id="ida_typeinf.BTF_INT32"><code class="name">var <span class="ident">BTF_INT32</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BTF_INT32 = 20</div></div>
</dd>
<dt id="ida_typeinf.BTF_INT64"><code class="name">var <span class="ident">BTF_INT64</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BTF_INT64 = 21</div></div>
</dd>
<dt id="ida_typeinf.BTF_INT8"><code class="name">var <span class="ident">BTF_INT8</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BTF_INT8 = 18</div></div>
</dd>
<dt id="ida_typeinf.BTF_LDOUBLE"><code class="name">var <span class="ident">BTF_LDOUBLE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BTF_LDOUBLE = 41</div></div>
</dd>
<dt id="ida_typeinf.BTF_SINT"><code class="name">var <span class="ident">BTF_SINT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BTF_SINT = 23</div></div>
</dd>
<dt id="ida_typeinf.BTF_STRUCT"><code class="name">var <span class="ident">BTF_STRUCT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BTF_STRUCT = 13</div></div>
</dd>
<dt id="ida_typeinf.BTF_TBYTE"><code class="name">var <span class="ident">BTF_TBYTE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BTF_TBYTE = 57</div></div>
</dd>
<dt id="ida_typeinf.BTF_TYPEDEF"><code class="name">var <span class="ident">BTF_TYPEDEF</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BTF_TYPEDEF = 61</div></div>
</dd>
<dt id="ida_typeinf.BTF_UCHAR"><code class="name">var <span class="ident">BTF_UCHAR</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BTF_UCHAR = 34</div></div>
</dd>
<dt id="ida_typeinf.BTF_UINT"><code class="name">var <span class="ident">BTF_UINT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BTF_UINT = 39</div></div>
</dd>
<dt id="ida_typeinf.BTF_UINT128"><code class="name">var <span class="ident">BTF_UINT128</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BTF_UINT128 = 38</div></div>
</dd>
<dt id="ida_typeinf.BTF_UINT16"><code class="name">var <span class="ident">BTF_UINT16</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BTF_UINT16 = 35</div></div>
</dd>
<dt id="ida_typeinf.BTF_UINT32"><code class="name">var <span class="ident">BTF_UINT32</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BTF_UINT32 = 36</div></div>
</dd>
<dt id="ida_typeinf.BTF_UINT64"><code class="name">var <span class="ident">BTF_UINT64</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BTF_UINT64 = 37</div></div>
</dd>
<dt id="ida_typeinf.BTF_UINT8"><code class="name">var <span class="ident">BTF_UINT8</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BTF_UINT8 = 34</div></div>
</dd>
<dt id="ida_typeinf.BTF_UNION"><code class="name">var <span class="ident">BTF_UNION</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BTF_UNION = 29</div></div>
</dd>
<dt id="ida_typeinf.BTF_UNK"><code class="name">var <span class="ident">BTF_UNK</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BTF_UNK = 48</div></div>
</dd>
<dt id="ida_typeinf.BTF_VOID"><code class="name">var <span class="ident">BTF_VOID</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BTF_VOID = 1</div></div>
</dd>
<dt id="ida_typeinf.BTMT_ARRESERV"><code class="name">var <span class="ident">BTMT_ARRESERV</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BTMT_ARRESERV = 32</div></div>
</dd>
<dt id="ida_typeinf.BTMT_BFLDI16"><code class="name">var <span class="ident">BTMT_BFLDI16</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BTMT_BFLDI16 = 16</div></div>
</dd>
<dt id="ida_typeinf.BTMT_BFLDI32"><code class="name">var <span class="ident">BTMT_BFLDI32</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BTMT_BFLDI32 = 32</div></div>
</dd>
<dt id="ida_typeinf.BTMT_BFLDI64"><code class="name">var <span class="ident">BTMT_BFLDI64</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BTMT_BFLDI64 = 48</div></div>
</dd>
<dt id="ida_typeinf.BTMT_BFLDI8"><code class="name">var <span class="ident">BTMT_BFLDI8</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BTMT_BFLDI8 = 0</div></div>
</dd>
<dt id="ida_typeinf.BTMT_BOOL1"><code class="name">var <span class="ident">BTMT_BOOL1</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BTMT_BOOL1 = 16</div></div>
</dd>
<dt id="ida_typeinf.BTMT_BOOL2"><code class="name">var <span class="ident">BTMT_BOOL2</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BTMT_BOOL2 = 32</div></div>
</dd>
<dt id="ida_typeinf.BTMT_BOOL4"><code class="name">var <span class="ident">BTMT_BOOL4</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BTMT_BOOL4 = 48</div></div>
</dd>
<dt id="ida_typeinf.BTMT_BOOL8"><code class="name">var <span class="ident">BTMT_BOOL8</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BTMT_BOOL8 = 32</div></div>
</dd>
<dt id="ida_typeinf.BTMT_CHAR"><code class="name">var <span class="ident">BTMT_CHAR</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BTMT_CHAR = 48</div></div>
</dd>
<dt id="ida_typeinf.BTMT_CLOSURE"><code class="name">var <span class="ident">BTMT_CLOSURE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BTMT_CLOSURE = 48</div></div>
</dd>
<dt id="ida_typeinf.BTMT_DEFBOOL"><code class="name">var <span class="ident">BTMT_DEFBOOL</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BTMT_DEFBOOL = 0</div></div>
</dd>
<dt id="ida_typeinf.BTMT_DEFCALL"><code class="name">var <span class="ident">BTMT_DEFCALL</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BTMT_DEFCALL = 0</div></div>
</dd>
<dt id="ida_typeinf.BTMT_DEFPTR"><code class="name">var <span class="ident">BTMT_DEFPTR</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BTMT_DEFPTR = 0</div></div>
</dd>
<dt id="ida_typeinf.BTMT_DOUBLE"><code class="name">var <span class="ident">BTMT_DOUBLE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BTMT_DOUBLE = 16</div></div>
</dd>
<dt id="ida_typeinf.BTMT_ENUM"><code class="name">var <span class="ident">BTMT_ENUM</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BTMT_ENUM = 32</div></div>
</dd>
<dt id="ida_typeinf.BTMT_FAR"><code class="name">var <span class="ident">BTMT_FAR</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BTMT_FAR = 32</div></div>
</dd>
<dt id="ida_typeinf.BTMT_FARCALL"><code class="name">var <span class="ident">BTMT_FARCALL</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BTMT_FARCALL = 32</div></div>
</dd>
<dt id="ida_typeinf.BTMT_FLOAT"><code class="name">var <span class="ident">BTMT_FLOAT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BTMT_FLOAT = 0</div></div>
</dd>
<dt id="ida_typeinf.BTMT_INTCALL"><code class="name">var <span class="ident">BTMT_INTCALL</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BTMT_INTCALL = 48</div></div>
</dd>
<dt id="ida_typeinf.BTMT_LNGDBL"><code class="name">var <span class="ident">BTMT_LNGDBL</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BTMT_LNGDBL = 32</div></div>
</dd>
<dt id="ida_typeinf.BTMT_NEAR"><code class="name">var <span class="ident">BTMT_NEAR</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BTMT_NEAR = 16</div></div>
</dd>
<dt id="ida_typeinf.BTMT_NEARCALL"><code class="name">var <span class="ident">BTMT_NEARCALL</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BTMT_NEARCALL = 16</div></div>
</dd>
<dt id="ida_typeinf.BTMT_NONBASED"><code class="name">var <span class="ident">BTMT_NONBASED</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BTMT_NONBASED = 16</div></div>
</dd>
<dt id="ida_typeinf.BTMT_SIGNED"><code class="name">var <span class="ident">BTMT_SIGNED</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BTMT_SIGNED = 16</div></div>
</dd>
<dt id="ida_typeinf.BTMT_SIZE0"><code class="name">var <span class="ident">BTMT_SIZE0</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BTMT_SIZE0 = 0</div></div>
</dd>
<dt id="ida_typeinf.BTMT_SIZE12"><code class="name">var <span class="ident">BTMT_SIZE12</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BTMT_SIZE12 = 16</div></div>
</dd>
<dt id="ida_typeinf.BTMT_SIZE128"><code class="name">var <span class="ident">BTMT_SIZE128</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BTMT_SIZE128 = 48</div></div>
</dd>
<dt id="ida_typeinf.BTMT_SIZE48"><code class="name">var <span class="ident">BTMT_SIZE48</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BTMT_SIZE48 = 32</div></div>
</dd>
<dt id="ida_typeinf.BTMT_SPECFLT"><code class="name">var <span class="ident">BTMT_SPECFLT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BTMT_SPECFLT = 48</div></div>
</dd>
<dt id="ida_typeinf.BTMT_STRUCT"><code class="name">var <span class="ident">BTMT_STRUCT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BTMT_STRUCT = 0</div></div>
</dd>
<dt id="ida_typeinf.BTMT_TYPEDEF"><code class="name">var <span class="ident">BTMT_TYPEDEF</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BTMT_TYPEDEF = 48</div></div>
</dd>
<dt id="ida_typeinf.BTMT_UNION"><code class="name">var <span class="ident">BTMT_UNION</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BTMT_UNION = 16</div></div>
</dd>
<dt id="ida_typeinf.BTMT_UNKSIGN"><code class="name">var <span class="ident">BTMT_UNKSIGN</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BTMT_UNKSIGN = 0</div></div>
</dd>
<dt id="ida_typeinf.BTMT_UNSIGNED"><code class="name">var <span class="ident">BTMT_UNSIGNED</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BTMT_UNSIGNED = 32</div></div>
</dd>
<dt id="ida_typeinf.BTMT_USIGNED"><code class="name">var <span class="ident">BTMT_USIGNED</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BTMT_USIGNED = 32</div></div>
</dd>
<dt id="ida_typeinf.BTM_CONST"><code class="name">var <span class="ident">BTM_CONST</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BTM_CONST = 64</div></div>
</dd>
<dt id="ida_typeinf.BTM_VOLATILE"><code class="name">var <span class="ident">BTM_VOLATILE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BTM_VOLATILE = 128</div></div>
</dd>
<dt id="ida_typeinf.BT_ARRAY"><code class="name">var <span class="ident">BT_ARRAY</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BT_ARRAY = 11</div></div>
</dd>
<dt id="ida_typeinf.BT_BITFIELD"><code class="name">var <span class="ident">BT_BITFIELD</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BT_BITFIELD = 14</div></div>
</dd>
<dt id="ida_typeinf.BT_BOOL"><code class="name">var <span class="ident">BT_BOOL</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BT_BOOL = 8</div></div>
</dd>
<dt id="ida_typeinf.BT_COMPLEX"><code class="name">var <span class="ident">BT_COMPLEX</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BT_COMPLEX = 13</div></div>
</dd>
<dt id="ida_typeinf.BT_FLOAT"><code class="name">var <span class="ident">BT_FLOAT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BT_FLOAT = 9</div></div>
</dd>
<dt id="ida_typeinf.BT_FUNC"><code class="name">var <span class="ident">BT_FUNC</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BT_FUNC = 12</div></div>
</dd>
<dt id="ida_typeinf.BT_INT"><code class="name">var <span class="ident">BT_INT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BT_INT = 7</div></div>
</dd>
<dt id="ida_typeinf.BT_INT128"><code class="name">var <span class="ident">BT_INT128</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BT_INT128 = 6</div></div>
</dd>
<dt id="ida_typeinf.BT_INT16"><code class="name">var <span class="ident">BT_INT16</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BT_INT16 = 3</div></div>
</dd>
<dt id="ida_typeinf.BT_INT32"><code class="name">var <span class="ident">BT_INT32</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BT_INT32 = 4</div></div>
</dd>
<dt id="ida_typeinf.BT_INT64"><code class="name">var <span class="ident">BT_INT64</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BT_INT64 = 5</div></div>
</dd>
<dt id="ida_typeinf.BT_INT8"><code class="name">var <span class="ident">BT_INT8</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BT_INT8 = 2</div></div>
</dd>
<dt id="ida_typeinf.BT_PTR"><code class="name">var <span class="ident">BT_PTR</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BT_PTR = 10</div></div>
</dd>
<dt id="ida_typeinf.BT_RESERVED"><code class="name">var <span class="ident">BT_RESERVED</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BT_RESERVED = 15</div></div>
</dd>
<dt id="ida_typeinf.BT_SEGREG"><code class="name">var <span class="ident">BT_SEGREG</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BT_SEGREG = 55</div></div>
</dd>
<dt id="ida_typeinf.BT_UNK"><code class="name">var <span class="ident">BT_UNK</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BT_UNK = 0</div></div>
</dd>
<dt id="ida_typeinf.BT_UNKNOWN"><code class="name">var <span class="ident">BT_UNKNOWN</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BT_UNKNOWN = 48</div></div>
</dd>
<dt id="ida_typeinf.BT_UNK_BYTE"><code class="name">var <span class="ident">BT_UNK_BYTE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BT_UNK_BYTE = 17</div></div>
</dd>
<dt id="ida_typeinf.BT_UNK_DWORD"><code class="name">var <span class="ident">BT_UNK_DWORD</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BT_UNK_DWORD = 33</div></div>
</dd>
<dt id="ida_typeinf.BT_UNK_OWORD"><code class="name">var <span class="ident">BT_UNK_OWORD</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BT_UNK_OWORD = 49</div></div>
</dd>
<dt id="ida_typeinf.BT_UNK_QWORD"><code class="name">var <span class="ident">BT_UNK_QWORD</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BT_UNK_QWORD = 32</div></div>
</dd>
<dt id="ida_typeinf.BT_UNK_WORD"><code class="name">var <span class="ident">BT_UNK_WORD</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BT_UNK_WORD = 16</div></div>
</dd>
<dt id="ida_typeinf.BT_VOID"><code class="name">var <span class="ident">BT_VOID</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BT_VOID = 1</div></div>
</dd>
<dt id="ida_typeinf.CCN_C"><code class="name">var <span class="ident">CCN_C</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
CCN_C = 0</div></div>
</dd>
<dt id="ida_typeinf.CCN_CPP"><code class="name">var <span class="ident">CCN_CPP</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
CCN_CPP = 1</div></div>
</dd>
<dt id="ida_typeinf.CC_ALLOW_ARGPERM"><code class="name">var <span class="ident">CC_ALLOW_ARGPERM</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
disregard argument order?</div></div>
</dd>
<dt id="ida_typeinf.CC_ALLOW_REGHOLES"><code class="name">var <span class="ident">CC_ALLOW_REGHOLES</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
allow holes in register argument list?</div></div>
</dd>
<dt id="ida_typeinf.CC_CDECL_OK"><code class="name">var <span class="ident">CC_CDECL_OK</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
can use __cdecl calling convention?</div></div>
</dd>
<dt id="ida_typeinf.CC_GOLANG_OK"><code class="name">var <span class="ident">CC_GOLANG_OK</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
can use __golang calling convention</div></div>
</dd>
<dt id="ida_typeinf.CC_HAS_ELLIPSIS"><code class="name">var <span class="ident">CC_HAS_ELLIPSIS</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
function has a variable list of arguments?</div></div>
</dd>
<dt id="ida_typeinf.CM_CC_CDECL"><code class="name">var <span class="ident">CM_CC_CDECL</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
CM_CC_CDECL = 48</div></div>
</dd>
<dt id="ida_typeinf.CM_CC_ELLIPSIS"><code class="name">var <span class="ident">CM_CC_ELLIPSIS</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
CM_CC_ELLIPSIS = 64</div></div>
</dd>
<dt id="ida_typeinf.CM_CC_FASTCALL"><code class="name">var <span class="ident">CM_CC_FASTCALL</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
CM_CC_FASTCALL = 112</div></div>
</dd>
<dt id="ida_typeinf.CM_CC_GOLANG"><code class="name">var <span class="ident">CM_CC_GOLANG</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
CM_CC_GOLANG = 176</div></div>
</dd>
<dt id="ida_typeinf.CM_CC_INVALID"><code class="name">var <span class="ident">CM_CC_INVALID</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
CM_CC_INVALID = 0</div></div>
</dd>
<dt id="ida_typeinf.CM_CC_MANUAL"><code class="name">var <span class="ident">CM_CC_MANUAL</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
CM_CC_MANUAL = 144</div></div>
</dd>
<dt id="ida_typeinf.CM_CC_MASK"><code class="name">var <span class="ident">CM_CC_MASK</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
CM_CC_MASK = 240</div></div>
</dd>
<dt id="ida_typeinf.CM_CC_PASCAL"><code class="name">var <span class="ident">CM_CC_PASCAL</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
CM_CC_PASCAL = 96</div></div>
</dd>
<dt id="ida_typeinf.CM_CC_RESERVE3"><code class="name">var <span class="ident">CM_CC_RESERVE3</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
CM_CC_RESERVE3 = 192</div></div>
</dd>
<dt id="ida_typeinf.CM_CC_SPECIAL"><code class="name">var <span class="ident">CM_CC_SPECIAL</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
CM_CC_SPECIAL = 240</div></div>
</dd>
<dt id="ida_typeinf.CM_CC_SPECIALE"><code class="name">var <span class="ident">CM_CC_SPECIALE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
CM_CC_SPECIALE = 208</div></div>
</dd>
<dt id="ida_typeinf.CM_CC_SPECIALP"><code class="name">var <span class="ident">CM_CC_SPECIALP</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
CM_CC_SPECIALP = 224</div></div>
</dd>
<dt id="ida_typeinf.CM_CC_SPOILED"><code class="name">var <span class="ident">CM_CC_SPOILED</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
CM_CC_SPOILED = 160</div></div>
</dd>
<dt id="ida_typeinf.CM_CC_STDCALL"><code class="name">var <span class="ident">CM_CC_STDCALL</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
CM_CC_STDCALL = 80</div></div>
</dd>
<dt id="ida_typeinf.CM_CC_THISCALL"><code class="name">var <span class="ident">CM_CC_THISCALL</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
CM_CC_THISCALL = 128</div></div>
</dd>
<dt id="ida_typeinf.CM_CC_UNKNOWN"><code class="name">var <span class="ident">CM_CC_UNKNOWN</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
CM_CC_UNKNOWN = 16</div></div>
</dd>
<dt id="ida_typeinf.CM_CC_VOIDARG"><code class="name">var <span class="ident">CM_CC_VOIDARG</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
CM_CC_VOIDARG = 32</div></div>
</dd>
<dt id="ida_typeinf.CM_MASK"><code class="name">var <span class="ident">CM_MASK</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
CM_MASK = 3</div></div>
</dd>
<dt id="ida_typeinf.CM_M_FF"><code class="name">var <span class="ident">CM_M_FF</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
CM_M_FF = 4</div></div>
</dd>
<dt id="ida_typeinf.CM_M_FN"><code class="name">var <span class="ident">CM_M_FN</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
CM_M_FN = 12</div></div>
</dd>
<dt id="ida_typeinf.CM_M_MASK"><code class="name">var <span class="ident">CM_M_MASK</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
CM_M_MASK = 12</div></div>
</dd>
<dt id="ida_typeinf.CM_M_NF"><code class="name">var <span class="ident">CM_M_NF</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
CM_M_NF = 8</div></div>
</dd>
<dt id="ida_typeinf.CM_M_NN"><code class="name">var <span class="ident">CM_M_NN</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
CM_M_NN = 0</div></div>
</dd>
<dt id="ida_typeinf.CM_N16_F32"><code class="name">var <span class="ident">CM_N16_F32</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
CM_N16_F32 = 2</div></div>
</dd>
<dt id="ida_typeinf.CM_N32_F48"><code class="name">var <span class="ident">CM_N32_F48</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
CM_N32_F48 = 3</div></div>
</dd>
<dt id="ida_typeinf.CM_N64"><code class="name">var <span class="ident">CM_N64</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
CM_N64 = 1</div></div>
</dd>
<dt id="ida_typeinf.CM_N8_F16"><code class="name">var <span class="ident">CM_N8_F16</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
CM_N8_F16 = 1</div></div>
</dd>
<dt id="ida_typeinf.CM_UNKNOWN"><code class="name">var <span class="ident">CM_UNKNOWN</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
CM_UNKNOWN = 0</div></div>
</dd>
<dt id="ida_typeinf.COMP_BC"><code class="name">var <span class="ident">COMP_BC</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
COMP_BC = 2</div></div>
</dd>
<dt id="ida_typeinf.COMP_BP"><code class="name">var <span class="ident">COMP_BP</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
COMP_BP = 8</div></div>
</dd>
<dt id="ida_typeinf.COMP_GNU"><code class="name">var <span class="ident">COMP_GNU</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
COMP_GNU = 6</div></div>
</dd>
<dt id="ida_typeinf.COMP_MASK"><code class="name">var <span class="ident">COMP_MASK</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
COMP_MASK = 15</div></div>
</dd>
<dt id="ida_typeinf.COMP_MS"><code class="name">var <span class="ident">COMP_MS</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
COMP_MS = 1</div></div>
</dd>
<dt id="ida_typeinf.COMP_UNK"><code class="name">var <span class="ident">COMP_UNK</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
COMP_UNK = 0</div></div>
</dd>
<dt id="ida_typeinf.COMP_UNSURE"><code class="name">var <span class="ident">COMP_UNSURE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
COMP_UNSURE = 128</div></div>
</dd>
<dt id="ida_typeinf.COMP_VISAGE"><code class="name">var <span class="ident">COMP_VISAGE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
COMP_VISAGE = 7</div></div>
</dd>
<dt id="ida_typeinf.COMP_WATCOM"><code class="name">var <span class="ident">COMP_WATCOM</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
COMP_WATCOM = 3</div></div>
</dd>
<dt id="ida_typeinf.C_PC_COMPACT"><code class="name">var <span class="ident">C_PC_COMPACT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
C_PC_COMPACT = 10</div></div>
</dd>
<dt id="ida_typeinf.C_PC_FLAT"><code class="name">var <span class="ident">C_PC_FLAT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
C_PC_FLAT = 3</div></div>
</dd>
<dt id="ida_typeinf.C_PC_HUGE"><code class="name">var <span class="ident">C_PC_HUGE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
C_PC_HUGE = 6</div></div>
</dd>
<dt id="ida_typeinf.C_PC_LARGE"><code class="name">var <span class="ident">C_PC_LARGE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
C_PC_LARGE = 6</div></div>
</dd>
<dt id="ida_typeinf.C_PC_MEDIUM"><code class="name">var <span class="ident">C_PC_MEDIUM</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
C_PC_MEDIUM = 14</div></div>
</dd>
<dt id="ida_typeinf.C_PC_SMALL"><code class="name">var <span class="ident">C_PC_SMALL</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
C_PC_SMALL = 2</div></div>
</dd>
<dt id="ida_typeinf.C_PC_TINY"><code class="name">var <span class="ident">C_PC_TINY</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
C_PC_TINY = 2</div></div>
</dd>
<dt id="ida_typeinf.FAH_BYTE"><code class="name">var <span class="ident">FAH_BYTE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
function argument attribute header byte</div></div>
</dd>
<dt id="ida_typeinf.FAI_ARRAY"><code class="name">var <span class="ident">FAI_ARRAY</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
was initially an array see "__org_typedef" or "__org_arrdim" type
attributes to determine the original type</div></div>
</dd>
<dt id="ida_typeinf.FAI_HIDDEN"><code class="name">var <span class="ident">FAI_HIDDEN</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
hidden argument</div></div>
</dd>
<dt id="ida_typeinf.FAI_RETPTR"><code class="name">var <span class="ident">FAI_RETPTR</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
pointer to return value. implies hidden</div></div>
</dd>
<dt id="ida_typeinf.FAI_STRUCT"><code class="name">var <span class="ident">FAI_STRUCT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
was initially a structure</div></div>
</dd>
<dt id="ida_typeinf.FAI_UNUSED"><code class="name">var <span class="ident">FAI_UNUSED</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
argument is not used by the function</div></div>
</dd>
<dt id="ida_typeinf.FIRST_NONTRIVIAL_TYPID"><code class="name">var <span class="ident">FIRST_NONTRIVIAL_TYPID</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
FIRST_NONTRIVIAL_TYPID = 256</div></div>
</dd>
<dt id="ida_typeinf.FMTFUNC_PRINTF"><code class="name">var <span class="ident">FMTFUNC_PRINTF</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
FMTFUNC_PRINTF = 0</div></div>
</dd>
<dt id="ida_typeinf.FMTFUNC_SCANF"><code class="name">var <span class="ident">FMTFUNC_SCANF</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
FMTFUNC_SCANF = 1</div></div>
</dd>
<dt id="ida_typeinf.FMTFUNC_STRFMON"><code class="name">var <span class="ident">FMTFUNC_STRFMON</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
FMTFUNC_STRFMON = 3</div></div>
</dd>
<dt id="ida_typeinf.FMTFUNC_STRFTIME"><code class="name">var <span class="ident">FMTFUNC_STRFTIME</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
FMTFUNC_STRFTIME = 2</div></div>
</dd>
<dt id="ida_typeinf.FTI_ALL"><code class="name">var <span class="ident">FTI_ALL</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
all defined bits</div></div>
</dd>
<dt id="ida_typeinf.FTI_ARGLOCS"><code class="name">var <span class="ident">FTI_ARGLOCS</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
info about argument locations has been calculated (stkargs and retloc
too)</div></div>
</dd>
<dt id="ida_typeinf.FTI_CALLTYPE"><code class="name">var <span class="ident">FTI_CALLTYPE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
mask for FTI_*CALL</div></div>
</dd>
<dt id="ida_typeinf.FTI_DEFCALL"><code class="name">var <span class="ident">FTI_DEFCALL</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
default call</div></div>
</dd>
<dt id="ida_typeinf.FTI_EXPLOCS"><code class="name">var <span class="ident">FTI_EXPLOCS</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
all arglocs are specified explicitly</div></div>
</dd>
<dt id="ida_typeinf.FTI_FARCALL"><code class="name">var <span class="ident">FTI_FARCALL</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
far call</div></div>
</dd>
<dt id="ida_typeinf.FTI_HIGH"><code class="name">var <span class="ident">FTI_HIGH</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
high level prototype (with possibly hidden args)</div></div>
</dd>
<dt id="ida_typeinf.FTI_INTCALL"><code class="name">var <span class="ident">FTI_INTCALL</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
interrupt call</div></div>
</dd>
<dt id="ida_typeinf.FTI_NEARCALL"><code class="name">var <span class="ident">FTI_NEARCALL</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
near call</div></div>
</dd>
<dt id="ida_typeinf.FTI_NORET"><code class="name">var <span class="ident">FTI_NORET</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
noreturn</div></div>
</dd>
<dt id="ida_typeinf.FTI_PURE"><code class="name">var <span class="ident">FTI_PURE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
__pure</div></div>
</dd>
<dt id="ida_typeinf.FTI_SPOILED"><code class="name">var <span class="ident">FTI_SPOILED</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
information about spoiled registers is present</div></div>
</dd>
<dt id="ida_typeinf.FTI_STATIC"><code class="name">var <span class="ident">FTI_STATIC</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
static</div></div>
</dd>
<dt id="ida_typeinf.FTI_VIRTUAL"><code class="name">var <span class="ident">FTI_VIRTUAL</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
virtual</div></div>
</dd>
<dt id="ida_typeinf.GTD_CALC_ARGLOCS"><code class="name">var <span class="ident">GTD_CALC_ARGLOCS</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
GTD_CALC_ARGLOCS = 0</div></div>
</dd>
<dt id="ida_typeinf.GTD_CALC_LAYOUT"><code class="name">var <span class="ident">GTD_CALC_LAYOUT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
GTD_CALC_LAYOUT = 0</div></div>
</dd>
<dt id="ida_typeinf.GTD_DEL_BITFLDS"><code class="name">var <span class="ident">GTD_DEL_BITFLDS</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
GTD_DEL_BITFLDS = 64</div></div>
</dd>
<dt id="ida_typeinf.GTD_NO_ARGLOCS"><code class="name">var <span class="ident">GTD_NO_ARGLOCS</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
GTD_NO_ARGLOCS = 128</div></div>
</dd>
<dt id="ida_typeinf.GTD_NO_LAYOUT"><code class="name">var <span class="ident">GTD_NO_LAYOUT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
GTD_NO_LAYOUT = 128</div></div>
</dd>
<dt id="ida_typeinf.GTS_BASECLASS"><code class="name">var <span class="ident">GTS_BASECLASS</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
GTS_BASECLASS = 2</div></div>
</dd>
<dt id="ida_typeinf.GTS_NESTED"><code class="name">var <span class="ident">GTS_NESTED</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
GTS_NESTED = 1</div></div>
</dd>
<dt id="ida_typeinf.GUESS_FUNC_FAILED"><code class="name">var <span class="ident">GUESS_FUNC_FAILED</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
couldn't guess the function type</div></div>
</dd>
<dt id="ida_typeinf.GUESS_FUNC_OK"><code class="name">var <span class="ident">GUESS_FUNC_OK</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
ok, some non-trivial information is gathered</div></div>
</dd>
<dt id="ida_typeinf.GUESS_FUNC_TRIVIAL"><code class="name">var <span class="ident">GUESS_FUNC_TRIVIAL</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
the function type doesn't have interesting info</div></div>
</dd>
<dt id="ida_typeinf.HTI_CPP"><code class="name">var <span class="ident">HTI_CPP</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
C++ mode (not implemented)</div></div>
</dd>
<dt id="ida_typeinf.HTI_DCL"><code class="name">var <span class="ident">HTI_DCL</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
don't complain about redeclarations</div></div>
</dd>
<dt id="ida_typeinf.HTI_EXT"><code class="name">var <span class="ident">HTI_EXT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
debug: print external representation of types</div></div>
</dd>
<dt id="ida_typeinf.HTI_FIL"><code class="name">var <span class="ident">HTI_FIL</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
"input" is file name, otherwise "input" contains a C declaration</div></div>
</dd>
<dt id="ida_typeinf.HTI_HIGH"><code class="name">var <span class="ident">HTI_HIGH</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
assume high level prototypes (with hidden args, etc)</div></div>
</dd>
<dt id="ida_typeinf.HTI_INT"><code class="name">var <span class="ident">HTI_INT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
debug: print internal representation of types</div></div>
</dd>
<dt id="ida_typeinf.HTI_LEX"><code class="name">var <span class="ident">HTI_LEX</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
debug: print tokens</div></div>
</dd>
<dt id="ida_typeinf.HTI_LOWER"><code class="name">var <span class="ident">HTI_LOWER</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
lower the function prototypes</div></div>
</dd>
<dt id="ida_typeinf.HTI_MAC"><code class="name">var <span class="ident">HTI_MAC</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
define macros from the base tils</div></div>
</dd>
<dt id="ida_typeinf.HTI_NDC"><code class="name">var <span class="ident">HTI_NDC</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
don't decorate names</div></div>
</dd>
<dt id="ida_typeinf.HTI_NER"><code class="name">var <span class="ident">HTI_NER</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
ignore all errors but display them</div></div>
</dd>
<dt id="ida_typeinf.HTI_NWR"><code class="name">var <span class="ident">HTI_NWR</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
no warning messages</div></div>
</dd>
<dt id="ida_typeinf.HTI_PAK"><code class="name">var <span class="ident">HTI_PAK</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
explicit structure pack value (#pragma pack)</div></div>
</dd>
<dt id="ida_typeinf.HTI_PAK1"><code class="name">var <span class="ident">HTI_PAK1</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
#pragma pack(1)</div></div>
</dd>
<dt id="ida_typeinf.HTI_PAK16"><code class="name">var <span class="ident">HTI_PAK16</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
#pragma pack(16)</div></div>
</dd>
<dt id="ida_typeinf.HTI_PAK2"><code class="name">var <span class="ident">HTI_PAK2</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
#pragma pack(2)</div></div>
</dd>
<dt id="ida_typeinf.HTI_PAK4"><code class="name">var <span class="ident">HTI_PAK4</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
#pragma pack(4)</div></div>
</dd>
<dt id="ida_typeinf.HTI_PAK8"><code class="name">var <span class="ident">HTI_PAK8</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
#pragma pack(8)</div></div>
</dd>
<dt id="ida_typeinf.HTI_PAKDEF"><code class="name">var <span class="ident">HTI_PAKDEF</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
default pack value</div></div>
</dd>
<dt id="ida_typeinf.HTI_PAK_SHIFT"><code class="name">var <span class="ident">HTI_PAK_SHIFT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
shift for 'HTI_PAK' . This field should be used if you want to
remember an explicit pack value for each structure/union type. See
'HTI_PAK' ... definitions</div></div>
</dd>
<dt id="ida_typeinf.HTI_RAWARGS"><code class="name">var <span class="ident">HTI_RAWARGS</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
leave argument names unchanged (do not remove underscores)</div></div>
</dd>
<dt id="ida_typeinf.HTI_TST"><code class="name">var <span class="ident">HTI_TST</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
test mode: discard the result</div></div>
</dd>
<dt id="ida_typeinf.HTI_UNP"><code class="name">var <span class="ident">HTI_UNP</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
debug: check the result by unpacking it</div></div>
</dd>
<dt id="ida_typeinf.IMPTYPE_LOCAL"><code class="name">var <span class="ident">IMPTYPE_LOCAL</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
the type is local, the struct/enum won't be marked as til type. there
is no need to specify this bit if til==idati, the kernel will set it
automatically</div></div>
</dd>
<dt id="ida_typeinf.IMPTYPE_OVERRIDE"><code class="name">var <span class="ident">IMPTYPE_OVERRIDE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
override existing type</div></div>
</dd>
<dt id="ida_typeinf.IMPTYPE_VERBOSE"><code class="name">var <span class="ident">IMPTYPE_VERBOSE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
more verbose output (dialog boxes may appear)</div></div>
</dd>
<dt id="ida_typeinf.MAX_DECL_ALIGN"><code class="name">var <span class="ident">MAX_DECL_ALIGN</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
MAX_DECL_ALIGN = 15</div></div>
</dd>
<dt id="ida_typeinf.MAX_FUNC_ARGS"><code class="name">var <span class="ident">MAX_FUNC_ARGS</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
max number of function arguments</div></div>
</dd>
<dt id="ida_typeinf.NTF_64BIT"><code class="name">var <span class="ident">NTF_64BIT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
value is 64bit</div></div>
</dd>
<dt id="ida_typeinf.NTF_CHKSYNC"><code class="name">var <span class="ident">NTF_CHKSYNC</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
check that synchronization to IDB passed OK (set_numbered_type,
set_named_type)</div></div>
</dd>
<dt id="ida_typeinf.NTF_FIXNAME"><code class="name">var <span class="ident">NTF_FIXNAME</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
force-validate the name of the type when setting (set_named_type,
set_numbered_type only)</div></div>
</dd>
<dt id="ida_typeinf.NTF_IDBENC"><code class="name">var <span class="ident">NTF_IDBENC</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
the name is given in the IDB encoding; non-ASCII bytes will be decoded
accordingly (set_named_type, set_numbered_type only)</div></div>
</dd>
<dt id="ida_typeinf.NTF_NOBASE"><code class="name">var <span class="ident">NTF_NOBASE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
don't inspect base tils (for get_named_type)</div></div>
</dd>
<dt id="ida_typeinf.NTF_NOCUR"><code class="name">var <span class="ident">NTF_NOCUR</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
don't inspect current til file (for get_named_type)</div></div>
</dd>
<dt id="ida_typeinf.NTF_REPLACE"><code class="name">var <span class="ident">NTF_REPLACE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
replace original type (for set_named_type)</div></div>
</dd>
<dt id="ida_typeinf.NTF_SYMM"><code class="name">var <span class="ident">NTF_SYMM</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
symbol, name is mangled ('_func') only one of 'NTF_TYPE' and
'NTF_SYMU' , 'NTF_SYMM' can be used</div></div>
</dd>
<dt id="ida_typeinf.NTF_SYMU"><code class="name">var <span class="ident">NTF_SYMU</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
symbol, name is unmangled ('func')</div></div>
</dd>
<dt id="ida_typeinf.NTF_TYPE"><code class="name">var <span class="ident">NTF_TYPE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
type name</div></div>
</dd>
<dt id="ida_typeinf.NTF_UMANGLED"><code class="name">var <span class="ident">NTF_UMANGLED</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
name is unmangled (don't use this flag)</div></div>
</dd>
<dt id="ida_typeinf.PCN_CHR"><code class="name">var <span class="ident">PCN_CHR</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
character</div></div>
</dd>
<dt id="ida_typeinf.PCN_DEC"><code class="name">var <span class="ident">PCN_DEC</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
decimal</div></div>
</dd>
<dt id="ida_typeinf.PCN_DECSEXT"><code class="name">var <span class="ident">PCN_DECSEXT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
automatically extend sign of signed decimal numbers</div></div>
</dd>
<dt id="ida_typeinf.PCN_HEX"><code class="name">var <span class="ident">PCN_HEX</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
hexadecimal</div></div>
</dd>
<dt id="ida_typeinf.PCN_LZHEX"><code class="name">var <span class="ident">PCN_LZHEX</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
print leading zeroes for hexdecimal number</div></div>
</dd>
<dt id="ida_typeinf.PCN_NEGSIGN"><code class="name">var <span class="ident">PCN_NEGSIGN</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
print negated value (-N) for negative numbers</div></div>
</dd>
<dt id="ida_typeinf.PCN_OCT"><code class="name">var <span class="ident">PCN_OCT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
octal</div></div>
</dd>
<dt id="ida_typeinf.PCN_RADIX"><code class="name">var <span class="ident">PCN_RADIX</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
number base to use</div></div>
</dd>
<dt id="ida_typeinf.PCN_UNSIGNED"><code class="name">var <span class="ident">PCN_UNSIGNED</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
add 'u' suffix</div></div>
</dd>
<dt id="ida_typeinf.PDF_DEF_BASE"><code class="name">var <span class="ident">PDF_DEF_BASE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Include base types: __int8, __int16, etc..</div></div>
</dd>
<dt id="ida_typeinf.PDF_DEF_FWD"><code class="name">var <span class="ident">PDF_DEF_FWD</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Allow forward declarations.</div></div>
</dd>
<dt id="ida_typeinf.PDF_HEADER_CMT"><code class="name">var <span class="ident">PDF_HEADER_CMT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Prepend output with a descriptive comment.</div></div>
</dd>
<dt id="ida_typeinf.PDF_INCL_DEPS"><code class="name">var <span class="ident">PDF_INCL_DEPS</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Include all type dependencies.</div></div>
</dd>
<dt id="ida_typeinf.PIO_IGNORE_PTRS"><code class="name">var <span class="ident">PIO_IGNORE_PTRS</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
do not follow pointers</div></div>
</dd>
<dt id="ida_typeinf.PIO_NOATTR_FAIL"><code class="name">var <span class="ident">PIO_NOATTR_FAIL</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
missing attributes are not ok</div></div>
</dd>
<dt id="ida_typeinf.PRALOC_STKOFF"><code class="name">var <span class="ident">PRALOC_STKOFF</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
print stack offsets</div></div>
</dd>
<dt id="ida_typeinf.PRALOC_VERIFY"><code class="name">var <span class="ident">PRALOC_VERIFY</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
interr if illegal argloc</div></div>
</dd>
<dt id="ida_typeinf.PRTYPE_1LINE"><code class="name">var <span class="ident">PRTYPE_1LINE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
print to one line</div></div>
</dd>
<dt id="ida_typeinf.PRTYPE_COLORED"><code class="name">var <span class="ident">PRTYPE_COLORED</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
add color tag COLOR_SYMBOL for any parentheses, commas and colons</div></div>
</dd>
<dt id="ida_typeinf.PRTYPE_CPP"><code class="name">var <span class="ident">PRTYPE_CPP</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
use c++ name (only for 'print_type()' )</div></div>
</dd>
<dt id="ida_typeinf.PRTYPE_DEF"><code class="name">var <span class="ident">PRTYPE_DEF</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
'tinfo_t' : print definition, if available</div></div>
</dd>
<dt id="ida_typeinf.PRTYPE_MULTI"><code class="name">var <span class="ident">PRTYPE_MULTI</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
print to many lines</div></div>
</dd>
<dt id="ida_typeinf.PRTYPE_NOARGS"><code class="name">var <span class="ident">PRTYPE_NOARGS</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
'tinfo_t' : do not print function argument names</div></div>
</dd>
<dt id="ida_typeinf.PRTYPE_NOARRS"><code class="name">var <span class="ident">PRTYPE_NOARRS</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
'tinfo_t' : print arguments with 'FAI_ARRAY' as pointers</div></div>
</dd>
<dt id="ida_typeinf.PRTYPE_NOREGEX"><code class="name">var <span class="ident">PRTYPE_NOREGEX</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
do not apply regular expressions to beautify name</div></div>
</dd>
<dt id="ida_typeinf.PRTYPE_NORES"><code class="name">var <span class="ident">PRTYPE_NORES</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
'tinfo_t' : never resolve types (meaningful with PRTYPE_DEF)</div></div>
</dd>
<dt id="ida_typeinf.PRTYPE_PRAGMA"><code class="name">var <span class="ident">PRTYPE_PRAGMA</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
print pragmas for alignment</div></div>
</dd>
<dt id="ida_typeinf.PRTYPE_RESTORE"><code class="name">var <span class="ident">PRTYPE_RESTORE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
'tinfo_t' : print restored types for 'FAI_ARRAY' and 'FAI_STRUCT'</div></div>
</dd>
<dt id="ida_typeinf.PRTYPE_SEMI"><code class="name">var <span class="ident">PRTYPE_SEMI</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
append ; to the end</div></div>
</dd>
<dt id="ida_typeinf.PRTYPE_TYPE"><code class="name">var <span class="ident">PRTYPE_TYPE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
print type declaration (not variable declaration)</div></div>
</dd>
<dt id="ida_typeinf.PT_FILE"><code class="name">var <span class="ident">PT_FILE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
PT_FILE = 65536</div></div>
</dd>
<dt id="ida_typeinf.PT_HIGH"><code class="name">var <span class="ident">PT_HIGH</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
assume high level prototypes (with hidden args, etc)</div></div>
</dd>
<dt id="ida_typeinf.PT_LOWER"><code class="name">var <span class="ident">PT_LOWER</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
lower the function prototypes</div></div>
</dd>
<dt id="ida_typeinf.PT_NDC"><code class="name">var <span class="ident">PT_NDC</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
don't decorate names</div></div>
</dd>
<dt id="ida_typeinf.PT_PACKMASK"><code class="name">var <span class="ident">PT_PACKMASK</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
mask for pack alignment values</div></div>
</dd>
<dt id="ida_typeinf.PT_RAWARGS"><code class="name">var <span class="ident">PT_RAWARGS</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
leave argument names unchanged (do not remove underscores)</div></div>
</dd>
<dt id="ida_typeinf.PT_REPLACE"><code class="name">var <span class="ident">PT_REPLACE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
replace the old type (used in idc)</div></div>
</dd>
<dt id="ida_typeinf.PT_SIL"><code class="name">var <span class="ident">PT_SIL</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
silent, no messages</div></div>
</dd>
<dt id="ida_typeinf.PT_TYP"><code class="name">var <span class="ident">PT_TYP</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
return declared type information</div></div>
</dd>
<dt id="ida_typeinf.PT_VAR"><code class="name">var <span class="ident">PT_VAR</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
return declared object information</div></div>
</dd>
<dt id="ida_typeinf.RESERVED_BYTE"><code class="name">var <span class="ident">RESERVED_BYTE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
multifunctional purpose</div></div>
</dd>
<dt id="ida_typeinf.SETCOMP_BY_USER"><code class="name">var <span class="ident">SETCOMP_BY_USER</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
invoked by user, cannot be replaced by module/loader</div></div>
</dd>
<dt id="ida_typeinf.SETCOMP_ONLY_ABI"><code class="name">var <span class="ident">SETCOMP_ONLY_ABI</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
ignore cc field complete, use only abiname</div></div>
</dd>
<dt id="ida_typeinf.SETCOMP_ONLY_ID"><code class="name">var <span class="ident">SETCOMP_ONLY_ID</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
cc has only 'id' field the rest will be set to defaults corresponding
to the program bitness</div></div>
</dd>
<dt id="ida_typeinf.SETCOMP_OVERRIDE"><code class="name">var <span class="ident">SETCOMP_OVERRIDE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
may override old compiler info</div></div>
</dd>
<dt id="ida_typeinf.STI_ACCHAR"><code class="name">var <span class="ident">STI_ACCHAR</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
STI_ACCHAR = 12</div></div>
</dd>
<dt id="ida_typeinf.STI_ACHAR"><code class="name">var <span class="ident">STI_ACHAR</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
STI_ACHAR = 10</div></div>
</dd>
<dt id="ida_typeinf.STI_ACUCHAR"><code class="name">var <span class="ident">STI_ACUCHAR</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
STI_ACUCHAR = 13</div></div>
</dd>
<dt id="ida_typeinf.STI_AEABI_LCMP"><code class="name">var <span class="ident">STI_AEABI_LCMP</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
STI_AEABI_LCMP = 17</div></div>
</dd>
<dt id="ida_typeinf.STI_AEABI_MEMCLR"><code class="name">var <span class="ident">STI_AEABI_MEMCLR</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
STI_AEABI_MEMCLR = 24</div></div>
</dd>
<dt id="ida_typeinf.STI_AEABI_MEMCPY"><code class="name">var <span class="ident">STI_AEABI_MEMCPY</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
STI_AEABI_MEMCPY = 22</div></div>
</dd>
<dt id="ida_typeinf.STI_AEABI_MEMSET"><code class="name">var <span class="ident">STI_AEABI_MEMSET</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
STI_AEABI_MEMSET = 23</div></div>
</dd>
<dt id="ida_typeinf.STI_AEABI_ULCMP"><code class="name">var <span class="ident">STI_AEABI_ULCMP</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
STI_AEABI_ULCMP = 18</div></div>
</dd>
<dt id="ida_typeinf.STI_AUCHAR"><code class="name">var <span class="ident">STI_AUCHAR</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
STI_AUCHAR = 11</div></div>
</dd>
<dt id="ida_typeinf.STI_DONT_USE"><code class="name">var <span class="ident">STI_DONT_USE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
STI_DONT_USE = 19</div></div>
</dd>
<dt id="ida_typeinf.STI_FDELOP"><code class="name">var <span class="ident">STI_FDELOP</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
STI_FDELOP = 15</div></div>
</dd>
<dt id="ida_typeinf.STI_FPURGING"><code class="name">var <span class="ident">STI_FPURGING</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
STI_FPURGING = 14</div></div>
</dd>
<dt id="ida_typeinf.STI_LAST"><code class="name">var <span class="ident">STI_LAST</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
STI_LAST = 28</div></div>
</dd>
<dt id="ida_typeinf.STI_MSGSEND"><code class="name">var <span class="ident">STI_MSGSEND</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
STI_MSGSEND = 16</div></div>
</dd>
<dt id="ida_typeinf.STI_PBYTE"><code class="name">var <span class="ident">STI_PBYTE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
STI_PBYTE = 4</div></div>
</dd>
<dt id="ida_typeinf.STI_PCCHAR"><code class="name">var <span class="ident">STI_PCCHAR</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
STI_PCCHAR = 2</div></div>
</dd>
<dt id="ida_typeinf.STI_PCHAR"><code class="name">var <span class="ident">STI_PCHAR</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
STI_PCHAR = 0</div></div>
</dd>
<dt id="ida_typeinf.STI_PCUCHAR"><code class="name">var <span class="ident">STI_PCUCHAR</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
STI_PCUCHAR = 3</div></div>
</dd>
<dt id="ida_typeinf.STI_PCVOID"><code class="name">var <span class="ident">STI_PCVOID</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
STI_PCVOID = 9</div></div>
</dd>
<dt id="ida_typeinf.STI_PINT"><code class="name">var <span class="ident">STI_PINT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
STI_PINT = 5</div></div>
</dd>
<dt id="ida_typeinf.STI_PPVOID"><code class="name">var <span class="ident">STI_PPVOID</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
STI_PPVOID = 8</div></div>
</dd>
<dt id="ida_typeinf.STI_PUCHAR"><code class="name">var <span class="ident">STI_PUCHAR</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
STI_PUCHAR = 1</div></div>
</dd>
<dt id="ida_typeinf.STI_PUINT"><code class="name">var <span class="ident">STI_PUINT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
STI_PUINT = 6</div></div>
</dd>
<dt id="ida_typeinf.STI_PVOID"><code class="name">var <span class="ident">STI_PVOID</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
STI_PVOID = 7</div></div>
</dd>
<dt id="ida_typeinf.STI_RTC_CHECK_2"><code class="name">var <span class="ident">STI_RTC_CHECK_2</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
STI_RTC_CHECK_2 = 25</div></div>
</dd>
<dt id="ida_typeinf.STI_RTC_CHECK_4"><code class="name">var <span class="ident">STI_RTC_CHECK_4</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
STI_RTC_CHECK_4 = 26</div></div>
</dd>
<dt id="ida_typeinf.STI_RTC_CHECK_8"><code class="name">var <span class="ident">STI_RTC_CHECK_8</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
STI_RTC_CHECK_8 = 27</div></div>
</dd>
<dt id="ida_typeinf.STI_SIZE_T"><code class="name">var <span class="ident">STI_SIZE_T</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
STI_SIZE_T = 20</div></div>
</dd>
<dt id="ida_typeinf.STI_SSIZE_T"><code class="name">var <span class="ident">STI_SSIZE_T</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
STI_SSIZE_T = 21</div></div>
</dd>
<dt id="ida_typeinf.STRMEM_ANON"><code class="name">var <span class="ident">STRMEM_ANON</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
can be combined with 'STRMEM_NAME' : look inside anonymous members
too.</div></div>
</dd>
<dt id="ida_typeinf.STRMEM_AUTO"><code class="name">var <span class="ident">STRMEM_AUTO</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
get member by offset if struct, or get member by index if unionnb:
union: index is stored in the udm-&gt;offset field!nb: struct: offset is
in bytes (not in bits)!</div></div>
</dd>
<dt id="ida_typeinf.STRMEM_CASTABLE_TO"><code class="name">var <span class="ident">STRMEM_CASTABLE_TO</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
can be combined with 'STRMEM_TYPE' : member type must be castable to
the specified type</div></div>
</dd>
<dt id="ida_typeinf.STRMEM_INDEX"><code class="name">var <span class="ident">STRMEM_INDEX</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
get member by numberin: udm-&gt;offset - is a member number</div></div>
</dd>
<dt id="ida_typeinf.STRMEM_MASK"><code class="name">var <span class="ident">STRMEM_MASK</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
STRMEM_MASK = 7</div></div>
</dd>
<dt id="ida_typeinf.STRMEM_MAXS"><code class="name">var <span class="ident">STRMEM_MAXS</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
get biggest member by size.</div></div>
</dd>
<dt id="ida_typeinf.STRMEM_MINS"><code class="name">var <span class="ident">STRMEM_MINS</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
get smallest member by size.</div></div>
</dd>
<dt id="ida_typeinf.STRMEM_NAME"><code class="name">var <span class="ident">STRMEM_NAME</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
get member by namein: udm-&gt;name - the desired member name.</div></div>
</dd>
<dt id="ida_typeinf.STRMEM_OFFSET"><code class="name">var <span class="ident">STRMEM_OFFSET</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
get member by offsetin: udm-&gt;offset - is a member offset in bits</div></div>
</dd>
<dt id="ida_typeinf.STRMEM_SIZE"><code class="name">var <span class="ident">STRMEM_SIZE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
get member by size.in: udm-&gt;size - the desired member size.</div></div>
</dd>
<dt id="ida_typeinf.STRMEM_SKIP_EMPTY"><code class="name">var <span class="ident">STRMEM_SKIP_EMPTY</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
can be combined with 'STRMEM_OFFSET' , 'STRMEM_AUTO' skip empty
members (i.e. having zero size) only last empty member can be returned</div></div>
</dd>
<dt id="ida_typeinf.STRMEM_TYPE"><code class="name">var <span class="ident">STRMEM_TYPE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
get member by type.in: udm-&gt;type - the desired member type. member
types are compared with tinfo_t::equals_to()</div></div>
</dd>
<dt id="ida_typeinf.STRMEM_VFTABLE"><code class="name">var <span class="ident">STRMEM_VFTABLE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
can be combined with 'STRMEM_OFFSET' , 'STRMEM_AUTO' get vftable
instead of the base class</div></div>
</dd>
<dt id="ida_typeinf.SUDT_ALIGN"><code class="name">var <span class="ident">SUDT_ALIGN</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
recalculate field alignments, struct packing, etc to match the offsets
and size info</div></div>
</dd>
<dt id="ida_typeinf.SUDT_CONST"><code class="name">var <span class="ident">SUDT_CONST</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
only for serialize_udt: make type const</div></div>
</dd>
<dt id="ida_typeinf.SUDT_FAST"><code class="name">var <span class="ident">SUDT_FAST</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
serialize without verifying offsets and alignments</div></div>
</dd>
<dt id="ida_typeinf.SUDT_GAPS"><code class="name">var <span class="ident">SUDT_GAPS</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
allow to fill gaps with additional members (_BYTE[])</div></div>
</dd>
<dt id="ida_typeinf.SUDT_SORT"><code class="name">var <span class="ident">SUDT_SORT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
fields are not sorted by offset, sort them first</div></div>
</dd>
<dt id="ida_typeinf.SUDT_TRUNC"><code class="name">var <span class="ident">SUDT_TRUNC</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
serialize: truncate useless strings from fields, fldcmts</div></div>
</dd>
<dt id="ida_typeinf.SUDT_UNEX"><code class="name">var <span class="ident">SUDT_UNEX</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
references to nonexistent member types are acceptable in this case it
is better to set the corresponding 'udt_member_t::fda' field to the
type alignment. if this field is not set, ida will try to guess the
alignment.</div></div>
</dd>
<dt id="ida_typeinf.SUDT_VOLATILE"><code class="name">var <span class="ident">SUDT_VOLATILE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
only for serialize_udt: make type volatile</div></div>
</dd>
<dt id="ida_typeinf.TAENUM_64BIT"><code class="name">var <span class="ident">TAENUM_64BIT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
enum: store 64-bit values</div></div>
</dd>
<dt id="ida_typeinf.TAENUM_SIGNED"><code class="name">var <span class="ident">TAENUM_SIGNED</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
enum: signed</div></div>
</dd>
<dt id="ida_typeinf.TAENUM_UNSIGNED"><code class="name">var <span class="ident">TAENUM_UNSIGNED</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
enum: unsigned</div></div>
</dd>
<dt id="ida_typeinf.TAFLD_BASECLASS"><code class="name">var <span class="ident">TAFLD_BASECLASS</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
field: do not include but inherit from the current field</div></div>
</dd>
<dt id="ida_typeinf.TAFLD_UNALIGNED"><code class="name">var <span class="ident">TAFLD_UNALIGNED</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
field: unaligned field</div></div>
</dd>
<dt id="ida_typeinf.TAFLD_VFTABLE"><code class="name">var <span class="ident">TAFLD_VFTABLE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
field: ptr to virtual function table</div></div>
</dd>
<dt id="ida_typeinf.TAFLD_VIRTBASE"><code class="name">var <span class="ident">TAFLD_VIRTBASE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
field: virtual base (not supported yet)</div></div>
</dd>
<dt id="ida_typeinf.TAH_ALL"><code class="name">var <span class="ident">TAH_ALL</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
all defined bits</div></div>
</dd>
<dt id="ida_typeinf.TAH_BYTE"><code class="name">var <span class="ident">TAH_BYTE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
type attribute header byte</div></div>
</dd>
<dt id="ida_typeinf.TAH_HASATTRS"><code class="name">var <span class="ident">TAH_HASATTRS</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
has extended attributes</div></div>
</dd>
<dt id="ida_typeinf.TAPTR_PTR32"><code class="name">var <span class="ident">TAPTR_PTR32</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
ptr: __ptr32</div></div>
</dd>
<dt id="ida_typeinf.TAPTR_PTR64"><code class="name">var <span class="ident">TAPTR_PTR64</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
ptr: __ptr64</div></div>
</dd>
<dt id="ida_typeinf.TAPTR_RESTRICT"><code class="name">var <span class="ident">TAPTR_RESTRICT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
ptr: __restrict</div></div>
</dd>
<dt id="ida_typeinf.TAPTR_SHIFTED"><code class="name">var <span class="ident">TAPTR_SHIFTED</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
ptr: __shifted(parent_struct, delta)</div></div>
</dd>
<dt id="ida_typeinf.TAUDT_CPPOBJ"><code class="name">var <span class="ident">TAUDT_CPPOBJ</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
struct: a c++ object, not simple pod type</div></div>
</dd>
<dt id="ida_typeinf.TAUDT_MSSTRUCT"><code class="name">var <span class="ident">TAUDT_MSSTRUCT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
struct: gcc msstruct attribute</div></div>
</dd>
<dt id="ida_typeinf.TAUDT_UNALIGNED"><code class="name">var <span class="ident">TAUDT_UNALIGNED</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
struct: unaligned struct</div></div>
</dd>
<dt id="ida_typeinf.TAUDT_VFTABLE"><code class="name">var <span class="ident">TAUDT_VFTABLE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
struct: is virtual function table</div></div>
</dd>
<dt id="ida_typeinf.TA_FORMAT"><code class="name">var <span class="ident">TA_FORMAT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
info about the 'format' argument 3 times pack_dd: 'format_functype_t'
, argument number of 'format', argument number of '...'</div></div>
</dd>
<dt id="ida_typeinf.TA_ORG_ARRDIM"><code class="name">var <span class="ident">TA_ORG_ARRDIM</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
the original array dimension (pack_dd)</div></div>
</dd>
<dt id="ida_typeinf.TA_ORG_TYPEDEF"><code class="name">var <span class="ident">TA_ORG_TYPEDEF</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
the original typedef name (simple string)</div></div>
</dd>
<dt id="ida_typeinf.TCMP_ANYBASE"><code class="name">var <span class="ident">TCMP_ANYBASE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
accept any base class when casting</div></div>
</dd>
<dt id="ida_typeinf.TCMP_AUTOCAST"><code class="name">var <span class="ident">TCMP_AUTOCAST</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
can t1 be cast into t2 automatically?</div></div>
</dd>
<dt id="ida_typeinf.TCMP_CALL"><code class="name">var <span class="ident">TCMP_CALL</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
can t1 be called with t2 type?</div></div>
</dd>
<dt id="ida_typeinf.TCMP_DECL"><code class="name">var <span class="ident">TCMP_DECL</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
compare declarations without resolving them</div></div>
</dd>
<dt id="ida_typeinf.TCMP_DELPTR"><code class="name">var <span class="ident">TCMP_DELPTR</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
remove pointer from types before comparing</div></div>
</dd>
<dt id="ida_typeinf.TCMP_EQUAL"><code class="name">var <span class="ident">TCMP_EQUAL</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
are types equal?</div></div>
</dd>
<dt id="ida_typeinf.TCMP_IGNMODS"><code class="name">var <span class="ident">TCMP_IGNMODS</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
ignore const/volatile modifiers</div></div>
</dd>
<dt id="ida_typeinf.TCMP_MANCAST"><code class="name">var <span class="ident">TCMP_MANCAST</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
can t1 be cast into t2 manually?</div></div>
</dd>
<dt id="ida_typeinf.TCMP_SKIPTHIS"><code class="name">var <span class="ident">TCMP_SKIPTHIS</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
skip the first function argument in comparison</div></div>
</dd>
<dt id="ida_typeinf.TERR_BADSYNC"><code class="name">var <span class="ident">TERR_BADSYNC</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
TERR_BADSYNC = -4</div></div>
</dd>
<dt id="ida_typeinf.TERR_OK"><code class="name">var <span class="ident">TERR_OK</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
TERR_OK = 0</div></div>
</dd>
<dt id="ida_typeinf.TERR_SAVE"><code class="name">var <span class="ident">TERR_SAVE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
TERR_SAVE = -1</div></div>
</dd>
<dt id="ida_typeinf.TERR_SERIALIZE"><code class="name">var <span class="ident">TERR_SERIALIZE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
TERR_SERIALIZE = -2</div></div>
</dd>
<dt id="ida_typeinf.TERR_WRONGNAME"><code class="name">var <span class="ident">TERR_WRONGNAME</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
TERR_WRONGNAME = -3</div></div>
</dd>
<dt id="ida_typeinf.TIL_ADD_ALREADY"><code class="name">var <span class="ident">TIL_ADD_ALREADY</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
the base til was already added</div></div>
</dd>
<dt id="ida_typeinf.TIL_ADD_FAILED"><code class="name">var <span class="ident">TIL_ADD_FAILED</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
see errbuf</div></div>
</dd>
<dt id="ida_typeinf.TIL_ADD_OK"><code class="name">var <span class="ident">TIL_ADD_OK</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
some tils were added</div></div>
</dd>
<dt id="ida_typeinf.TIL_ALI"><code class="name">var <span class="ident">TIL_ALI</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
type aliases are present (this bit is used only on the disk)</div></div>
</dd>
<dt id="ida_typeinf.TIL_ESI"><code class="name">var <span class="ident">TIL_ESI</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
extended sizeof info (short, long, longlong)</div></div>
</dd>
<dt id="ida_typeinf.TIL_MAC"><code class="name">var <span class="ident">TIL_MAC</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
til has macro table</div></div>
</dd>
<dt id="ida_typeinf.TIL_MOD"><code class="name">var <span class="ident">TIL_MOD</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
til has been modified, should be saved</div></div>
</dd>
<dt id="ida_typeinf.TIL_ORD"><code class="name">var <span class="ident">TIL_ORD</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
type ordinal numbers are present</div></div>
</dd>
<dt id="ida_typeinf.TIL_SLD"><code class="name">var <span class="ident">TIL_SLD</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
sizeof(long double)</div></div>
</dd>
<dt id="ida_typeinf.TIL_STM"><code class="name">var <span class="ident">TIL_STM</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
til has extra streams</div></div>
</dd>
<dt id="ida_typeinf.TIL_UNI"><code class="name">var <span class="ident">TIL_UNI</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
universal til for any compiler</div></div>
</dd>
<dt id="ida_typeinf.TIL_ZIP"><code class="name">var <span class="ident">TIL_ZIP</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
pack buckets using zip</div></div>
</dd>
<dt id="ida_typeinf.TINFO_DEFINITE"><code class="name">var <span class="ident">TINFO_DEFINITE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
this is a definite type</div></div>
</dd>
<dt id="ida_typeinf.TINFO_DELAYFUNC"><code class="name">var <span class="ident">TINFO_DELAYFUNC</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
if type is a function and no function exists at ea, schedule its
creation and argument renaming to auto-analysis otherwise try to
create it immediately</div></div>
</dd>
<dt id="ida_typeinf.TINFO_GUESSED"><code class="name">var <span class="ident">TINFO_GUESSED</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
this is a guessed type</div></div>
</dd>
<dt id="ida_typeinf.TINFO_STRICT"><code class="name">var <span class="ident">TINFO_STRICT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
never convert given type to another one before applying</div></div>
</dd>
<dt id="ida_typeinf.TPOS_LNNUM"><code class="name">var <span class="ident">TPOS_LNNUM</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
TPOS_LNNUM = '\x05'</div></div>
</dd>
<dt id="ida_typeinf.TVIS_CMT"><code class="name">var <span class="ident">TVIS_CMT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
new comment is present</div></div>
</dd>
<dt id="ida_typeinf.TVIS_NAME"><code class="name">var <span class="ident">TVIS_NAME</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
new name is present</div></div>
</dd>
<dt id="ida_typeinf.TVIS_TYPE"><code class="name">var <span class="ident">TVIS_TYPE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
new type info is present</div></div>
</dd>
<dt id="ida_typeinf.TVST_DEF"><code class="name">var <span class="ident">TVST_DEF</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
visit type definition (meaningful for typerefs)</div></div>
</dd>
<dt id="ida_typeinf.TVST_LEVEL"><code class="name">var <span class="ident">TVST_LEVEL</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
TVST_LEVEL = 4</div></div>
</dd>
<dt id="ida_typeinf.TVST_PRUNE"><code class="name">var <span class="ident">TVST_PRUNE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
don't visit children of current type</div></div>
</dd>
<dt id="ida_typeinf.TYPE_BASE_MASK"><code class="name">var <span class="ident">TYPE_BASE_MASK</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
TYPE_BASE_MASK = 15</div></div>
</dd>
<dt id="ida_typeinf.TYPE_FLAGS_MASK"><code class="name">var <span class="ident">TYPE_FLAGS_MASK</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
TYPE_FLAGS_MASK = 48</div></div>
</dd>
<dt id="ida_typeinf.TYPE_FULL_MASK"><code class="name">var <span class="ident">TYPE_FULL_MASK</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
TYPE_FULL_MASK = 63</div></div>
</dd>
<dt id="ida_typeinf.TYPE_MODIF_MASK"><code class="name">var <span class="ident">TYPE_MODIF_MASK</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
TYPE_MODIF_MASK = 192</div></div>
</dd>
<dt id="ida_typeinf.TYPID_ISREF"><code class="name">var <span class="ident">TYPID_ISREF</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
TYPID_ISREF = 256</div></div>
</dd>
<dt id="ida_typeinf.TYPID_SHIFT"><code class="name">var <span class="ident">TYPID_SHIFT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
TYPID_SHIFT = 9</div></div>
</dd>
<dt id="ida_typeinf.UTP_ENUM"><code class="name">var <span class="ident">UTP_ENUM</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
UTP_ENUM = 0</div></div>
</dd>
<dt id="ida_typeinf.UTP_STRUCT"><code class="name">var <span class="ident">UTP_STRUCT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
UTP_STRUCT = 1</div></div>
</dd>
<dt id="ida_typeinf.VALSTR_OPEN"><code class="name">var <span class="ident">VALSTR_OPEN</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
printed opening curly brace '{'</div></div>
</dd>
<dt id="ida_typeinf.VTBL_MEMNAME"><code class="name">var <span class="ident">VTBL_MEMNAME</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
VTBL_MEMNAME = '__vftable'</div></div>
</dd>
<dt id="ida_typeinf.VTBL_SUFFIX"><code class="name">var <span class="ident">VTBL_SUFFIX</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
VTBL_SUFFIX = '_vtbl'</div></div>
</dd>
<dt id="ida_typeinf.abs_no"><code class="name">var <span class="ident">abs_no</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
abs_no = 1</div></div>
</dd>
<dt id="ida_typeinf.abs_unk"><code class="name">var <span class="ident">abs_unk</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
abs_unk = 0</div></div>
</dd>
<dt id="ida_typeinf.abs_yes"><code class="name">var <span class="ident">abs_yes</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
abs_yes = 2</div></div>
</dd>
<dt id="ida_typeinf.no_sign"><code class="name">var <span class="ident">no_sign</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
no_sign = 0</div></div>
</dd>
<dt id="ida_typeinf.sc_auto"><code class="name">var <span class="ident">sc_auto</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
sc_auto = 5</div></div>
</dd>
<dt id="ida_typeinf.sc_ext"><code class="name">var <span class="ident">sc_ext</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
sc_ext = 2</div></div>
</dd>
<dt id="ida_typeinf.sc_friend"><code class="name">var <span class="ident">sc_friend</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
sc_friend = 6</div></div>
</dd>
<dt id="ida_typeinf.sc_reg"><code class="name">var <span class="ident">sc_reg</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
sc_reg = 4</div></div>
</dd>
<dt id="ida_typeinf.sc_stat"><code class="name">var <span class="ident">sc_stat</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
sc_stat = 3</div></div>
</dd>
<dt id="ida_typeinf.sc_type"><code class="name">var <span class="ident">sc_type</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
sc_type = 1</div></div>
</dd>
<dt id="ida_typeinf.sc_unk"><code class="name">var <span class="ident">sc_unk</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
sc_unk = 0</div></div>
</dd>
<dt id="ida_typeinf.sc_virt"><code class="name">var <span class="ident">sc_virt</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
sc_virt = 7</div></div>
</dd>
<dt id="ida_typeinf.type_signed"><code class="name">var <span class="ident">type_signed</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
type_signed = 1</div></div>
</dd>
<dt id="ida_typeinf.type_unsigned"><code class="name">var <span class="ident">type_unsigned</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
type_unsigned = 2</div></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="ida_typeinf.add_til"><code class="name flex">
<span>def <span class="ident">add_til</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Load a til file.</div>
<div class="epy_par">
<strong class="epy_sig">add_til(name, flags) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">name</strong>: til name (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">flags</strong>: combination of
Load TIL flags (C++: int)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: one of
Load TIL result codes</div>
</div></div>
</dd>
<dt id="ida_typeinf.alloc_type_ordinal"><code class="name flex">
<span>def <span class="ident">alloc_type_ordinal</span></span>(<span>*args) &#8209;&gt;&#160;uint32</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
\call2{alloc_type_ordinals,ti,1}</div>
<div class="epy_par">
<strong class="epy_sig">alloc_type_ordinal(ti) -&gt; uint32</strong><div class="epy_nested">
<strong class="epy_parameter">ti</strong> (C++: til_t
*)</div>
</div></div>
</dd>
<dt id="ida_typeinf.alloc_type_ordinals"><code class="name flex">
<span>def <span class="ident">alloc_type_ordinals</span></span>(<span>*args) &#8209;&gt;&#160;uint32</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Allocate a range of ordinal numbers for new types.</div>
<div class="epy_par">
<strong class="epy_sig">alloc_type_ordinals(ti, qty) -&gt; uint32</strong><div class="epy_nested">
<strong class="epy_parameter">ti</strong>: type library (C++: til_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">qty</strong>: number of ordinals to allocate (C++: int)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: the first ordinal. 0 means failure.</div>
</div></div>
</dd>
<dt id="ida_typeinf.append_abi_opts"><code class="name flex">
<span>def <span class="ident">append_abi_opts</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Add/remove/check ABI option General form of full abi name: abiname-
opt1-opt2-... or -opt1-opt2-...</div>
<div class="epy_par">
<strong class="epy_sig">append_abi_opts(abi_opts, user_level=False) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">abi_opts</strong>: - ABI options to add/remove in form opt1-opt2-...<div class="epy_nested">
(C++: const char *)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">user_level</strong>: - initiated by user if TRUE (==SETCOMP_BY_USER)<div class="epy_nested">
(C++: bool)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: success</div>
</div></div>
</dd>
<dt id="ida_typeinf.append_argloc"><code class="name flex">
<span>def <span class="ident">append_argloc</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Serialize argument location Deserialize an argument location. Argument
FORBID_STKOFF check location type. It can be used, for example, to
check the return location of a function that cannot return a value in
the stack</div>
<div class="epy_par">
<strong class="epy_sig">append_argloc(out, vloc) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">out</strong> (C++: qtype
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">vloc</strong> (C++: const
argloc_t
&amp;)</div>
</div></div>
</dd>
<dt id="ida_typeinf.append_tinfo_covered"><code class="name flex">
<span>def <span class="ident">append_tinfo_covered</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">append_tinfo_covered(out, typid, offset) -&gt; bool</strong><div class="epy_nested">
out: rangeset_t *
typid: uint32
offset: uint64</div>
</div></div>
</dd>
<dt id="ida_typeinf.apply_callee_tinfo"><code class="name flex">
<span>def <span class="ident">apply_callee_tinfo</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Apply the type of the called function to the calling instruction. This
function will append parameter comments and rename the local variables
of the calling function. It also stores information about the
instructions that initialize call arguments in the database. Use
'get_arg_addrs()' to retrieve it if necessary. Alternatively it is
possible to hook to processor_t::arg_addrs_ready event.</div>
<div class="epy_par">
<strong class="epy_sig">apply_callee_tinfo(caller, tif) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">caller</strong>: linear address of the calling instruction. must belong<div class="epy_nested">
to a function. (C++: ea_t)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">tif</strong>: type info (C++: const
tinfo_t
&amp;)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: success</div>
</div></div>
</dd>
<dt id="ida_typeinf.apply_cdecl"><code class="name flex">
<span>def <span class="ident">apply_cdecl</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Apply the specified type to the address. This function parses the
declaration and calls 'apply_tinfo()'</div>
<div class="epy_par">
<strong class="epy_sig">apply_cdecl(til, ea, decl, flags=0) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">til</strong>: type library (C++: til_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">ea</strong>: linear address (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">decl</strong>: type declaration in C form (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">flags</strong>: flags to pass to apply_tinfo ( TINFO_DEFINITE
is always<div class="epy_nested">
passed) (C++: int)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: success</div>
</div></div>
</dd>
<dt id="ida_typeinf.apply_named_type"><code class="name flex">
<span>def <span class="ident">apply_named_type</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Apply the specified named type to the address.</div>
<div class="epy_par">
<strong class="epy_sig">apply_named_type(ea, name) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong>: linear address (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">name</strong>: the type name, e.g. "FILE" (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: success</div>
</div></div>
</dd>
<dt id="ida_typeinf.apply_once_tinfo_and_name"><code class="name flex">
<span>def <span class="ident">apply_once_tinfo_and_name</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Apply the specified type and name to the address. This function checks
if the address already has a type. If the old typedoes not exist or
the new type is 'better' than the old type, then thenew type will be
applied. A type is considered better if it has moreinformation (e.g.
'BTMT_STRUCT' is better than 'BT_INT' ).The same logic is with the
name: if the address already have a meaningfulname, it will be
preserved. Only if the old name does not exist or itis a dummy name
like byte_123, it will be replaced by the new name.</div>
<div class="epy_par">
<strong class="epy_sig">apply_once_tinfo_and_name(dea, tif, name) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">dea</strong>: linear address (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">tif</strong>: type string in the internal format (C++: const
tinfo_t<div class="epy_nested">
&amp;)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">name</strong>: new name for the address (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: success</div>
</div></div>
</dd>
<dt id="ida_typeinf.apply_tinfo"><code class="name flex">
<span>def <span class="ident">apply_tinfo</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Apply the specified type to the specified address. This function sets
the type and tries to convert the item at the specified address to
conform the type.</div>
<div class="epy_par">
<strong class="epy_sig">apply_tinfo(ea, tif, flags) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong>: linear address (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">tif</strong>: type string in internal format (C++: const
tinfo_t
&amp;)</div>
<div class="epy_nested">
<strong class="epy_parameter">flags</strong>: combination of
Apply tinfo flags (C++: uint32)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: success</div>
</div></div>
</dd>
<dt id="ida_typeinf.apply_tinfo_to_stkarg"><code class="name flex">
<span>def <span class="ident">apply_tinfo_to_stkarg</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Helper function for the processor modules. to be called from</div>
<div class="epy_par">
\ph{use_stkarg_type}</div>
<div class="epy_par">
<strong class="epy_sig">apply_tinfo_to_stkarg(insn, x, v, tif, name) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">insn</strong>
- an ida_ua.insn_t, or an address (C++: const insn_t &amp;)</div>
<div class="epy_nested">
<strong class="epy_parameter">x</strong> (C++: const
op_t
&amp;)</div>
<div class="epy_nested">
<strong class="epy_parameter">v</strong> (C++: uval_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">tif</strong> (C++: const
tinfo_t
&amp;)</div>
<div class="epy_nested">
<strong class="epy_parameter">name</strong> (C++: const char *)</div>
</div></div>
</dd>
<dt id="ida_typeinf.apply_type"><code class="name flex">
<span>def <span class="ident">apply_type</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">apply_type(ti, type, fields, ea, flags) -&gt; bool</strong><div class="epy_nested">
Apply the specified type to the address</div>
<div class="epy_nested">
<strong class="epy_parameter">ti</strong>: Type info library. 'None' can be used.</div>
<div class="epy_nested">
<strong class="epy_parameter">py_type</strong>: type string</div>
<div class="epy_nested">
<strong class="epy_parameter">py_fields</strong>: fields string (may be empty or None)</div>
<div class="epy_nested">
<strong class="epy_parameter">ea</strong>: the address of the object</div>
<div class="epy_nested">
<strong class="epy_parameter">flags</strong>: combination of TINFO_... constants or 0</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: Boolean</div>
</div></div>
</dd>
<dt id="ida_typeinf.begin_type_updating"><code class="name flex">
<span>def <span class="ident">begin_type_updating</span></span>(<span>*args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Mark the beginning of a large update operation on the types. Can be
used with 'add_enum_member()' , add_struc_member, etc... Also see
'end_type_updating()'</div>
<div class="epy_par">
<strong class="epy_sig">begin_type_updating(utp)</strong><div class="epy_nested">
<strong class="epy_parameter">utp</strong> (C++: update_type_t)</div>
</div></div>
</dd>
<dt id="ida_typeinf.calc_c_cpp_name"><code class="name flex">
<span>def <span class="ident">calc_c_cpp_name</span></span>(<span>*args) &#8209;&gt;&#160;qstring&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get C or C++ form of the name.</div>
<div class="epy_par">
<strong class="epy_sig">calc_c_cpp_name(name, type, ccn_flags) -&gt; str</strong><div class="epy_nested">
<strong class="epy_parameter">name</strong>: original (mangled or decorated) name (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">type</strong>: name type if known, otherwise NULL (C++: const
tinfo_t<div class="epy_nested">
*)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">ccn_flags</strong>: one of
C/C++ naming flags (C++: int)</div>
</div></div>
</dd>
<dt id="ida_typeinf.calc_number_of_children"><code class="name flex">
<span>def <span class="ident">calc_number_of_children</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Calculate max number of lines of a formatted c data, when expanded (
'PTV_EXPAND' ).</div>
<div class="epy_par">
<strong class="epy_sig">calc_number_of_children(loc, tif, dont_deref_ptr=False) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">loc</strong>: location of the data ( ALOC_STATIC
or
ALOC_CUSTOM )<div class="epy_nested">
(C++: const
argloc_t
&amp;)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">tif</strong>: type info (C++: const
tinfo_t
&amp;)</div>
<div class="epy_nested">
<strong class="epy_parameter">dont_deref_ptr</strong>: consider 'ea' as the ptr value (C++: bool)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - data is not expandable</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: -1 - error, see qerrno</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: else - the max number of lines</div>
</div></div>
</dd>
<dt id="ida_typeinf.calc_tinfo_gaps"><code class="name flex">
<span>def <span class="ident">calc_tinfo_gaps</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">calc_tinfo_gaps(out, typid) -&gt; bool</strong><div class="epy_nested">
out: rangeset_t *
typid: uint32</div>
</div></div>
</dd>
<dt id="ida_typeinf.calc_type_size"><code class="name flex">
<span>def <span class="ident">calc_type_size</span></span>(<span>*args) &#8209;&gt;&#160;PyObject&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">calc_type_size(ti, tp) -&gt; PyObject *</strong><div class="epy_nested">
Returns the size of a type</div>
<div class="epy_nested">
<strong class="epy_parameter">ti</strong>: Type info. 'None' can be passed.</div>
<div class="epy_nested">
<strong class="epy_parameter">tp</strong>: type string</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>:<ul class="epy_ul">
<li class="epy_li"><span class="epy_nested">
None on failure</span>
</li>
<li class="epy_li"><span class="epy_nested">
The size of the type</span>
</li>
</ul>
</div>
</div></div>
</dd>
<dt id="ida_typeinf.callregs_t_regcount"><code class="name flex">
<span>def <span class="ident">callregs_t_regcount</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">callregs_t_regcount(cc) -&gt; int</strong><div class="epy_nested">
cc: cm_t</div>
</div></div>
</dd>
<dt id="ida_typeinf.choose_local_tinfo"><code class="name flex">
<span>def <span class="ident">choose_local_tinfo</span></span>(<span>*args) &#8209;&gt;&#160;uint32</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Choose a type from the local type library.</div>
<div class="epy_par">
<strong class="epy_sig">choose_local_tinfo(ti, title, func=None, def_ord=0, ud=None) -&gt; uint32</strong><div class="epy_nested">
<strong class="epy_parameter">ti</strong>: pointer to til (C++: const
til_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">title</strong>: title of listbox to display (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">func</strong>: predicate to select types to display (maybe NULL) (C++:<div class="epy_nested">
local_tinfo_predicate_t
*)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">def_ord</strong>: ordinal to position cursor before choose (C++: uint32)</div>
<div class="epy_nested">
<strong class="epy_parameter">ud</strong>: user data (C++: void *)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: == 0 means nothing is chosen, otherwise an ordinal number</div>
</div></div>
</dd>
<dt id="ida_typeinf.choose_local_tinfo_and_delta"><code class="name flex">
<span>def <span class="ident">choose_local_tinfo_and_delta</span></span>(<span>*args) &#8209;&gt;&#160;uint32</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Choose a type from the local type library and specify the pointer
shift value.</div>
<div class="epy_par">
<strong class="epy_sig">choose_local_tinfo_and_delta(delta, ti, title, func=None, def_ord=0, ud=None) -&gt; uint32</strong><div class="epy_nested">
<strong class="epy_parameter">delta</strong>: pointer shift value (C++: int32
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">ti</strong>: pointer to til (C++: const
til_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">title</strong>: title of listbox to display (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">func</strong>: predicate to select types to display (maybe NULL) (C++:<div class="epy_nested">
local_tinfo_predicate_t
*)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">def_ord</strong>: ordinal to position cursor before choose (C++: uint32)</div>
<div class="epy_nested">
<strong class="epy_parameter">ud</strong>: user data (C++: void *)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: == 0 means nothing is chosen, otherwise an ordinal number</div>
</div></div>
</dd>
<dt id="ida_typeinf.choose_named_type"><code class="name flex">
<span>def <span class="ident">choose_named_type</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Choose a type from a type library.</div>
<div class="epy_par">
<strong class="epy_sig">choose_named_type(out_sym, root_til, title, ntf_flags, predicate=None) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">out_sym</strong>: pointer to be filled with the chosen type (C++:<div class="epy_nested">
til_symbol_t
*)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">root_til</strong>: pointer to starting til (the function will inspect<div class="epy_nested">
the base tils if allowed by flags) (C++: const
til_t
*)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">title</strong>: title of listbox to display (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">ntf_flags</strong>: combination of
Flags for named types (C++: int)</div>
<div class="epy_nested">
<strong class="epy_parameter">predicate</strong>: predicate to select types to display (maybe NULL)<div class="epy_nested">
(C++: predicate_t
*)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: false if nothing is chosen, otherwise true</div>
</div></div>
</dd>
<dt id="ida_typeinf.clear_tinfo_t"><code class="name flex">
<span>def <span class="ident">clear_tinfo_t</span></span>(<span>*args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">clear_tinfo_t(_this)</strong><div class="epy_nested">
_this: tinfo_t *</div>
</div></div>
</dd>
<dt id="ida_typeinf.compact_til"><code class="name flex">
<span>def <span class="ident">compact_til</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Collect garbage in til. Must be called before storing the til.</div>
<div class="epy_par">
<strong class="epy_sig">compact_til(ti) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ti</strong> (C++: til_t
*)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: true if any memory was freed</div>
</div></div>
</dd>
<dt id="ida_typeinf.compare_tinfo"><code class="name flex">
<span>def <span class="ident">compare_tinfo</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">compare_tinfo(t1, t2, tcflags) -&gt; bool</strong><div class="epy_nested">
t1: uint32
t2: uint32
tcflags: int</div>
</div></div>
</dd>
<dt id="ida_typeinf.convert_pt_flags_to_hti"><code class="name flex">
<span>def <span class="ident">convert_pt_flags_to_hti</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Convert 'Type parsing flags' to 'Type formatting flags' . Type parsing
flags lesser than 0x10 don't have stable meaning and will be ignored
(more on these flags can be seen in idc.idc)</div>
<div class="epy_par">
<strong class="epy_sig">convert_pt_flags_to_hti(pt_flags) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">pt_flags</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_typeinf.copy_named_type"><code class="name flex">
<span>def <span class="ident">copy_named_type</span></span>(<span>*args) &#8209;&gt;&#160;uint32</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Copy a named type from one til to another. This function will copy the
specified type and all dependent types from the source type library to
the destination library.</div>
<div class="epy_par">
<strong class="epy_sig">copy_named_type(dsttil, srctil, name) -&gt; uint32</strong><div class="epy_nested">
<strong class="epy_parameter">dsttil</strong>: Destination til. It must have orginal types enabled<div class="epy_nested">
(C++: til_t
*)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">srctil</strong>: Source til. (C++: const
til_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">name</strong>: name of the type to copy (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: ordinal number of the copied type. 0 means error</div>
</div></div>
</dd>
<dt id="ida_typeinf.copy_tinfo_t"><code class="name flex">
<span>def <span class="ident">copy_tinfo_t</span></span>(<span>*args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">copy_tinfo_t(_this, r)</strong><div class="epy_nested">
_this: tinfo_t *
r: tinfo_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_typeinf.create_numbered_type_name"><code class="name flex">
<span>def <span class="ident">create_numbered_type_name</span></span>(<span>*args) &#8209;&gt;&#160;qstring&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Create anonymous name for numbered type. This name can be used to
reference a numbered type by its ordinal Ordinal names have the
following format: '#' + set_de(ord) Returns: -1 if error, otherwise
the name length</div>
<div class="epy_par">
<strong class="epy_sig">create_numbered_type_name(ord) -&gt; str</strong><div class="epy_nested">
<strong class="epy_parameter">ord</strong> (C++: int32)</div>
</div></div>
</dd>
<dt id="ida_typeinf.create_tinfo"><code class="name flex">
<span>def <span class="ident">create_tinfo</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">create_tinfo(_this, bt, bt2, ptr) -&gt; bool</strong><div class="epy_nested">
_this: tinfo_t *
bt: type_t
bt2: type_t
ptr: void *</div>
</div></div>
</dd>
<dt id="ida_typeinf.default_compiler"><code class="name flex">
<span>def <span class="ident">default_compiler</span></span>(<span>*args) &#8209;&gt;&#160;comp_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get compiler specified by \varmem{inf,idainfo,cc}
.</div></div>
</dd>
<dt id="ida_typeinf.del_named_type"><code class="name flex">
<span>def <span class="ident">del_named_type</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Delete information about a symbol.</div>
<div class="epy_par">
<strong class="epy_sig">del_named_type(ti, name, ntf_flags) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ti</strong>: type library (C++: til_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">name</strong>: name of symbol (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">ntf_flags</strong>: combination of
Flags for named types (C++: int)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: success</div>
</div></div>
</dd>
<dt id="ida_typeinf.del_numbered_type"><code class="name flex">
<span>def <span class="ident">del_numbered_type</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Delete a numbered type.</div>
<div class="epy_par">
<strong class="epy_sig">del_numbered_type(ti, ordinal) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ti</strong> (C++: til_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">ordinal</strong> (C++: uint32)</div>
</div></div>
</dd>
<dt id="ida_typeinf.del_til"><code class="name flex">
<span>def <span class="ident">del_til</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Unload a til file.</div>
<div class="epy_par">
<strong class="epy_sig">del_til(name) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">name</strong> (C++: const char *)</div>
</div></div>
</dd>
<dt id="ida_typeinf.del_tinfo_attr"><code class="name flex">
<span>def <span class="ident">del_tinfo_attr</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">del_tinfo_attr(tif, key, make_copy) -&gt; bool</strong><div class="epy_nested">
tif: tinfo_t *
key: qstring const &amp;
make_copy: bool</div>
</div></div>
</dd>
<dt id="ida_typeinf.del_vftable_ea"><code class="name flex">
<span>def <span class="ident">del_vftable_ea</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Delete the address of a vftable instance for a vftable type.</div>
<div class="epy_par">
<strong class="epy_sig">del_vftable_ea(ordinal) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ordinal</strong>: ordinal number of a vftable type. (C++: uint32)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: success</div>
</div></div>
</dd>
<dt id="ida_typeinf.deref_ptr"><code class="name flex">
<span>def <span class="ident">deref_ptr</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Dereference a pointer.</div>
<div class="epy_par">
<strong class="epy_sig">deref_ptr(ptr_ea, tif, closure_obj=None) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ptr_ea</strong>: in/out parameter
in: address of the pointer
out:<div class="epy_nested">
the pointed address (C++: ea_t *)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">tif</strong>: type of the pointer (C++: const
tinfo_t
&amp;)</div>
<div class="epy_nested">
<strong class="epy_parameter">closure_obj</strong>: closure object (not used yet) (C++: ea_t *)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: success</div>
</div></div>
</dd>
<dt id="ida_typeinf.deserialize_tinfo"><code class="name flex">
<span>def <span class="ident">deserialize_tinfo</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">deserialize_tinfo(tif, til, ptype, pfields, pfldcmts) -&gt; bool</strong><div class="epy_nested">
tif: tinfo_t *
til: til_t const *
ptype: type_t const **
pfields: p_list const **
pfldcmts: p_list const **</div>
</div></div>
</dd>
<dt id="ida_typeinf.dstr_tinfo"><code class="name flex">
<span>def <span class="ident">dstr_tinfo</span></span>(<span>*args) &#8209;&gt;&#160;char&#160;const&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">dstr_tinfo(tif) -&gt; char const *</strong><div class="epy_nested">
tif: tinfo_t const *</div>
</div></div>
</dd>
<dt id="ida_typeinf.dump_func_type_data"><code class="name flex">
<span>def <span class="ident">dump_func_type_data</span></span>(<span>*args) &#8209;&gt;&#160;qstring&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Use 'func_type_data_t::dump()'</div>
<div class="epy_par">
<strong class="epy_sig">dump_func_type_data(fti, praloc_bits) -&gt; str</strong><div class="epy_nested">
<strong class="epy_parameter">fti</strong> (C++: const
func_type_data_t
&amp;)</div>
<div class="epy_nested">
<strong class="epy_parameter">praloc_bits</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_typeinf.end_type_updating"><code class="name flex">
<span>def <span class="ident">end_type_updating</span></span>(<span>*args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Mark the end of a large update operation on the types (see
'begin_type_updating()' )</div>
<div class="epy_par">
<strong class="epy_sig">end_type_updating(utp)</strong><div class="epy_nested">
<strong class="epy_parameter">utp</strong> (C++: update_type_t)</div>
</div></div>
</dd>
<dt id="ida_typeinf.extract_argloc"><code class="name flex">
<span>def <span class="ident">extract_argloc</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">extract_argloc(vloc, ptype, forbid_stkoff) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">vloc</strong> (C++: argloc_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">ptype</strong> (C++: const
type_t
**)</div>
<div class="epy_nested">
<strong class="epy_parameter">forbid_stkoff</strong> (C++: bool)</div>
</div></div>
</dd>
<dt id="ida_typeinf.find_tinfo_udt_member"><code class="name flex">
<span>def <span class="ident">find_tinfo_udt_member</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">find_tinfo_udt_member(udm, typid, strmem_flags) -&gt; int</strong><div class="epy_nested">
udm: udt_member_t *
typid: uint32
strmem_flags: int</div>
</div></div>
</dd>
<dt id="ida_typeinf.first_named_type"><code class="name flex">
<span>def <span class="ident">first_named_type</span></span>(<span>*args) &#8209;&gt;&#160;char&#160;const&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Enumerate types. Returns mangled names. Never returns anonymous types.
To include it, enumerate types by ordinals.</div>
<div class="epy_par">
<strong class="epy_sig">first_named_type(ti, ntf_flags) -&gt; char const *</strong><div class="epy_nested">
<strong class="epy_parameter">ti</strong> (C++: const
til_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">ntf_flags</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_typeinf.for_all_arglocs"><code class="name flex">
<span>def <span class="ident">for_all_arglocs</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Compress larger argloc types and initiate the aloc visitor.</div>
<div class="epy_par">
<strong class="epy_sig">for_all_arglocs(vv, vloc, size, off=0) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">vv</strong> (C++: aloc_visitor_t
&amp;)</div>
<div class="epy_nested">
<strong class="epy_parameter">vloc</strong> (C++: argloc_t
&amp;)</div>
<div class="epy_nested">
<strong class="epy_parameter">size</strong> (C++: int)</div>
<div class="epy_nested">
<strong class="epy_parameter">off</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_typeinf.for_all_const_arglocs"><code class="name flex">
<span>def <span class="ident">for_all_const_arglocs</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
See 'for_all_arglocs()'</div>
<div class="epy_par">
<strong class="epy_sig">for_all_const_arglocs(vv, vloc, size, off=0) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">vv</strong> (C++: const_aloc_visitor_t
&amp;)</div>
<div class="epy_nested">
<strong class="epy_parameter">vloc</strong> (C++: const
argloc_t
&amp;)</div>
<div class="epy_nested">
<strong class="epy_parameter">size</strong> (C++: int)</div>
<div class="epy_nested">
<strong class="epy_parameter">off</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_typeinf.free_til"><code class="name flex">
<span>def <span class="ident">free_til</span></span>(<span>*args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Free memory allocated by til.</div>
<div class="epy_par">
<strong class="epy_sig">free_til(ti)</strong><div class="epy_nested">
<strong class="epy_parameter">ti</strong> (C++: til_t
*)</div>
</div></div>
</dd>
<dt id="ida_typeinf.func_has_stkframe_hole"><code class="name flex">
<span>def <span class="ident">func_has_stkframe_hole</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Looks for a hole at the beginning of the stack arguments. Will make
use of the IDB's 'func_t' function at that place (if present) to help
determine the presence of such a hole.</div>
<div class="epy_par">
<strong class="epy_sig">func_has_stkframe_hole(ea, fti) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">fti</strong> (C++: const
func_type_data_t
&amp;)</div>
</div></div>
</dd>
<dt id="ida_typeinf.gcc_layout"><code class="name flex">
<span>def <span class="ident">gcc_layout</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Should use the struct/union layout as done by gcc?</div></div>
</dd>
<dt id="ida_typeinf.gen_decorate_name"><code class="name flex">
<span>def <span class="ident">gen_decorate_name</span></span>(<span>*args) &#8209;&gt;&#160;qstring&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Generic function for 'decorate_name()' (may be used in IDP modules)</div>
<div class="epy_par">
<strong class="epy_sig">gen_decorate_name(name, mangle, cc, type) -&gt; str</strong><div class="epy_nested">
<strong class="epy_parameter">name</strong> (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">mangle</strong> (C++: bool)</div>
<div class="epy_nested">
<strong class="epy_parameter">cc</strong> (C++: cm_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">type</strong> (C++: const
tinfo_t
*)</div>
</div></div>
</dd>
<dt id="ida_typeinf.gen_use_arg_tinfos"><code class="name flex">
<span>def <span class="ident">gen_use_arg_tinfos</span></span>(<span>*args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">gen_use_arg_tinfos(caller, fti, rargs, set_optype, is_stkarg_load, has_delay_slot)</strong><div class="epy_nested">
<strong class="epy_parameter">caller</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">fti</strong> (C++: func_type_data_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">rargs</strong> (C++: funcargvec_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">set_optype</strong> (C++: set_op_tinfo_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">is_stkarg_load</strong> (C++: is_stkarg_load_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">has_delay_slot</strong> (C++: has_delay_slot_t *)</div>
</div></div>
</dd>
<dt id="ida_typeinf.gen_use_arg_tinfos2"><code class="name flex">
<span>def <span class="ident">gen_use_arg_tinfos2</span></span>(<span>*args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Do not call this function directly, use 'argtinfo_helper_t' .</div>
<div class="epy_par">
<strong class="epy_sig">gen_use_arg_tinfos2(_this, caller, fti, rargs)</strong><div class="epy_nested">
<strong class="epy_parameter">_this</strong> (C++: struct
argtinfo_helper_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">caller</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">fti</strong> (C++: func_type_data_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">rargs</strong> (C++: funcargvec_t
*)</div>
</div></div>
</dd>
<dt id="ida_typeinf.get_abi_name"><code class="name flex">
<span>def <span class="ident">get_abi_name</span></span>(<span>*args) &#8209;&gt;&#160;qstring&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get ABI name.</div></div>
</dd>
<dt id="ida_typeinf.get_alias_target"><code class="name flex">
<span>def <span class="ident">get_alias_target</span></span>(<span>*args) &#8209;&gt;&#160;uint32</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Find the final alias destination. If the ordinal has not been aliased,
return the specified ordinal itself If failed, returns 0.</div>
<div class="epy_par">
<strong class="epy_sig">get_alias_target(ti, ordinal) -&gt; uint32</strong><div class="epy_nested">
<strong class="epy_parameter">ti</strong> (C++: const
til_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">ordinal</strong> (C++: uint32)</div>
</div></div>
</dd>
<dt id="ida_typeinf.get_arg_addrs"><code class="name flex">
<span>def <span class="ident">get_arg_addrs</span></span>(<span>*args) &#8209;&gt;&#160;PyObject&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">get_arg_addrs(caller) -&gt; PyObject *</strong><div class="epy_nested">
Retrieve addresses of argument initialization instructions</div>
<div class="epy_nested">
<strong class="epy_parameter">caller</strong>: the address of the call instruction</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: list of instruction addresses</div>
</div></div>
</dd>
<dt id="ida_typeinf.get_base_type"><code class="name flex">
<span>def <span class="ident">get_base_type</span></span>(<span>*args) &#8209;&gt;&#160;type_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get get basic type bits ( 'TYPE_BASE_MASK' )</div>
<div class="epy_par">
<strong class="epy_sig">get_base_type(t) -&gt; type_t</strong><div class="epy_nested">
<strong class="epy_parameter">t</strong> (C++: type_t)</div>
</div></div>
</dd>
<dt id="ida_typeinf.get_c_header_path"><code class="name flex">
<span>def <span class="ident">get_c_header_path</span></span>(<span>*args) &#8209;&gt;&#160;qstring&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get the include directory path of the target compiler.</div></div>
</dd>
<dt id="ida_typeinf.get_c_macros"><code class="name flex">
<span>def <span class="ident">get_c_macros</span></span>(<span>*args) &#8209;&gt;&#160;qstring&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get predefined macros for the target compiler.</div></div>
</dd>
<dt id="ida_typeinf.get_comp"><code class="name flex">
<span>def <span class="ident">get_comp</span></span>(<span>*args) &#8209;&gt;&#160;comp_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get compiler bits.</div>
<div class="epy_par">
<strong class="epy_sig">get_comp(comp) -&gt; comp_t</strong><div class="epy_nested">
<strong class="epy_parameter">comp</strong> (C++: comp_t)</div>
</div></div>
</dd>
<dt id="ida_typeinf.get_compiler_abbr"><code class="name flex">
<span>def <span class="ident">get_compiler_abbr</span></span>(<span>*args) &#8209;&gt;&#160;char&#160;const&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get abbreviated compiler name.</div>
<div class="epy_par">
<strong class="epy_sig">get_compiler_abbr(id) -&gt; char const *</strong><div class="epy_nested">
<strong class="epy_parameter">id</strong> (C++: comp_t)</div>
</div></div>
</dd>
<dt id="ida_typeinf.get_compiler_name"><code class="name flex">
<span>def <span class="ident">get_compiler_name</span></span>(<span>*args) &#8209;&gt;&#160;char&#160;const&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get full compiler name.</div>
<div class="epy_par">
<strong class="epy_sig">get_compiler_name(id) -&gt; char const *</strong><div class="epy_nested">
<strong class="epy_parameter">id</strong> (C++: comp_t)</div>
</div></div>
</dd>
<dt id="ida_typeinf.get_compilers"><code class="name flex">
<span>def <span class="ident">get_compilers</span></span>(<span>*args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get names of all built-in compilers.</div>
<div class="epy_par">
<strong class="epy_sig">get_compilers(ids, names, abbrs)</strong><div class="epy_nested">
<strong class="epy_parameter">ids</strong> (C++: compvec_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">names</strong> (C++: qstrvec_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">abbrs</strong> (C++: qstrvec_t
*)</div>
</div></div>
</dd>
<dt id="ida_typeinf.get_enum_member_expr"><code class="name flex">
<span>def <span class="ident">get_enum_member_expr</span></span>(<span>*args) &#8209;&gt;&#160;qstring&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Return a C expression that can be used to represent an enum member. If
the value does not correspond to any single enum member, this function
tries to find a bitwise combination of enum members that correspond to
it. If more than half of value bits do not match any enum members, it
fails.</div>
<div class="epy_par">
<strong class="epy_sig">get_enum_member_expr(tif, serial, value) -&gt; str</strong><div class="epy_nested">
<strong class="epy_parameter">tif</strong>: enumeration type (C++: const
tinfo_t
&amp;)</div>
<div class="epy_nested">
<strong class="epy_parameter">serial</strong>: which enumeration member to use (0 means the first with<div class="epy_nested">
the given value) (C++: int)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">value</strong>: value to search in the enumeration type. only 32-bit<div class="epy_nested">
number can be handled yet (C++: uint64)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: success</div>
</div></div>
</dd>
<dt id="ida_typeinf.get_full_type"><code class="name flex">
<span>def <span class="ident">get_full_type</span></span>(<span>*args) &#8209;&gt;&#160;type_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get basic type bits + type flags ( 'TYPE_FULL_MASK' )</div>
<div class="epy_par">
<strong class="epy_sig">get_full_type(t) -&gt; type_t</strong><div class="epy_nested">
<strong class="epy_parameter">t</strong> (C++: type_t)</div>
</div></div>
</dd>
<dt id="ida_typeinf.get_idainfo_by_type"><code class="name flex">
<span>def <span class="ident">get_idainfo_by_type</span></span>(<span>*args) &#8209;&gt;&#160;size_t&#160;*,&#160;flags_t&#160;*,&#160;opinfo_t&#160;*,&#160;size_t&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Extract information from a 'tinfo_t' .</div>
<div class="epy_par">
<strong class="epy_sig">get_idainfo_by_type(tif) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">tif</strong>: the type to inspect (C++: const
tinfo_t
&amp;)</div>
</div></div>
</dd>
<dt id="ida_typeinf.get_idati"><code class="name flex">
<span>def <span class="ident">get_idati</span></span>(<span>*args) &#8209;&gt;&#160;<a title="ida_typeinf.til_t" href="#ida_typeinf.til_t">til_t</a>&#160;const&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Pointer to the local type library - this til is private for each IDB
file Function that accepts til_t* uses local type library instead of
NULL.</div></div>
</dd>
<dt id="ida_typeinf.get_named_type"><code class="name flex">
<span>def <span class="ident">get_named_type</span></span>(<span>*args) &#8209;&gt;&#160;PyObject&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">get_named_type(til, name, ntf_flags) -&gt; PyObject *</strong><div class="epy_nested">
Get a type data by its name.</div>
<div class="epy_nested">
<strong class="epy_parameter">til</strong>: the type library</div>
<div class="epy_nested">
<strong class="epy_parameter">name</strong>: the type name</div>
<div class="epy_nested">
<strong class="epy_parameter">ntf_flags</strong>: a combination of NTF_* constants</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>:<div class="epy_nested">
None on failure
tuple(code, type_str, fields_str, cmt, field_cmts, sclass, value) on success</div>
</div>
</div></div>
</dd>
<dt id="ida_typeinf.get_named_type64"><code class="name flex">
<span>def <span class="ident">get_named_type64</span></span>(<span>*args) &#8209;&gt;&#160;PyObject&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
See 'get_named_type()' above.If the value in the 'ti' library is
32-bit, it will be sign-extended before being stored in the 'value'
pointer.</div>
<div class="epy_par">
<strong class="epy_sig">get_named_type64(til, name, ntf_flags) -&gt; PyObject *</strong><div class="epy_nested">
til: til_t const *</div>
<div class="epy_nested">
<strong class="epy_parameter">name</strong> (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">ntf_flags</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_typeinf.get_numbered_type"><code class="name flex">
<span>def <span class="ident">get_numbered_type</span></span>(<span>*args) &#8209;&gt;&#160;PyObject&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Retrieve a type by its ordinal number.</div>
<div class="epy_par">
<strong class="epy_sig">get_numbered_type(til, ordinal) -&gt; PyObject *</strong><div class="epy_nested">
til: til_t const *</div>
<div class="epy_nested">
<strong class="epy_parameter">ordinal</strong> (C++: uint32)</div>
</div></div>
</dd>
<dt id="ida_typeinf.get_numbered_type_name"><code class="name flex">
<span>def <span class="ident">get_numbered_type_name</span></span>(<span>*args) &#8209;&gt;&#160;char&#160;const&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get type name (if exists) by its ordinal. If the type is anonymous,
returns "". If failed, returns NULL</div>
<div class="epy_par">
<strong class="epy_sig">get_numbered_type_name(ti, ordinal) -&gt; char const *</strong><div class="epy_nested">
<strong class="epy_parameter">ti</strong> (C++: const
til_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">ordinal</strong> (C++: uint32)</div>
</div></div>
</dd>
<dt id="ida_typeinf.get_ordinal_from_idb_type"><code class="name flex">
<span>def <span class="ident">get_ordinal_from_idb_type</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get ordinal number of an idb type (struct/enum). The 'type' parameter
is used only to determine the kind of the type (struct or enum) Use
this function to find out the correspondence between idb types and til
types</div>
<div class="epy_par">
<strong class="epy_sig">get_ordinal_from_idb_type(name, type) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">name</strong> (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">type</strong> (C++: const
type_t
*)</div>
</div></div>
</dd>
<dt id="ida_typeinf.get_ordinal_qty"><code class="name flex">
<span>def <span class="ident">get_ordinal_qty</span></span>(<span>*args) &#8209;&gt;&#160;uint32</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get number of allocated ordinals.</div>
<div class="epy_par">
<strong class="epy_sig">get_ordinal_qty(ti) -&gt; uint32</strong><div class="epy_nested">
<strong class="epy_parameter">ti</strong> (C++: const
til_t
*)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: uint32(-1) if failed</div>
</div></div>
</dd>
<dt id="ida_typeinf.get_scalar_bt"><code class="name flex">
<span>def <span class="ident">get_scalar_bt</span></span>(<span>*args) &#8209;&gt;&#160;type_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">get_scalar_bt(size) -&gt; type_t</strong><div class="epy_nested">
<strong class="epy_parameter">size</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_typeinf.get_stock_tinfo"><code class="name flex">
<span>def <span class="ident">get_stock_tinfo</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">get_stock_tinfo(tif, id) -&gt; bool</strong><div class="epy_nested">
tif: tinfo_t *
id: enum stock_type_id_t</div>
</div></div>
</dd>
<dt id="ida_typeinf.get_tinfo_attr"><code class="name flex">
<span>def <span class="ident">get_tinfo_attr</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">get_tinfo_attr(typid, key, bv, all_attrs) -&gt; bool</strong><div class="epy_nested">
typid: uint32
key: qstring const &amp;
bv: bytevec_t *
all_attrs: bool</div>
</div></div>
</dd>
<dt id="ida_typeinf.get_tinfo_attrs"><code class="name flex">
<span>def <span class="ident">get_tinfo_attrs</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">get_tinfo_attrs(typid, tav, include_ref_attrs) -&gt; bool</strong><div class="epy_nested">
typid: uint32
tav: type_attrs_t *
include_ref_attrs: bool</div>
</div></div>
</dd>
<dt id="ida_typeinf.get_tinfo_details"><code class="name flex">
<span>def <span class="ident">get_tinfo_details</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">get_tinfo_details(typid, bt2, buf) -&gt; bool</strong><div class="epy_nested">
typid: uint32
bt2: type_t
buf: void *</div>
</div></div>
</dd>
<dt id="ida_typeinf.get_tinfo_pdata"><code class="name flex">
<span>def <span class="ident">get_tinfo_pdata</span></span>(<span>*args) &#8209;&gt;&#160;size_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">get_tinfo_pdata(outptr, typid, what) -&gt; size_t</strong><div class="epy_nested">
outptr: void *
typid: uint32
what: int</div>
</div></div>
</dd>
<dt id="ida_typeinf.get_tinfo_property"><code class="name flex">
<span>def <span class="ident">get_tinfo_property</span></span>(<span>*args) &#8209;&gt;&#160;size_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">get_tinfo_property(typid, gta_prop) -&gt; size_t</strong><div class="epy_nested">
typid: uint32
gta_prop: int</div>
</div></div>
</dd>
<dt id="ida_typeinf.get_tinfo_size"><code class="name flex">
<span>def <span class="ident">get_tinfo_size</span></span>(<span>*args) &#8209;&gt;&#160;size_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">get_tinfo_size(p_effalign, typid, gts_code) -&gt; size_t</strong><div class="epy_nested">
p_effalign: uint32 *
typid: uint32
gts_code: int</div>
</div></div>
</dd>
<dt id="ida_typeinf.get_type_flags"><code class="name flex">
<span>def <span class="ident">get_type_flags</span></span>(<span>*args) &#8209;&gt;&#160;type_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get type flags ( 'TYPE_FLAGS_MASK' )</div>
<div class="epy_par">
<strong class="epy_sig">get_type_flags(t) -&gt; type_t</strong><div class="epy_nested">
<strong class="epy_parameter">t</strong> (C++: type_t)</div>
</div></div>
</dd>
<dt id="ida_typeinf.get_type_ordinal"><code class="name flex">
<span>def <span class="ident">get_type_ordinal</span></span>(<span>*args) &#8209;&gt;&#160;int32</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get type ordinal by its name.</div>
<div class="epy_par">
<strong class="epy_sig">get_type_ordinal(ti, name) -&gt; int32</strong><div class="epy_nested">
<strong class="epy_parameter">ti</strong> (C++: const
til_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">name</strong> (C++: const char *)</div>
</div></div>
</dd>
<dt id="ida_typeinf.get_vftable_ea"><code class="name flex">
<span>def <span class="ident">get_vftable_ea</span></span>(<span>*args) &#8209;&gt;&#160;ea_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get address of a virtual function table.</div>
<div class="epy_par">
<strong class="epy_sig">get_vftable_ea(ordinal) -&gt; ea_t</strong><div class="epy_nested">
<strong class="epy_parameter">ordinal</strong>: ordinal number of a vftable type. (C++: uint32)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: address of the corresponding virtual function table in the<div class="epy_nested">
current database.</div>
</div>
</div></div>
</dd>
<dt id="ida_typeinf.get_vftable_ordinal"><code class="name flex">
<span>def <span class="ident">get_vftable_ordinal</span></span>(<span>*args) &#8209;&gt;&#160;uint32</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get ordinal number of the virtual function table.</div>
<div class="epy_par">
<strong class="epy_sig">get_vftable_ordinal(vftable_ea) -&gt; uint32</strong><div class="epy_nested">
<strong class="epy_parameter">vftable_ea</strong>: address of a virtual function table. (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: ordinal number of the corresponding vftable type. 0 -<div class="epy_nested">
failure.</div>
</div>
</div></div>
</dd>
<dt id="ida_typeinf.guess_func_cc"><code class="name flex">
<span>def <span class="ident">guess_func_cc</span></span>(<span>*args) &#8209;&gt;&#160;cm_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Use 'func_type_data_t::guess_cc()'</div>
<div class="epy_par">
<strong class="epy_sig">guess_func_cc(fti, npurged, cc_flags) -&gt; cm_t</strong><div class="epy_nested">
<strong class="epy_parameter">fti</strong> (C++: const
func_type_data_t
&amp;)</div>
<div class="epy_nested">
<strong class="epy_parameter">npurged</strong> (C++: int)</div>
<div class="epy_nested">
<strong class="epy_parameter">cc_flags</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_typeinf.guess_tinfo"><code class="name flex">
<span>def <span class="ident">guess_tinfo</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Generate a type information about the id from the disassembly. id can
be a structure/union/enum id or an address.</div>
<div class="epy_par">
<strong class="epy_sig">guess_tinfo(tif, id) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">tif</strong> (C++: tinfo_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">id</strong> (C++: tid_t)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: one of
Guess tinfo codes</div>
</div></div>
</dd>
<dt id="ida_typeinf.idc_get_local_type"><code class="name flex">
<span>def <span class="ident">idc_get_local_type</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">idc_get_local_type(ordinal, flags, buf, maxsize) -&gt; int</strong><div class="epy_nested">
ordinal: int
flags: int
buf: char *
maxsize: size_t</div>
</div></div>
</dd>
<dt id="ida_typeinf.idc_get_local_type_name"><code class="name flex">
<span>def <span class="ident">idc_get_local_type_name</span></span>(<span>*args) &#8209;&gt;&#160;size_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">idc_get_local_type_name(ordinal) -&gt; str</strong><div class="epy_nested">
ordinal: int</div>
</div></div>
</dd>
<dt id="ida_typeinf.idc_get_local_type_raw"><code class="name flex">
<span>def <span class="ident">idc_get_local_type_raw</span></span>(<span>*args) &#8209;&gt;&#160;PyObject&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">idc_get_local_type_raw(ordinal) -&gt; PyObject *</strong><div class="epy_nested">
ordinal: int</div>
</div></div>
</dd>
<dt id="ida_typeinf.idc_get_type"><code class="name flex">
<span>def <span class="ident">idc_get_type</span></span>(<span>*args) &#8209;&gt;&#160;size_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">idc_get_type(ea) -&gt; str</strong><div class="epy_nested">
ea: ea_t</div>
</div></div>
</dd>
<dt id="ida_typeinf.idc_get_type_raw"><code class="name flex">
<span>def <span class="ident">idc_get_type_raw</span></span>(<span>*args) &#8209;&gt;&#160;PyObject&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">idc_get_type_raw(ea) -&gt; PyObject *</strong><div class="epy_nested">
ea: ea_t</div>
</div></div>
</dd>
<dt id="ida_typeinf.idc_guess_type"><code class="name flex">
<span>def <span class="ident">idc_guess_type</span></span>(<span>*args) &#8209;&gt;&#160;size_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">idc_guess_type(ea) -&gt; str</strong><div class="epy_nested">
ea: ea_t</div>
</div></div>
</dd>
<dt id="ida_typeinf.idc_parse_decl"><code class="name flex">
<span>def <span class="ident">idc_parse_decl</span></span>(<span>*args) &#8209;&gt;&#160;PyObject&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">idc_parse_decl(ti, decl, flags) -&gt; PyObject *</strong><div class="epy_nested">
ti: til_t *
decl: char const *
flags: int</div>
</div></div>
</dd>
<dt id="ida_typeinf.idc_parse_types"><code class="name flex">
<span>def <span class="ident">idc_parse_types</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">idc_parse_types(input, flags) -&gt; int</strong><div class="epy_nested">
input: char const *
flags: int</div>
</div></div>
</dd>
<dt id="ida_typeinf.idc_print_type"><code class="name flex">
<span>def <span class="ident">idc_print_type</span></span>(<span>*args) &#8209;&gt;&#160;PyObject&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">idc_print_type(type, fields, name, flags) -&gt; PyObject *</strong><div class="epy_nested">
type: type_t const *
fields: p_list const *
name: char const *
flags: int</div>
</div></div>
</dd>
<dt id="ida_typeinf.idc_set_local_type"><code class="name flex">
<span>def <span class="ident">idc_set_local_type</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">idc_set_local_type(ordinal, dcl, flags) -&gt; int</strong><div class="epy_nested">
ordinal: int
dcl: char const *
flags: int</div>
</div></div>
</dd>
<dt id="ida_typeinf.import_type"><code class="name flex">
<span>def <span class="ident">import_type</span></span>(<span>*args) &#8209;&gt;&#160;tid_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Copy a named type from til to idb.</div>
<div class="epy_par">
<strong class="epy_sig">import_type(til, idx, name, flags=0) -&gt; tid_t</strong><div class="epy_nested">
<strong class="epy_parameter">til</strong>: type library (C++: const
til_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">idx</strong>: the position of the new type in the list of types<div class="epy_nested">
(structures or enums). -1 means at the end of the list
(C++: int)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">name</strong>: the type name (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">flags</strong>: combination of
Import type flags (C++: int)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: BADNODE
on error</div>
</div></div>
</dd>
<dt id="ida_typeinf.is_autosync"><code class="name flex">
<span>def <span class="ident">is_autosync</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is the specified idb type automatically synchronized?</div>
<div class="epy_par">
<strong class="epy_sig">is_autosync(name, type) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">name</strong> (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">type</strong> (C++: const
type_t
*)</div>
</div>
<div class="epy_par">
<strong class="epy_sig">is_autosync(name, tif) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">name</strong> (C++: const char *)
tif: tinfo_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_typeinf.is_code_far"><code class="name flex">
<span>def <span class="ident">is_code_far</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Does the given model specify far code?.</div>
<div class="epy_par">
<strong class="epy_sig">is_code_far(cm) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">cm</strong> (C++: cm_t)</div>
</div></div>
</dd>
<dt id="ida_typeinf.is_comp_unsure"><code class="name flex">
<span>def <span class="ident">is_comp_unsure</span></span>(<span>*args) &#8209;&gt;&#160;comp_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
See 'COMP_UNSURE' .</div>
<div class="epy_par">
<strong class="epy_sig">is_comp_unsure(comp) -&gt; comp_t</strong><div class="epy_nested">
<strong class="epy_parameter">comp</strong> (C++: comp_t)</div>
</div></div>
</dd>
<dt id="ida_typeinf.is_data_far"><code class="name flex">
<span>def <span class="ident">is_data_far</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Does the given model specify far data?.</div>
<div class="epy_par">
<strong class="epy_sig">is_data_far(cm) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">cm</strong> (C++: cm_t)</div>
</div></div>
</dd>
<dt id="ida_typeinf.is_gcc"><code class="name flex">
<span>def <span class="ident">is_gcc</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is the target compiler 'COMP_GNU' ?</div></div>
</dd>
<dt id="ida_typeinf.is_gcc32"><code class="name flex">
<span>def <span class="ident">is_gcc32</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is the target compiler 32 bit gcc?</div></div>
</dd>
<dt id="ida_typeinf.is_gcc64"><code class="name flex">
<span>def <span class="ident">is_gcc64</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is the target compiler 64 bit gcc?</div></div>
</dd>
<dt id="ida_typeinf.is_golang_cc"><code class="name flex">
<span>def <span class="ident">is_golang_cc</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
GO language calling convention (return value in stack)?</div>
<div class="epy_par">
<strong class="epy_sig">is_golang_cc(cc) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">cc</strong> (C++: cm_t)</div>
</div></div>
</dd>
<dt id="ida_typeinf.is_ordinal_name"><code class="name flex">
<span>def <span class="ident">is_ordinal_name</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Check if the name is an ordinal name. Ordinal names have the following
format: '#' + set_de(ord)</div>
<div class="epy_par">
<strong class="epy_sig">is_ordinal_name(name, ord=None) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">name</strong> (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">ord</strong> (C++: uint32
*)</div>
</div></div>
</dd>
<dt id="ida_typeinf.is_purging_cc"><code class="name flex">
<span>def <span class="ident">is_purging_cc</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Does the calling convention clean the stack arguments upon
return?.this function is valid only for x86 code</div>
<div class="epy_par">
<strong class="epy_sig">is_purging_cc(cm) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">cm</strong> (C++: cm_t)</div>
</div></div>
</dd>
<dt id="ida_typeinf.is_restype_enum"><code class="name flex">
<span>def <span class="ident">is_restype_enum</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">is_restype_enum(til, type) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">til</strong> (C++: const
til_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">type</strong> (C++: const
type_t
*)</div>
</div></div>
</dd>
<dt id="ida_typeinf.is_restype_struct"><code class="name flex">
<span>def <span class="ident">is_restype_struct</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">is_restype_struct(til, type) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">til</strong> (C++: const
til_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">type</strong> (C++: const
type_t
*)</div>
</div></div>
</dd>
<dt id="ida_typeinf.is_restype_struni"><code class="name flex">
<span>def <span class="ident">is_restype_struni</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">is_restype_struni(til, type) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">til</strong> (C++: const
til_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">type</strong> (C++: const
type_t
*)</div>
</div></div>
</dd>
<dt id="ida_typeinf.is_restype_void"><code class="name flex">
<span>def <span class="ident">is_restype_void</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">is_restype_void(til, type) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">til</strong> (C++: const
til_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">type</strong> (C++: const
type_t
*)</div>
</div></div>
</dd>
<dt id="ida_typeinf.is_sdacl_byte"><code class="name flex">
<span>def <span class="ident">is_sdacl_byte</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Identify an sdacl byte. The first sdacl byte has the following format:
11xx000x. The sdacl bytes are appended to udt fields. They indicate
the start of type attributes (as the tah-bytes do). The sdacl bytes
are used in the udt headers instead of the tah-byte. This is done for
compatibility with old databases, they were already using sdacl bytes
in udt headers and as udt field postfixes. (see "sdacl-typeattrs" in
the type bit definitions)</div>
<div class="epy_par">
<strong class="epy_sig">is_sdacl_byte(t) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">t</strong> (C++: type_t)</div>
</div></div>
</dd>
<dt id="ida_typeinf.is_tah_byte"><code class="name flex">
<span>def <span class="ident">is_tah_byte</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
The TAH byte (type attribute header byte) denotes the start of type
attributes. (see "tah-typeattrs" in the type bit definitions)</div>
<div class="epy_par">
<strong class="epy_sig">is_tah_byte(t) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">t</strong> (C++: type_t)</div>
</div></div>
</dd>
<dt id="ida_typeinf.is_type_arithmetic"><code class="name flex">
<span>def <span class="ident">is_type_arithmetic</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is the type an arithmetic type? (floating or integral)</div>
<div class="epy_par">
<strong class="epy_sig">is_type_arithmetic(t) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">t</strong> (C++: type_t)</div>
</div></div>
</dd>
<dt id="ida_typeinf.is_type_array"><code class="name flex">
<span>def <span class="ident">is_type_array</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
See 'BT_ARRAY' .</div>
<div class="epy_par">
<strong class="epy_sig">is_type_array(t) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">t</strong> (C++: type_t)</div>
</div></div>
</dd>
<dt id="ida_typeinf.is_type_bitfld"><code class="name flex">
<span>def <span class="ident">is_type_bitfld</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
See 'BT_BITFIELD' .</div>
<div class="epy_par">
<strong class="epy_sig">is_type_bitfld(t) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">t</strong> (C++: type_t)</div>
</div></div>
</dd>
<dt id="ida_typeinf.is_type_bool"><code class="name flex">
<span>def <span class="ident">is_type_bool</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
See 'BTF_BOOL' .</div>
<div class="epy_par">
<strong class="epy_sig">is_type_bool(t) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">t</strong> (C++: type_t)</div>
</div></div>
</dd>
<dt id="ida_typeinf.is_type_char"><code class="name flex">
<span>def <span class="ident">is_type_char</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Does the type specify a char value? (signed or unsigned, see 'Basic
type: integer' )</div>
<div class="epy_par">
<strong class="epy_sig">is_type_char(t) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">t</strong> (C++: type_t)</div>
</div></div>
</dd>
<dt id="ida_typeinf.is_type_complex"><code class="name flex">
<span>def <span class="ident">is_type_complex</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
See 'BT_COMPLEX' .</div>
<div class="epy_par">
<strong class="epy_sig">is_type_complex(t) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">t</strong> (C++: type_t)</div>
</div></div>
</dd>
<dt id="ida_typeinf.is_type_const"><code class="name flex">
<span>def <span class="ident">is_type_const</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
See 'BTM_CONST' .</div>
<div class="epy_par">
<strong class="epy_sig">is_type_const(t) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">t</strong> (C++: type_t)</div>
</div></div>
</dd>
<dt id="ida_typeinf.is_type_double"><code class="name flex">
<span>def <span class="ident">is_type_double</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
See 'BTF_DOUBLE' .</div>
<div class="epy_par">
<strong class="epy_sig">is_type_double(t) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">t</strong> (C++: type_t)</div>
</div></div>
</dd>
<dt id="ida_typeinf.is_type_enum"><code class="name flex">
<span>def <span class="ident">is_type_enum</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
See 'BTF_ENUM' .</div>
<div class="epy_par">
<strong class="epy_sig">is_type_enum(t) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">t</strong> (C++: type_t)</div>
</div></div>
</dd>
<dt id="ida_typeinf.is_type_ext_arithmetic"><code class="name flex">
<span>def <span class="ident">is_type_ext_arithmetic</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is the type an extended arithmetic type? (arithmetic or enum)</div>
<div class="epy_par">
<strong class="epy_sig">is_type_ext_arithmetic(t) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">t</strong> (C++: type_t)</div>
</div></div>
</dd>
<dt id="ida_typeinf.is_type_ext_integral"><code class="name flex">
<span>def <span class="ident">is_type_ext_integral</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is the type an extended integral type? (integral or enum)</div>
<div class="epy_par">
<strong class="epy_sig">is_type_ext_integral(t) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">t</strong> (C++: type_t)</div>
</div></div>
</dd>
<dt id="ida_typeinf.is_type_float"><code class="name flex">
<span>def <span class="ident">is_type_float</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
See 'BTF_FLOAT' .</div>
<div class="epy_par">
<strong class="epy_sig">is_type_float(t) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">t</strong> (C++: type_t)</div>
</div></div>
</dd>
<dt id="ida_typeinf.is_type_floating"><code class="name flex">
<span>def <span class="ident">is_type_floating</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is the type a floating point type?</div>
<div class="epy_par">
<strong class="epy_sig">is_type_floating(t) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">t</strong> (C++: type_t)</div>
</div></div>
</dd>
<dt id="ida_typeinf.is_type_func"><code class="name flex">
<span>def <span class="ident">is_type_func</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
See 'BT_FUNC' .</div>
<div class="epy_par">
<strong class="epy_sig">is_type_func(t) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">t</strong> (C++: type_t)</div>
</div></div>
</dd>
<dt id="ida_typeinf.is_type_int"><code class="name flex">
<span>def <span class="ident">is_type_int</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Does the type_t specify one of the basic types in 'Basic type:
integer' ?</div>
<div class="epy_par">
<strong class="epy_sig">is_type_int(bt) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">bt</strong> (C++: type_t)</div>
</div></div>
</dd>
<dt id="ida_typeinf.is_type_int128"><code class="name flex">
<span>def <span class="ident">is_type_int128</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Does the type specify a 128-bit value? (signed or unsigned, see 'Basic
type: integer' )</div>
<div class="epy_par">
<strong class="epy_sig">is_type_int128(t) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">t</strong> (C++: type_t)</div>
</div></div>
</dd>
<dt id="ida_typeinf.is_type_int16"><code class="name flex">
<span>def <span class="ident">is_type_int16</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Does the type specify a 16-bit value? (signed or unsigned, see 'Basic
type: integer' )</div>
<div class="epy_par">
<strong class="epy_sig">is_type_int16(t) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">t</strong> (C++: type_t)</div>
</div></div>
</dd>
<dt id="ida_typeinf.is_type_int32"><code class="name flex">
<span>def <span class="ident">is_type_int32</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Does the type specify a 32-bit value? (signed or unsigned, see 'Basic
type: integer' )</div>
<div class="epy_par">
<strong class="epy_sig">is_type_int32(t) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">t</strong> (C++: type_t)</div>
</div></div>
</dd>
<dt id="ida_typeinf.is_type_int64"><code class="name flex">
<span>def <span class="ident">is_type_int64</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Does the type specify a 64-bit value? (signed or unsigned, see 'Basic
type: integer' )</div>
<div class="epy_par">
<strong class="epy_sig">is_type_int64(t) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">t</strong> (C++: type_t)</div>
</div></div>
</dd>
<dt id="ida_typeinf.is_type_integral"><code class="name flex">
<span>def <span class="ident">is_type_integral</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is the type an integral type (char/short/int/long/bool)?</div>
<div class="epy_par">
<strong class="epy_sig">is_type_integral(t) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">t</strong> (C++: type_t)</div>
</div></div>
</dd>
<dt id="ida_typeinf.is_type_ldouble"><code class="name flex">
<span>def <span class="ident">is_type_ldouble</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
See 'BTF_LDOUBLE' .</div>
<div class="epy_par">
<strong class="epy_sig">is_type_ldouble(t) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">t</strong> (C++: type_t)</div>
</div></div>
</dd>
<dt id="ida_typeinf.is_type_paf"><code class="name flex">
<span>def <span class="ident">is_type_paf</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is the type a pointer, array, or function type?</div>
<div class="epy_par">
<strong class="epy_sig">is_type_paf(t) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">t</strong> (C++: type_t)</div>
</div></div>
</dd>
<dt id="ida_typeinf.is_type_partial"><code class="name flex">
<span>def <span class="ident">is_type_partial</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Identifies an unknown or void type with a known size (see 'Basic type:
unknown &amp; void' )</div>
<div class="epy_par">
<strong class="epy_sig">is_type_partial(t) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">t</strong> (C++: type_t)</div>
</div></div>
</dd>
<dt id="ida_typeinf.is_type_ptr"><code class="name flex">
<span>def <span class="ident">is_type_ptr</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
See 'BT_PTR' .</div>
<div class="epy_par">
<strong class="epy_sig">is_type_ptr(t) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">t</strong> (C++: type_t)</div>
</div></div>
</dd>
<dt id="ida_typeinf.is_type_ptr_or_array"><code class="name flex">
<span>def <span class="ident">is_type_ptr_or_array</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is the type a pointer or array type?</div>
<div class="epy_par">
<strong class="epy_sig">is_type_ptr_or_array(t) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">t</strong> (C++: type_t)</div>
</div></div>
</dd>
<dt id="ida_typeinf.is_type_struct"><code class="name flex">
<span>def <span class="ident">is_type_struct</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
See 'BTF_STRUCT' .</div>
<div class="epy_par">
<strong class="epy_sig">is_type_struct(t) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">t</strong> (C++: type_t)</div>
</div></div>
</dd>
<dt id="ida_typeinf.is_type_struni"><code class="name flex">
<span>def <span class="ident">is_type_struni</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is the type a struct or union?</div>
<div class="epy_par">
<strong class="epy_sig">is_type_struni(t) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">t</strong> (C++: type_t)</div>
</div></div>
</dd>
<dt id="ida_typeinf.is_type_sue"><code class="name flex">
<span>def <span class="ident">is_type_sue</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is the type a struct/union/enum?</div>
<div class="epy_par">
<strong class="epy_sig">is_type_sue(t) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">t</strong> (C++: type_t)</div>
</div></div>
</dd>
<dt id="ida_typeinf.is_type_tbyte"><code class="name flex">
<span>def <span class="ident">is_type_tbyte</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
See 'BTF_FLOAT' .</div>
<div class="epy_par">
<strong class="epy_sig">is_type_tbyte(t) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">t</strong> (C++: type_t)</div>
</div></div>
</dd>
<dt id="ida_typeinf.is_type_typedef"><code class="name flex">
<span>def <span class="ident">is_type_typedef</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
See 'BTF_TYPEDEF' .</div>
<div class="epy_par">
<strong class="epy_sig">is_type_typedef(t) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">t</strong> (C++: type_t)</div>
</div></div>
</dd>
<dt id="ida_typeinf.is_type_uchar"><code class="name flex">
<span>def <span class="ident">is_type_uchar</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
See 'BTF_UCHAR' .</div>
<div class="epy_par">
<strong class="epy_sig">is_type_uchar(t) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">t</strong> (C++: type_t)</div>
</div></div>
</dd>
<dt id="ida_typeinf.is_type_uint"><code class="name flex">
<span>def <span class="ident">is_type_uint</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
See 'BTF_UINT' .</div>
<div class="epy_par">
<strong class="epy_sig">is_type_uint(t) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">t</strong> (C++: type_t)</div>
</div></div>
</dd>
<dt id="ida_typeinf.is_type_uint128"><code class="name flex">
<span>def <span class="ident">is_type_uint128</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
See 'BTF_UINT128' .</div>
<div class="epy_par">
<strong class="epy_sig">is_type_uint128(t) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">t</strong> (C++: type_t)</div>
</div></div>
</dd>
<dt id="ida_typeinf.is_type_uint16"><code class="name flex">
<span>def <span class="ident">is_type_uint16</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
See 'BTF_UINT16' .</div>
<div class="epy_par">
<strong class="epy_sig">is_type_uint16(t) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">t</strong> (C++: type_t)</div>
</div></div>
</dd>
<dt id="ida_typeinf.is_type_uint32"><code class="name flex">
<span>def <span class="ident">is_type_uint32</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
See 'BTF_UINT32' .</div>
<div class="epy_par">
<strong class="epy_sig">is_type_uint32(t) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">t</strong> (C++: type_t)</div>
</div></div>
</dd>
<dt id="ida_typeinf.is_type_uint64"><code class="name flex">
<span>def <span class="ident">is_type_uint64</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
See 'BTF_UINT64' .</div>
<div class="epy_par">
<strong class="epy_sig">is_type_uint64(t) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">t</strong> (C++: type_t)</div>
</div></div>
</dd>
<dt id="ida_typeinf.is_type_union"><code class="name flex">
<span>def <span class="ident">is_type_union</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
See 'BTF_UNION' .</div>
<div class="epy_par">
<strong class="epy_sig">is_type_union(t) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">t</strong> (C++: type_t)</div>
</div></div>
</dd>
<dt id="ida_typeinf.is_type_unknown"><code class="name flex">
<span>def <span class="ident">is_type_unknown</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
See 'BT_UNKNOWN' .</div>
<div class="epy_par">
<strong class="epy_sig">is_type_unknown(t) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">t</strong> (C++: type_t)</div>
</div></div>
</dd>
<dt id="ida_typeinf.is_type_void"><code class="name flex">
<span>def <span class="ident">is_type_void</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
See 'BTF_VOID' .</div>
<div class="epy_par">
<strong class="epy_sig">is_type_void(t) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">t</strong> (C++: type_t)</div>
</div></div>
</dd>
<dt id="ida_typeinf.is_type_volatile"><code class="name flex">
<span>def <span class="ident">is_type_volatile</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
See 'BTM_VOLATILE' .</div>
<div class="epy_par">
<strong class="epy_sig">is_type_volatile(t) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">t</strong> (C++: type_t)</div>
</div></div>
</dd>
<dt id="ida_typeinf.is_typeid_last"><code class="name flex">
<span>def <span class="ident">is_typeid_last</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is the type_t the last byte of type declaration? (there are no
additional bytes after a basic type, see '_BT_LAST_BASIC' )</div>
<div class="epy_par">
<strong class="epy_sig">is_typeid_last(t) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">t</strong> (C++: type_t)</div>
</div></div>
</dd>
<dt id="ida_typeinf.is_user_cc"><code class="name flex">
<span>def <span class="ident">is_user_cc</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Does the calling convention specify argument locations explicitly?</div>
<div class="epy_par">
<strong class="epy_sig">is_user_cc(cm) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">cm</strong> (C++: cm_t)</div>
</div></div>
</dd>
<dt id="ida_typeinf.is_vararg_cc"><code class="name flex">
<span>def <span class="ident">is_vararg_cc</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Does the calling convention use ellipsis?</div>
<div class="epy_par">
<strong class="epy_sig">is_vararg_cc(cm) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">cm</strong> (C++: cm_t)</div>
</div></div>
</dd>
<dt id="ida_typeinf.lexcompare_tinfo"><code class="name flex">
<span>def <span class="ident">lexcompare_tinfo</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">lexcompare_tinfo(t1, t2, arg3) -&gt; int</strong><div class="epy_nested">
t1: uint32
t2: uint32
arg3: int</div>
</div></div>
</dd>
<dt id="ida_typeinf.load_til"><code class="name flex">
<span>def <span class="ident">load_til</span></span>(<span>*args) &#8209;&gt;&#160;qstring&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Load til from a file. Failure to load base tils are reported into
'errbuf'. They do not prevent loading of the main til.</div>
<div class="epy_par">
<strong class="epy_sig">load_til(name, tildir=None) -&gt; til_t</strong><div class="epy_nested">
<strong class="epy_parameter">name</strong>: filename of the til. If it's an absolute path, tildir is<div class="epy_nested">
ignored.
NB: the file extension is forced to .til (C++:
const char *)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">tildir</strong>: directory where to load the til from. NULL means<div class="epy_nested">
default til subdirectories. (C++: const char *)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: pointer to resulting til, NULL if failed and error message is<div class="epy_nested">
in errbuf</div>
</div>
</div></div>
</dd>
<dt id="ida_typeinf.load_til_header"><code class="name flex">
<span>def <span class="ident">load_til_header</span></span>(<span>*args) &#8209;&gt;&#160;qstring&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get human-readable til description.</div>
<div class="epy_par">
<strong class="epy_sig">load_til_header(tildir, name) -&gt; til_t</strong><div class="epy_nested">
<strong class="epy_parameter">tildir</strong> (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">name</strong> (C++: const char *)</div>
</div></div>
</dd>
<dt id="ida_typeinf.lower_type"><code class="name flex">
<span>def <span class="ident">lower_type</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Lower type. Inspect the type and lower all function subtypes using
lower_func_type().We call the prototypes usually encountered in source
files "high level"They may have implicit arguments, array arguments,
big structure retvals, etcWe introduce explicit arguments (i.e. 'this'
pointer) and call the result"low level prototype". See 'FTI_HIGH' .In
order to improve heuristics for recognition of big structure
retvals,it is recommended to pass a helper that will be used to make
decisions.That helper will be used only for lowering 'tif', and not
for the childrentypes walked through by recursion.</div>
<div class="epy_par">
<strong class="epy_sig">lower_type(til, tif, name=None, _helper=None) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">til</strong> (C++: til_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">tif</strong> (C++: tinfo_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">name</strong> (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">_helper</strong> (C++: lowertype_helper_t
*)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 - removed
FTI_HIGH ,</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 2 - made substantial changes</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: -1 - failure</div>
</div></div>
</dd>
<dt id="ida_typeinf.new_til"><code class="name flex">
<span>def <span class="ident">new_til</span></span>(<span>*args) &#8209;&gt;&#160;<a title="ida_typeinf.til_t" href="#ida_typeinf.til_t">til_t</a>&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Initialize a til.</div>
<div class="epy_par">
<strong class="epy_sig">new_til(name, desc) -&gt; til_t</strong><div class="epy_nested">
<strong class="epy_parameter">name</strong> (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">desc</strong> (C++: const char *)</div>
</div></div>
</dd>
<dt id="ida_typeinf.next_named_type"><code class="name flex">
<span>def <span class="ident">next_named_type</span></span>(<span>*args) &#8209;&gt;&#160;char&#160;const&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Enumerate types. Returns mangled names. Never returns anonymous types.
To include it, enumerate types by ordinals.</div>
<div class="epy_par">
<strong class="epy_sig">next_named_type(ti, name, ntf_flags) -&gt; char const *</strong><div class="epy_nested">
<strong class="epy_parameter">ti</strong> (C++: const
til_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">name</strong> (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">ntf_flags</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_typeinf.optimize_argloc"><code class="name flex">
<span>def <span class="ident">optimize_argloc</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Verify and optimize scattered argloc into simple form. All new arglocs
must be processed by this function.</div>
<div class="epy_par">
<strong class="epy_sig">optimize_argloc(vloc, size, gaps) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">vloc</strong> (C++: argloc_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">size</strong> (C++: int)</div>
<div class="epy_nested">
<strong class="epy_parameter">gaps</strong> (C++: const
rangeset_t
*)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: true - success</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: false - the input argloc was illegal</div>
</div></div>
</dd>
<dt id="ida_typeinf.pack_idcobj_to_bv"><code class="name flex">
<span>def <span class="ident">pack_idcobj_to_bv</span></span>(<span>*args) &#8209;&gt;&#160;error_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Write a typed idc object to the byte vector. Byte vector may be non-
empty, this function will append data to it</div>
<div class="epy_par">
<strong class="epy_sig">pack_idcobj_to_bv(obj, tif, bytes, objoff, pio_flags=0) -&gt; error_t</strong><div class="epy_nested">
<strong class="epy_parameter">obj</strong> (C++: const
idc_value_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">tif</strong> (C++: const
tinfo_t
&amp;)</div>
<div class="epy_nested">
<strong class="epy_parameter">bytes</strong> (C++: relobj_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">objoff</strong> (C++: void *)</div>
<div class="epy_nested">
<strong class="epy_parameter">pio_flags</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_typeinf.pack_idcobj_to_idb"><code class="name flex">
<span>def <span class="ident">pack_idcobj_to_idb</span></span>(<span>*args) &#8209;&gt;&#160;error_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Write a typed idc object to the database.</div>
<div class="epy_par">
<strong class="epy_sig">pack_idcobj_to_idb(obj, tif, ea, pio_flags=0) -&gt; error_t</strong><div class="epy_nested">
<strong class="epy_parameter">obj</strong> (C++: const
idc_value_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">tif</strong> (C++: const
tinfo_t
&amp;)</div>
<div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">pio_flags</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_typeinf.pack_object_to_bv"><code class="name flex">
<span>def <span class="ident">pack_object_to_bv</span></span>(<span>*args) &#8209;&gt;&#160;PyObject&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">pack_object_to_bv(py_obj, ti, type, fields, base_ea, pio_flags=0) -&gt; PyObject *</strong><div class="epy_nested">
Packs a typed object to a string</div>
<div class="epy_nested">
<strong class="epy_parameter">ti</strong>: Type info. 'None' can be passed.</div>
<div class="epy_nested">
<strong class="epy_parameter">tp</strong>: type string</div>
<div class="epy_nested">
<strong class="epy_parameter">fields</strong>: fields string (may be empty or None)</div>
<div class="epy_nested">
<strong class="epy_parameter">base_ea</strong>: base ea used to relocate the pointers in the packed object</div>
<div class="epy_nested">
<strong class="epy_parameter">pio_flags</strong>: flags used while unpacking</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>:<div class="epy_nested">
tuple(0, err_code) on failure
tuple(1, packed_buf) on success</div>
</div>
</div></div>
</dd>
<dt id="ida_typeinf.pack_object_to_idb"><code class="name flex">
<span>def <span class="ident">pack_object_to_idb</span></span>(<span>*args) &#8209;&gt;&#160;PyObject&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">pack_object_to_idb(py_obj, ti, type, fields, ea, pio_flags=0) -&gt; PyObject *</strong><div class="epy_nested">
Write a typed object to the database.
Raises an exception if wrong parameters were passed or conversion fails
Returns the error_t returned by idaapi.pack_object_to_idb</div>
<div class="epy_nested">
<strong class="epy_parameter">ti</strong>: Type info. 'None' can be passed.</div>
<div class="epy_nested">
<strong class="epy_parameter">tp</strong>: type string</div>
<div class="epy_nested">
<strong class="epy_parameter">fields</strong>: fields string (may be empty or None)</div>
<div class="epy_nested">
<strong class="epy_parameter">ea</strong>: ea to be used while packing</div>
<div class="epy_nested">
<strong class="epy_parameter">pio_flags</strong>: flags used while unpacking</div>
</div></div>
</dd>
<dt id="ida_typeinf.parse_decl"><code class="name flex">
<span>def <span class="ident">parse_decl</span></span>(<span>*args) &#8209;&gt;&#160;qstring&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Parse ONE declaration. If the input string contains more than one
declaration, the first complete type declaration ( 'PT_TYP' ) or the
last variable declaration ( 'PT_VAR' ) will be used.name &amp; tif may be
empty after the call!</div>
<div class="epy_par">
<strong class="epy_sig">parse_decl(tif, til, decl, flags) -&gt; str</strong><div class="epy_nested">
<strong class="epy_parameter">tif</strong>: type info (C++: tinfo_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">til</strong>: type library to use. may be NULL (C++: til_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">decl</strong>: C declaration to parse (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">flags</strong>: combination of
Type parsing flags
bits (C++: int)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: true - ok</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: false - declaration is bad, the error message is displayed if<div class="epy_nested">
!PT_SIL</div>
</div>
</div></div>
</dd>
<dt id="ida_typeinf.parse_decls"><code class="name flex">
<span>def <span class="ident">parse_decls</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Parse many declarations and store them in a til. If there are any
errors, they will be printed using 'printer'. This function uses
default include path and predefined macros from the database settings.
It always uses the 'HTI_DCL' bit.</div>
<div class="epy_par">
<strong class="epy_sig">parse_decls(til, input, printer, hti_flags) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">til</strong>: type library to store the result (C++: til_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">input</strong>: input string or file name (see hti_flags) (C++: const<div class="epy_nested">
char *)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">printer</strong>: function to output error messages (use msg or NULL or<div class="epy_nested">
your own callback) (C++: printer_t
*)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">hti_flags</strong>: combination of
Type formatting flags (C++: int)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: number of errors, 0 means ok.</div>
</div></div>
</dd>
<dt id="ida_typeinf.print_argloc"><code class="name flex">
<span>def <span class="ident">print_argloc</span></span>(<span>*args) &#8209;&gt;&#160;size_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Convert an argloc to human readable form.</div>
<div class="epy_par">
<strong class="epy_sig">print_argloc(vloc, size=0, vflags=0) -&gt; str</strong><div class="epy_nested">
<strong class="epy_parameter">vloc</strong> (C++: const
argloc_t
&amp;)</div>
<div class="epy_nested">
<strong class="epy_parameter">size</strong> (C++: int)</div>
<div class="epy_nested">
<strong class="epy_parameter">vflags</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_typeinf.print_decls"><code class="name flex">
<span>def <span class="ident">print_decls</span></span>(<span>*args) &#8209;&gt;&#160;PyObject&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Print types (and possibly their dependencies) in a format suitable for
use in a header file. This is the reverse 'parse_decls()' .</div>
<div class="epy_par">
<strong class="epy_sig">print_decls(printer, til, py_ordinals, flags) -&gt; PyObject *</strong><div class="epy_nested">
<strong class="epy_parameter">printer</strong>: a handler for printing text (C++: text_sink_t
&amp;)</div>
<div class="epy_nested">
<strong class="epy_parameter">til</strong>: the type library holding the ordinals (C++: til_t
*)
py_ordinals: PyObject *</div>
<div class="epy_nested">
<strong class="epy_parameter">flags</strong>: flags for the algorithm. A combination of PDF_*<div class="epy_nested">
constants (C++: uint32)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: &gt;0 - the number of types exported</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - an error occurred</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: &lt;0 - the negated number of types exported. There were minor<div class="epy_nested">
errors and the resulting output might not be compilable.</div>
</div>
</div></div>
</dd>
<dt id="ida_typeinf.print_tinfo"><code class="name flex">
<span>def <span class="ident">print_tinfo</span></span>(<span>*args) &#8209;&gt;&#160;qstring&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">print_tinfo(prefix, indent, cmtindent, flags, tif, name, cmt) -&gt; str</strong><div class="epy_nested">
prefix: char const *
indent: int
cmtindent: int
flags: int
tif: tinfo_t const *
name: char const *
cmt: char const *</div>
</div></div>
</dd>
<dt id="ida_typeinf.print_type"><code class="name flex">
<span>def <span class="ident">print_type</span></span>(<span>*args) &#8209;&gt;&#160;qstring&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get type declaration for the specified address.</div>
<div class="epy_par">
<strong class="epy_sig">print_type(ea, prtype_flags) -&gt; str</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong>: address (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">prtype_flags</strong>: combination of
Type printing flags (C++: int)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: success</div>
</div></div>
</dd>
<dt id="ida_typeinf.read_tinfo_bitfield_value"><code class="name flex">
<span>def <span class="ident">read_tinfo_bitfield_value</span></span>(<span>*args) &#8209;&gt;&#160;uint64</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">read_tinfo_bitfield_value(typid, v, bitoff) -&gt; uint64</strong><div class="epy_nested">
typid: uint32
v: uint64
bitoff: int</div>
</div></div>
</dd>
<dt id="ida_typeinf.remove_abi_opts"><code class="name flex">
<span>def <span class="ident">remove_abi_opts</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">remove_abi_opts(abi_opts, user_level=False) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">abi_opts</strong> (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">user_level</strong> (C++: bool)</div>
</div></div>
</dd>
<dt id="ida_typeinf.remove_pointer"><code class="name flex">
<span>def <span class="ident">remove_pointer</span></span>(<span>*args) &#8209;&gt;&#160;<a title="ida_typeinf.tinfo_t" href="#ida_typeinf.tinfo_t">tinfo_t</a></span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
'BT_PTR' : If the current type is a pointer, return the pointed
object. If the current type is not a pointer, return the current type.
See also get_ptrarr_object() and get_pointed_object()</div>
<div class="epy_par">
<strong class="epy_sig">remove_pointer(tif) -&gt; tinfo_t</strong><div class="epy_nested">
<strong class="epy_parameter">tif</strong> (C++: const
tinfo_t
&amp;)</div>
</div></div>
</dd>
<dt id="ida_typeinf.remove_tinfo_pointer"><code class="name flex">
<span>def <span class="ident">remove_tinfo_pointer</span></span>(<span>*args) &#8209;&gt;&#160;PyObject&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Remove pointer of a type. (i.e. convert "char *" into "char").
Optionally remove the "lp" (or similar) prefix of the input name. If
the input type is not a pointer, then fail.</div>
<div class="epy_par">
<strong class="epy_sig">remove_tinfo_pointer(tif, name, til) -&gt; PyObject *</strong><div class="epy_nested">
<strong class="epy_parameter">tif</strong> (C++: tinfo_t
*)
name: char const *</div>
<div class="epy_nested">
<strong class="epy_parameter">til</strong> (C++: const
til_t
*)</div>
</div></div>
</dd>
<dt id="ida_typeinf.replace_ordinal_typerefs"><code class="name flex">
<span>def <span class="ident">replace_ordinal_typerefs</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Replace references to ordinal types by name references. This function
'unties' the type from the current local type library and makes it
easier to export it.</div>
<div class="epy_par">
<strong class="epy_sig">replace_ordinal_typerefs(til, tif) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">til</strong>: type library to use. may be NULL. (C++: til_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">tif</strong>: type to modify (in/out) (C++: tinfo_t
*)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: number - of replaced subtypes, -1 on failure</div>
</div></div>
</dd>
<dt id="ida_typeinf.resolve_typedef"><code class="name flex">
<span>def <span class="ident">resolve_typedef</span></span>(<span>*args) &#8209;&gt;&#160;type_t&#160;const&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">resolve_typedef(til, type) -&gt; type_t const *</strong><div class="epy_nested">
<strong class="epy_parameter">til</strong> (C++: const
til_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">type</strong> (C++: const
type_t
*)</div>
</div></div>
</dd>
<dt id="ida_typeinf.save_tinfo"><code class="name flex">
<span>def <span class="ident">save_tinfo</span></span>(<span>*args) &#8209;&gt;&#160;tinfo_code_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">save_tinfo(tif, til, ord, name, ntf_flags) -&gt; tinfo_code_t</strong><div class="epy_nested">
tif: tinfo_t *
til: til_t *
ord: size_t
name: char const *
ntf_flags: int</div>
</div></div>
</dd>
<dt id="ida_typeinf.score_tinfo"><code class="name flex">
<span>def <span class="ident">score_tinfo</span></span>(<span>*args) &#8209;&gt;&#160;uint32</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">score_tinfo(tif) -&gt; uint32</strong><div class="epy_nested">
tif: tinfo_t const *</div>
</div></div>
</dd>
<dt id="ida_typeinf.serialize_tinfo"><code class="name flex">
<span>def <span class="ident">serialize_tinfo</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">serialize_tinfo(type, fields, fldcmts, tif, sudt_flags) -&gt; bool</strong><div class="epy_nested">
type: qtype *
fields: qtype *
fldcmts: qtype *
tif: tinfo_t const *
sudt_flags: int</div>
</div></div>
</dd>
<dt id="ida_typeinf.set_abi_name"><code class="name flex">
<span>def <span class="ident">set_abi_name</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Set abi name (see 'Compiler IDs' )</div>
<div class="epy_par">
<strong class="epy_sig">set_abi_name(abiname, user_level=False) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">abiname</strong> (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">user_level</strong> (C++: bool)</div>
</div></div>
</dd>
<dt id="ida_typeinf.set_c_header_path"><code class="name flex">
<span>def <span class="ident">set_c_header_path</span></span>(<span>*args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Set include directory path the target compiler.</div>
<div class="epy_par">
<strong class="epy_sig">set_c_header_path(incdir)</strong><div class="epy_nested">
<strong class="epy_parameter">incdir</strong> (C++: const char *)</div>
</div></div>
</dd>
<dt id="ida_typeinf.set_c_macros"><code class="name flex">
<span>def <span class="ident">set_c_macros</span></span>(<span>*args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Set predefined macros for the target compiler.</div>
<div class="epy_par">
<strong class="epy_sig">set_c_macros(macros)</strong><div class="epy_nested">
<strong class="epy_parameter">macros</strong> (C++: const char *)</div>
</div></div>
</dd>
<dt id="ida_typeinf.set_compiler"><code class="name flex">
<span>def <span class="ident">set_compiler</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Change current compiler.</div>
<div class="epy_par">
<strong class="epy_sig">set_compiler(cc, flags, abiname=None) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">cc</strong>: compiler to switch to (C++: const
compiler_info_t
&amp;)</div>
<div class="epy_nested">
<strong class="epy_parameter">flags</strong>: Set compiler flags (C++: int)</div>
<div class="epy_nested">
<strong class="epy_parameter">abiname</strong>: ABI name (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: success</div>
</div></div>
</dd>
<dt id="ida_typeinf.set_compiler_id"><code class="name flex">
<span>def <span class="ident">set_compiler_id</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Set the compiler id (see 'Compiler IDs' )</div>
<div class="epy_par">
<strong class="epy_sig">set_compiler_id(id, abiname=None) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">id</strong> (C++: comp_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">abiname</strong> (C++: const char *)</div>
</div></div>
</dd>
<dt id="ida_typeinf.set_compiler_string"><code class="name flex">
<span>def <span class="ident">set_compiler_string</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">set_compiler_string(compstr, user_level) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">compstr</strong>: - compiler description in form <abbr>:<abiname> (C++:<div class="epy_nested">
const char *)</div>
</abiname></abbr></div>
<div class="epy_nested">
<strong class="epy_parameter">user_level</strong>: - initiated by user if TRUE (C++: bool)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: success</div>
</div></div>
</dd>
<dt id="ida_typeinf.set_numbered_type"><code class="name flex">
<span>def <span class="ident">set_numbered_type</span></span>(<span>*args) &#8209;&gt;&#160;tinfo_code_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Store a type in the til. 'name' may be NULL for anonymous types. The
specified ordinal must be free (no other type is using it). For
ntf_flags, only 'NTF_REPLACE' is consulted.</div>
<div class="epy_par">
<strong class="epy_sig">set_numbered_type(ti, ordinal, ntf_flags, name, type, fields=None, cmt=None, fldcmts=None, sclass=None) -&gt; tinfo_code_t</strong><div class="epy_nested">
<strong class="epy_parameter">ti</strong> (C++: til_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">ordinal</strong> (C++: uint32)</div>
<div class="epy_nested">
<strong class="epy_parameter">ntf_flags</strong> (C++: int)</div>
<div class="epy_nested">
<strong class="epy_parameter">name</strong> (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">type</strong> (C++: const
type_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">fields</strong> (C++: const
p_list
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">cmt</strong> (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">fldcmts</strong> (C++: const
p_list
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">sclass</strong> (C++: const
sclass_t
*)</div>
</div></div>
</dd>
<dt id="ida_typeinf.set_tinfo_attr"><code class="name flex">
<span>def <span class="ident">set_tinfo_attr</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">set_tinfo_attr(tif, ta, may_overwrite) -&gt; bool</strong><div class="epy_nested">
tif: tinfo_t *
ta: type_attr_t const &amp;
may_overwrite: bool</div>
</div></div>
</dd>
<dt id="ida_typeinf.set_tinfo_attrs"><code class="name flex">
<span>def <span class="ident">set_tinfo_attrs</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">set_tinfo_attrs(tif, ta) -&gt; bool</strong><div class="epy_nested">
tif: tinfo_t *
ta: type_attrs_t *</div>
</div></div>
</dd>
<dt id="ida_typeinf.set_tinfo_property"><code class="name flex">
<span>def <span class="ident">set_tinfo_property</span></span>(<span>*args) &#8209;&gt;&#160;size_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">set_tinfo_property(tif, sta_prop, x) -&gt; size_t</strong><div class="epy_nested">
tif: tinfo_t *
sta_prop: int
x: size_t</div>
</div></div>
</dd>
<dt id="ida_typeinf.set_type_alias"><code class="name flex">
<span>def <span class="ident">set_type_alias</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Create a type alias. Redirects all references to source type to the
destination type. This is equivalent to instantaneous replacement all
reference to srctype by dsttype.</div>
<div class="epy_par">
<strong class="epy_sig">set_type_alias(ti, src_ordinal, dst_ordinal) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ti</strong> (C++: til_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">src_ordinal</strong> (C++: uint32)</div>
<div class="epy_nested">
<strong class="epy_parameter">dst_ordinal</strong> (C++: uint32)</div>
</div></div>
</dd>
<dt id="ida_typeinf.set_vftable_ea"><code class="name flex">
<span>def <span class="ident">set_vftable_ea</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Set the address of a vftable instance for a vftable type.</div>
<div class="epy_par">
<strong class="epy_sig">set_vftable_ea(ordinal, vftable_ea) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ordinal</strong>: ordinal number of the corresponding vftable type.<div class="epy_nested">
(C++: uint32)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">vftable_ea</strong>: address of a virtual function table. (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: success</div>
</div></div>
</dd>
<dt id="ida_typeinf.store_til"><code class="name flex">
<span>def <span class="ident">store_til</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Store til to a file. If the til contains garbage, it will be collected
before storing the til. Your plugin should call 'compact_til()' before
calling 'store_til()' .</div>
<div class="epy_par">
<strong class="epy_sig">store_til(ti, tildir, name) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ti</strong>: type library to store (C++: til_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">tildir</strong>: directory where to store the til. NULL means current<div class="epy_nested">
directory. (C++: const char *)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">name</strong>: filename of the til. If it's an absolute path, tildir is<div class="epy_nested">
ignored.
NB: the file extension is forced to .til (C++:
const char *)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: success</div>
</div></div>
</dd>
<dt id="ida_typeinf.switch_to_golang"><code class="name flex">
<span>def <span class="ident">switch_to_golang</span></span>(<span>*args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
switch to GOLANG calling convention (to be used as default CC)</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t_get_stock"><code class="name flex">
<span>def <span class="ident">tinfo_t_get_stock</span></span>(<span>*args) &#8209;&gt;&#160;<a title="ida_typeinf.tinfo_t" href="#ida_typeinf.tinfo_t">tinfo_t</a></span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">tinfo_t_get_stock(id) -&gt; tinfo_t</strong><div class="epy_nested">
id: enum stock_type_id_t</div>
</div></div>
</dd>
<dt id="ida_typeinf.unpack_idcobj_from_bv"><code class="name flex">
<span>def <span class="ident">unpack_idcobj_from_bv</span></span>(<span>*args) &#8209;&gt;&#160;error_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Read a typed idc object from the byte vector.</div>
<div class="epy_par">
<strong class="epy_sig">unpack_idcobj_from_bv(obj, tif, bytes, pio_flags=0) -&gt; error_t</strong><div class="epy_nested">
<strong class="epy_parameter">obj</strong> (C++: idc_value_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">tif</strong> (C++: const
tinfo_t
&amp;)</div>
<div class="epy_nested">
<strong class="epy_parameter">bytes</strong> (C++: const
bytevec_t
&amp;)</div>
<div class="epy_nested">
<strong class="epy_parameter">pio_flags</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_typeinf.unpack_idcobj_from_idb"><code class="name flex">
<span>def <span class="ident">unpack_idcobj_from_idb</span></span>(<span>*args) &#8209;&gt;&#160;error_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Collection of register objects.</div>
<div class="epy_par">
Read a typed idc object from the database</div>
<div class="epy_par">
<strong class="epy_sig">unpack_idcobj_from_idb(obj, tif, ea, off0, pio_flags=0) -&gt; error_t</strong><div class="epy_nested">
<strong class="epy_parameter">obj</strong> (C++: idc_value_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">tif</strong> (C++: const
tinfo_t
&amp;)</div>
<div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">off0</strong> (C++: const
bytevec_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">pio_flags</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_typeinf.unpack_object_from_bv"><code class="name flex">
<span>def <span class="ident">unpack_object_from_bv</span></span>(<span>*args) &#8209;&gt;&#160;PyObject&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">unpack_object_from_bv(ti, type, fields, bytes, pio_flags=0) -&gt; PyObject *</strong><div class="epy_nested">
Unpacks a buffer into an object.
Returns the error_t returned by idaapi.pack_object_to_idb</div>
<div class="epy_nested">
<strong class="epy_parameter">ti</strong>: Type info. 'None' can be passed.</div>
<div class="epy_nested">
<strong class="epy_parameter">tp</strong>: type string</div>
<div class="epy_nested">
<strong class="epy_parameter">fields</strong>: fields string (may be empty or None)</div>
<div class="epy_nested">
<strong class="epy_parameter">bytes</strong>: the bytes to unpack</div>
<div class="epy_nested">
<strong class="epy_parameter">pio_flags</strong>: flags used while unpacking</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>:<ul class="epy_ul">
<li class="epy_li"><span class="epy_nested">
tuple(0, err) on failure</span>
</li>
<li class="epy_li"><span class="epy_nested">
tuple(1, obj) on success</span>
</li>
</ul>
</div>
</div></div>
</dd>
<dt id="ida_typeinf.unpack_object_from_idb"><code class="name flex">
<span>def <span class="ident">unpack_object_from_idb</span></span>(<span>*args) &#8209;&gt;&#160;PyObject&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">unpack_object_from_idb(ti, type, fields, ea, pio_flags=0) -&gt; PyObject *</strong><div class="epy_nested">
ti: til_t *
type: type_t const *
fields: p_list const *
ea: ea_t
pio_flags: int</div>
</div></div>
</dd>
<dt id="ida_typeinf.use_golang_cc"><code class="name flex">
<span>def <span class="ident">use_golang_cc</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
is GOLANG calling convention used by default?</div></div>
</dd>
<dt id="ida_typeinf.verify_argloc"><code class="name flex">
<span>def <span class="ident">verify_argloc</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Verify 'argloc_t' .</div>
<div class="epy_par">
<strong class="epy_sig">verify_argloc(vloc, size, gaps) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">vloc</strong> (C++: const
argloc_t
&amp;)</div>
<div class="epy_nested">
<strong class="epy_parameter">size</strong>: total size of the variable (C++: int)</div>
<div class="epy_nested">
<strong class="epy_parameter">gaps</strong>: if not NULL, specifies gaps in structure definition.<div class="epy_nested">
these gaps should not map to any argloc, but everything
else must be covered (C++: const
rangeset_t
*)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: 0 if ok, otherwise an interr code.</div>
</div></div>
</dd>
<dt id="ida_typeinf.verify_tinfo"><code class="name flex">
<span>def <span class="ident">verify_tinfo</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">verify_tinfo(typid) -&gt; int</strong><div class="epy_nested">
typid: uint32</div>
</div></div>
</dd>
<dt id="ida_typeinf.visit_subtypes"><code class="name flex">
<span>def <span class="ident">visit_subtypes</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">visit_subtypes(visitor, out, tif, name, cmt) -&gt; int</strong><div class="epy_nested">
visitor: tinfo_visitor_t *
out: type_mods_t *
tif: tinfo_t const &amp;
name: char const *
cmt: char const *</div>
</div></div>
</dd>
<dt id="ida_typeinf.write_tinfo_bitfield_value"><code class="name flex">
<span>def <span class="ident">write_tinfo_bitfield_value</span></span>(<span>*args) &#8209;&gt;&#160;uint64</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">write_tinfo_bitfield_value(typid, dst, v, bitoff) -&gt; uint64</strong><div class="epy_nested">
typid: uint32
dst: uint64
v: uint64
bitoff: int</div>
</div></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ida_typeinf.aloc_visitor_t"><code class="flex name class">
<span>class <span class="ident">aloc_visitor_t</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ aloc_visitor_t class.</div>
<div class="epy_par">
<strong class="epy_sig">__init__(self) -&gt; aloc_visitor_t</strong><div class="epy_nested">
self: PyObject *</div>
</div></div>
<h3>Methods</h3>
<dl>
<dt id="ida_typeinf.aloc_visitor_t.visit_location"><code class="name flex">
<span>def <span class="ident">visit_location</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">visit_location(self, v, off, size) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">v</strong> (C++: argloc_t
&amp;)</div>
<div class="epy_nested">
<strong class="epy_parameter">off</strong> (C++: int)</div>
<div class="epy_nested">
<strong class="epy_parameter">size</strong> (C++: int)</div>
</div></div>
</dd>
</dl>
</dd>
<dt id="ida_typeinf.argloc_t"><code class="flex name class">
<span>class <span class="ident">argloc_t</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ argloc_t class.</div>
<div class="epy_par">
<strong class="epy_sig">__init__(self) -&gt; argloc_t</strong><div class="epy_nested">
r: argloc_t const &amp;</div>
</div></div>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="ida_hexrays.vdloc_t" href="ida_hexrays.html#ida_hexrays.vdloc_t">vdloc_t</a></li>
<li><a title="ida_typeinf.argpart_t" href="#ida_typeinf.argpart_t">argpart_t</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="ida_typeinf.argloc_t.advance"><code class="name flex">
<span>def <span class="ident">advance</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Move the location to point 'delta' bytes further.</div>
<div class="epy_par">
<strong class="epy_sig">advance(self, delta) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">delta</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_typeinf.argloc_t.atype"><code class="name flex">
<span>def <span class="ident">atype</span></span>(<span>self, *args) &#8209;&gt;&#160;argloc_type_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get type ( 'Argument location types' )</div></div>
</dd>
<dt id="ida_typeinf.argloc_t.calc_offset"><code class="name flex">
<span>def <span class="ident">calc_offset</span></span>(<span>self, *args) &#8209;&gt;&#160;sval_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Calculate offset that can be used to compare 2 similar arglocs.</div></div>
</dd>
<dt id="ida_typeinf.argloc_t.compare"><code class="name flex">
<span>def <span class="ident">compare</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">compare(self, r) -&gt; int</strong><div class="epy_nested">
r: argloc_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_typeinf.argloc_t.consume_rrel"><code class="name flex">
<span>def <span class="ident">consume_rrel</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Set register-relative location - can't be NULL.</div>
<div class="epy_par">
<strong class="epy_sig">consume_rrel(self, p)</strong><div class="epy_nested">
<strong class="epy_parameter">p</strong> (C++: rrel_t
*)</div>
</div></div>
</dd>
<dt id="ida_typeinf.argloc_t.consume_scattered"><code class="name flex">
<span>def <span class="ident">consume_scattered</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Set distributed argument location.</div>
<div class="epy_par">
<strong class="epy_sig">consume_scattered(self, p)</strong><div class="epy_nested">
<strong class="epy_parameter">p</strong> (C++: scattered_aloc_t
*)</div>
</div></div>
</dd>
<dt id="ida_typeinf.argloc_t.get_biggest"><code class="name flex">
<span>def <span class="ident">get_biggest</span></span>(<span>self, *args) &#8209;&gt;&#160;<a title="ida_typeinf.argloc_t" href="#ida_typeinf.argloc_t">argloc_t</a>::biggest_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get largest element in internal union.</div></div>
</dd>
<dt id="ida_typeinf.argloc_t.get_custom"><code class="name flex">
<span>def <span class="ident">get_custom</span></span>(<span>self, *args) &#8209;&gt;&#160;void&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get custom argloc info. Use if 'atype()' == 'ALOC_CUSTOM'</div></div>
</dd>
<dt id="ida_typeinf.argloc_t.get_ea"><code class="name flex">
<span>def <span class="ident">get_ea</span></span>(<span>self, *args) &#8209;&gt;&#160;ea_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get the global address. Use when 'atype()' == 'ALOC_STATIC'</div></div>
</dd>
<dt id="ida_typeinf.argloc_t.get_reginfo"><code class="name flex">
<span>def <span class="ident">get_reginfo</span></span>(<span>self, *args) &#8209;&gt;&#160;uint32</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get all register info. Use when 'atype()' == 'ALOC_REG1' or
'ALOC_REG2'</div></div>
</dd>
<dt id="ida_typeinf.argloc_t.get_rrel"><code class="name flex">
<span>def <span class="ident">get_rrel</span></span>(<span>self, *args) &#8209;&gt;&#160;<a title="ida_typeinf.rrel_t" href="#ida_typeinf.rrel_t">rrel_t</a>&#160;const&#160;&amp;</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get register-relative info. Use when 'atype()' == 'ALOC_RREL'</div></div>
</dd>
<dt id="ida_typeinf.argloc_t.has_reg"><code class="name flex">
<span>def <span class="ident">has_reg</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
TRUE if argloc has a register part.</div></div>
</dd>
<dt id="ida_typeinf.argloc_t.has_stkoff"><code class="name flex">
<span>def <span class="ident">has_stkoff</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
TRUE if argloc has a stack part.</div></div>
</dd>
<dt id="ida_typeinf.argloc_t.in_stack"><code class="name flex">
<span>def <span class="ident">in_stack</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
TRUE if argloc is in stack entirely.</div></div>
</dd>
<dt id="ida_typeinf.argloc_t.is_badloc"><code class="name flex">
<span>def <span class="ident">is_badloc</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
See 'ALOC_NONE' .</div></div>
</dd>
<dt id="ida_typeinf.argloc_t.is_custom"><code class="name flex">
<span>def <span class="ident">is_custom</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
See 'ALOC_CUSTOM' .</div></div>
</dd>
<dt id="ida_typeinf.argloc_t.is_ea"><code class="name flex">
<span>def <span class="ident">is_ea</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
See 'ALOC_STATIC' .</div></div>
</dd>
<dt id="ida_typeinf.argloc_t.is_fragmented"><code class="name flex">
<span>def <span class="ident">is_fragmented</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
'is_scattered()' || 'is_reg2()'</div></div>
</dd>
<dt id="ida_typeinf.argloc_t.is_mixed_scattered"><code class="name flex">
<span>def <span class="ident">is_mixed_scattered</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
mixed scattered: consists of register and stack parts</div></div>
</dd>
<dt id="ida_typeinf.argloc_t.is_reg"><code class="name flex">
<span>def <span class="ident">is_reg</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
'is_reg1()' || 'is_reg2()'</div></div>
</dd>
<dt id="ida_typeinf.argloc_t.is_reg1"><code class="name flex">
<span>def <span class="ident">is_reg1</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
See 'ALOC_REG1' .</div></div>
</dd>
<dt id="ida_typeinf.argloc_t.is_reg2"><code class="name flex">
<span>def <span class="ident">is_reg2</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
See 'ALOC_REG2' .</div></div>
</dd>
<dt id="ida_typeinf.argloc_t.is_rrel"><code class="name flex">
<span>def <span class="ident">is_rrel</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
See 'ALOC_RREL' .</div></div>
</dd>
<dt id="ida_typeinf.argloc_t.is_scattered"><code class="name flex">
<span>def <span class="ident">is_scattered</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
See 'ALOC_DIST' .</div></div>
</dd>
<dt id="ida_typeinf.argloc_t.is_stkoff"><code class="name flex">
<span>def <span class="ident">is_stkoff</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
See 'ALOC_STACK' .</div></div>
</dd>
<dt id="ida_typeinf.argloc_t.justify_reg_high"><code class="name flex">
<span>def <span class="ident">justify_reg_high</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Set register offset to justify it to the upper part of _SLOTSIZE.</div>
<div class="epy_par">
<strong class="epy_sig">justify_reg_high(self, size, _slotsize)</strong><div class="epy_nested">
<strong class="epy_parameter">size</strong> (C++: size_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">_slotsize</strong> (C++: size_t)</div>
</div></div>
</dd>
<dt id="ida_typeinf.argloc_t.justify_stkoff_right"><code class="name flex">
<span>def <span class="ident">justify_stkoff_right</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Set stack offset to right-justify it in _SLOTSIZE.</div>
<div class="epy_par">
<strong class="epy_sig">justify_stkoff_right(self, size, _slotsize)</strong><div class="epy_nested">
<strong class="epy_parameter">size</strong> (C++: size_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">_slotsize</strong> (C++: size_t)</div>
</div></div>
</dd>
<dt id="ida_typeinf.argloc_t.reg1"><code class="name flex">
<span>def <span class="ident">reg1</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get the register info. Use when 'atype()' == 'ALOC_REG1' or
'ALOC_REG2'</div></div>
</dd>
<dt id="ida_typeinf.argloc_t.reg2"><code class="name flex">
<span>def <span class="ident">reg2</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get info for the second register. Use when 'atype()' == 'ALOC_REG2'</div></div>
</dd>
<dt id="ida_typeinf.argloc_t.regoff"><code class="name flex">
<span>def <span class="ident">regoff</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get offset from the beginning of the register in bytes. Use when
'atype()' == 'ALOC_REG1'</div></div>
</dd>
<dt id="ida_typeinf.argloc_t.scattered"><code class="name flex">
<span>def <span class="ident">scattered</span></span>(<span>self, *args) &#8209;&gt;&#160;<a title="ida_typeinf.scattered_aloc_t" href="#ida_typeinf.scattered_aloc_t">scattered_aloc_t</a>&#160;const&#160;&amp;</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get scattered argument info. Use when 'atype()' == 'ALOC_DIST'</div></div>
</dd>
<dt id="ida_typeinf.argloc_t.set_badloc"><code class="name flex">
<span>def <span class="ident">set_badloc</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Set to invalid location.</div></div>
</dd>
<dt id="ida_typeinf.argloc_t.set_ea"><code class="name flex">
<span>def <span class="ident">set_ea</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Set static ea location.</div>
<div class="epy_par">
<strong class="epy_sig">set_ea(self, _ea)</strong><div class="epy_nested">
<strong class="epy_parameter">_ea</strong> (C++: ea_t)</div>
</div></div>
</dd>
<dt id="ida_typeinf.argloc_t.set_reg1"><code class="name flex">
<span>def <span class="ident">set_reg1</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Set register location.</div>
<div class="epy_par">
<strong class="epy_sig">set_reg1(self, reg, off=0)</strong><div class="epy_nested">
<strong class="epy_parameter">reg</strong> (C++: int)</div>
<div class="epy_nested">
<strong class="epy_parameter">off</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_typeinf.argloc_t.set_reg2"><code class="name flex">
<span>def <span class="ident">set_reg2</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Set secondary register location.</div>
<div class="epy_par">
<strong class="epy_sig">set_reg2(self, _reg1, _reg2)</strong><div class="epy_nested">
<strong class="epy_parameter">_reg1</strong> (C++: int)</div>
<div class="epy_nested">
<strong class="epy_parameter">_reg2</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_typeinf.argloc_t.set_stkoff"><code class="name flex">
<span>def <span class="ident">set_stkoff</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Set stack offset location.</div>
<div class="epy_par">
<strong class="epy_sig">set_stkoff(self, off)</strong><div class="epy_nested">
<strong class="epy_parameter">off</strong> (C++: sval_t)</div>
</div></div>
</dd>
<dt id="ida_typeinf.argloc_t.stkoff"><code class="name flex">
<span>def <span class="ident">stkoff</span></span>(<span>self, *args) &#8209;&gt;&#160;sval_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get the stack offset. Use if 'atype()' == 'ALOC_STACK'</div></div>
</dd>
<dt id="ida_typeinf.argloc_t.swap"><code class="name flex">
<span>def <span class="ident">swap</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Assign this == r and r == this.</div>
<div class="epy_par">
<strong class="epy_sig">swap(self, r)</strong><div class="epy_nested">
<strong class="epy_parameter">r</strong> (C++: argloc_t
&amp;)</div>
</div></div>
</dd>
</dl>
</dd>
<dt id="ida_typeinf.argpart_t"><code class="flex name class">
<span>class <span class="ident">argpart_t</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ argpart_t class.</div>
<div class="epy_par">
<strong class="epy_sig">__init__(self, a) -&gt; argpart_t</strong><div class="epy_nested">
a: argloc_t const &amp;</div>
</div></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="ida_typeinf.argloc_t" href="#ida_typeinf.argloc_t">argloc_t</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="ida_typeinf.argpart_t.off"><code class="name">var <span class="ident">off</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">argpart_t_off_get(self) -&gt; ushort</strong></div></div>
</dd>
<dt id="ida_typeinf.argpart_t.size"><code class="name">var <span class="ident">size</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">argpart_t_size_get(self) -&gt; ushort</strong></div></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ida_typeinf.argpart_t.bad_offset"><code class="name flex">
<span>def <span class="ident">bad_offset</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Does this argpart have a valid offset?</div></div>
</dd>
<dt id="ida_typeinf.argpart_t.bad_size"><code class="name flex">
<span>def <span class="ident">bad_size</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Does this argpart have a valid size?</div></div>
</dd>
<dt id="ida_typeinf.argpart_t.swap"><code class="name flex">
<span>def <span class="ident">swap</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Assign this = r and r = this.</div>
<div class="epy_par">
<strong class="epy_sig">swap(self, r)</strong><div class="epy_nested">
<strong class="epy_parameter">r</strong> (C++: argpart_t
&amp;)</div>
</div></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="ida_typeinf.argloc_t" href="#ida_typeinf.argloc_t">argloc_t</a></b></code>:
<ul class="hlist">
<li><code><a title="ida_typeinf.argloc_t.advance" href="#ida_typeinf.argloc_t.advance">advance</a></code></li>
<li><code><a title="ida_typeinf.argloc_t.atype" href="#ida_typeinf.argloc_t.atype">atype</a></code></li>
<li><code><a title="ida_typeinf.argloc_t.calc_offset" href="#ida_typeinf.argloc_t.calc_offset">calc_offset</a></code></li>
<li><code><a title="ida_typeinf.argloc_t.compare" href="#ida_typeinf.argloc_t.compare">compare</a></code></li>
<li><code><a title="ida_typeinf.argloc_t.consume_rrel" href="#ida_typeinf.argloc_t.consume_rrel">consume_rrel</a></code></li>
<li><code><a title="ida_typeinf.argloc_t.consume_scattered" href="#ida_typeinf.argloc_t.consume_scattered">consume_scattered</a></code></li>
<li><code><a title="ida_typeinf.argloc_t.get_biggest" href="#ida_typeinf.argloc_t.get_biggest">get_biggest</a></code></li>
<li><code><a title="ida_typeinf.argloc_t.get_custom" href="#ida_typeinf.argloc_t.get_custom">get_custom</a></code></li>
<li><code><a title="ida_typeinf.argloc_t.get_ea" href="#ida_typeinf.argloc_t.get_ea">get_ea</a></code></li>
<li><code><a title="ida_typeinf.argloc_t.get_reginfo" href="#ida_typeinf.argloc_t.get_reginfo">get_reginfo</a></code></li>
<li><code><a title="ida_typeinf.argloc_t.get_rrel" href="#ida_typeinf.argloc_t.get_rrel">get_rrel</a></code></li>
<li><code><a title="ida_typeinf.argloc_t.has_reg" href="#ida_typeinf.argloc_t.has_reg">has_reg</a></code></li>
<li><code><a title="ida_typeinf.argloc_t.has_stkoff" href="#ida_typeinf.argloc_t.has_stkoff">has_stkoff</a></code></li>
<li><code><a title="ida_typeinf.argloc_t.in_stack" href="#ida_typeinf.argloc_t.in_stack">in_stack</a></code></li>
<li><code><a title="ida_typeinf.argloc_t.is_badloc" href="#ida_typeinf.argloc_t.is_badloc">is_badloc</a></code></li>
<li><code><a title="ida_typeinf.argloc_t.is_custom" href="#ida_typeinf.argloc_t.is_custom">is_custom</a></code></li>
<li><code><a title="ida_typeinf.argloc_t.is_ea" href="#ida_typeinf.argloc_t.is_ea">is_ea</a></code></li>
<li><code><a title="ida_typeinf.argloc_t.is_fragmented" href="#ida_typeinf.argloc_t.is_fragmented">is_fragmented</a></code></li>
<li><code><a title="ida_typeinf.argloc_t.is_mixed_scattered" href="#ida_typeinf.argloc_t.is_mixed_scattered">is_mixed_scattered</a></code></li>
<li><code><a title="ida_typeinf.argloc_t.is_reg" href="#ida_typeinf.argloc_t.is_reg">is_reg</a></code></li>
<li><code><a title="ida_typeinf.argloc_t.is_reg1" href="#ida_typeinf.argloc_t.is_reg1">is_reg1</a></code></li>
<li><code><a title="ida_typeinf.argloc_t.is_reg2" href="#ida_typeinf.argloc_t.is_reg2">is_reg2</a></code></li>
<li><code><a title="ida_typeinf.argloc_t.is_rrel" href="#ida_typeinf.argloc_t.is_rrel">is_rrel</a></code></li>
<li><code><a title="ida_typeinf.argloc_t.is_scattered" href="#ida_typeinf.argloc_t.is_scattered">is_scattered</a></code></li>
<li><code><a title="ida_typeinf.argloc_t.is_stkoff" href="#ida_typeinf.argloc_t.is_stkoff">is_stkoff</a></code></li>
<li><code><a title="ida_typeinf.argloc_t.justify_reg_high" href="#ida_typeinf.argloc_t.justify_reg_high">justify_reg_high</a></code></li>
<li><code><a title="ida_typeinf.argloc_t.justify_stkoff_right" href="#ida_typeinf.argloc_t.justify_stkoff_right">justify_stkoff_right</a></code></li>
<li><code><a title="ida_typeinf.argloc_t.reg1" href="#ida_typeinf.argloc_t.reg1">reg1</a></code></li>
<li><code><a title="ida_typeinf.argloc_t.reg2" href="#ida_typeinf.argloc_t.reg2">reg2</a></code></li>
<li><code><a title="ida_typeinf.argloc_t.regoff" href="#ida_typeinf.argloc_t.regoff">regoff</a></code></li>
<li><code><a title="ida_typeinf.argloc_t.scattered" href="#ida_typeinf.argloc_t.scattered">scattered</a></code></li>
<li><code><a title="ida_typeinf.argloc_t.set_badloc" href="#ida_typeinf.argloc_t.set_badloc">set_badloc</a></code></li>
<li><code><a title="ida_typeinf.argloc_t.set_ea" href="#ida_typeinf.argloc_t.set_ea">set_ea</a></code></li>
<li><code><a title="ida_typeinf.argloc_t.set_reg1" href="#ida_typeinf.argloc_t.set_reg1">set_reg1</a></code></li>
<li><code><a title="ida_typeinf.argloc_t.set_reg2" href="#ida_typeinf.argloc_t.set_reg2">set_reg2</a></code></li>
<li><code><a title="ida_typeinf.argloc_t.set_stkoff" href="#ida_typeinf.argloc_t.set_stkoff">set_stkoff</a></code></li>
<li><code><a title="ida_typeinf.argloc_t.stkoff" href="#ida_typeinf.argloc_t.stkoff">stkoff</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="ida_typeinf.argpartvec_t"><code class="flex name class">
<span>class <span class="ident">argpartvec_t</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ qvector&lt; argpart_t &gt; class.</div>
<div class="epy_par">
<strong class="epy_sig">__init__(self) -&gt; argpartvec_t</strong><div class="epy_nested">
x: qvector&lt; argpart_t &gt; const &amp;</div>
</div></div>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="ida_typeinf.scattered_aloc_t" href="#ida_typeinf.scattered_aloc_t">scattered_aloc_t</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="ida_typeinf.argpartvec_t.add_unique"><code class="name flex">
<span>def <span class="ident">add_unique</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">add_unique(self, x) -&gt; bool</strong><div class="epy_nested">
x: argpart_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_typeinf.argpartvec_t.at"><code class="name flex">
<span>def <span class="ident">at</span></span>(<span>self, *args) &#8209;&gt;&#160;<a title="ida_typeinf.argpart_t" href="#ida_typeinf.argpart_t">argpart_t</a>&#160;const&#160;&amp;</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">at(self, _idx) -&gt; argpart_t</strong><div class="epy_nested">
_idx: size_t</div>
</div></div>
</dd>
<dt id="ida_typeinf.argpartvec_t.back"><code class="name flex">
<span>def <span class="ident">back</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"/>
</dd>
<dt id="ida_typeinf.argpartvec_t.begin"><code class="name flex">
<span>def <span class="ident">begin</span></span>(<span>self, *args) &#8209;&gt;&#160;qvectorargpart_t&#160;&gt;::const_iterator</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">begin(self) -&gt; argpart_t</strong></div>
<div class="epy_par">
<strong class="epy_sig">begin(self) -&gt; argpart_t</strong></div></div>
</dd>
<dt id="ida_typeinf.argpartvec_t.capacity"><code class="name flex">
<span>def <span class="ident">capacity</span></span>(<span>self, *args) &#8209;&gt;&#160;size_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">capacity(self) -&gt; size_t</strong></div></div>
</dd>
<dt id="ida_typeinf.argpartvec_t.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">clear(self)</strong></div></div>
</dd>
<dt id="ida_typeinf.argpartvec_t.empty"><code class="name flex">
<span>def <span class="ident">empty</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">empty(self) -&gt; bool</strong></div></div>
</dd>
<dt id="ida_typeinf.argpartvec_t.end"><code class="name flex">
<span>def <span class="ident">end</span></span>(<span>self, *args) &#8209;&gt;&#160;qvectorargpart_t&#160;&gt;::const_iterator</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">end(self) -&gt; argpart_t</strong></div>
<div class="epy_par">
<strong class="epy_sig">end(self) -&gt; argpart_t</strong></div></div>
</dd>
<dt id="ida_typeinf.argpartvec_t.erase"><code class="name flex">
<span>def <span class="ident">erase</span></span>(<span>self, *args) &#8209;&gt;&#160;qvectorargpart_t&#160;&gt;::iterator</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">erase(self, it) -&gt; argpart_t</strong><div class="epy_nested">
it: qvector&lt; argpart_t &gt;::iterator</div>
</div>
<div class="epy_par">
<strong class="epy_sig">erase(self, first, last) -&gt; argpart_t</strong><div class="epy_nested">
first: qvector&lt; argpart_t &gt;::iterator
last: qvector&lt; argpart_t &gt;::iterator</div>
</div></div>
</dd>
<dt id="ida_typeinf.argpartvec_t.extract"><code class="name flex">
<span>def <span class="ident">extract</span></span>(<span>self, *args) &#8209;&gt;&#160;<a title="ida_typeinf.argpart_t" href="#ida_typeinf.argpart_t">argpart_t</a>&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">extract(self) -&gt; argpart_t</strong></div></div>
</dd>
<dt id="ida_typeinf.argpartvec_t.find"><code class="name flex">
<span>def <span class="ident">find</span></span>(<span>self, *args) &#8209;&gt;&#160;qvectorargpart_t&#160;&gt;::const_iterator</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">find(self, x) -&gt; argpart_t</strong><div class="epy_nested">
x: argpart_t const &amp;</div>
</div>
<div class="epy_par">
<strong class="epy_sig">find(self, x) -&gt; argpart_t</strong><div class="epy_nested">
x: argpart_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_typeinf.argpartvec_t.front"><code class="name flex">
<span>def <span class="ident">front</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"/>
</dd>
<dt id="ida_typeinf.argpartvec_t.grow"><code class="name flex">
<span>def <span class="ident">grow</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
grow(self, x=argpart_t())<div class="epy_nested">
x: argpart_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_typeinf.argpartvec_t.has"><code class="name flex">
<span>def <span class="ident">has</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">has(self, x) -&gt; bool</strong><div class="epy_nested">
x: argpart_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_typeinf.argpartvec_t.inject"><code class="name flex">
<span>def <span class="ident">inject</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">inject(self, s, len)</strong><div class="epy_nested">
s: argpart_t *
len: size_t</div>
</div></div>
</dd>
<dt id="ida_typeinf.argpartvec_t.insert"><code class="name flex">
<span>def <span class="ident">insert</span></span>(<span>self, *args) &#8209;&gt;&#160;qvectorargpart_t&#160;&gt;::iterator</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">insert(self, it, x) -&gt; argpart_t</strong><div class="epy_nested">
it: qvector&lt; argpart_t &gt;::iterator
x: argpart_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_typeinf.argpartvec_t.pop_back"><code class="name flex">
<span>def <span class="ident">pop_back</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">pop_back(self)</strong></div></div>
</dd>
<dt id="ida_typeinf.argpartvec_t.push_back"><code class="name flex">
<span>def <span class="ident">push_back</span></span>(<span>self, *args) &#8209;&gt;&#160;<a title="ida_typeinf.argpart_t" href="#ida_typeinf.argpart_t">argpart_t</a>&#160;&amp;</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">push_back(self, x)</strong><div class="epy_nested">
x: argpart_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_typeinf.argpartvec_t.qclear"><code class="name flex">
<span>def <span class="ident">qclear</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">qclear(self)</strong></div></div>
</dd>
<dt id="ida_typeinf.argpartvec_t.reserve"><code class="name flex">
<span>def <span class="ident">reserve</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">reserve(self, cnt)</strong><div class="epy_nested">
cnt: size_t</div>
</div></div>
</dd>
<dt id="ida_typeinf.argpartvec_t.resize"><code class="name flex">
<span>def <span class="ident">resize</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">resize(self, _newsize, x)</strong><div class="epy_nested">
_newsize: size_t
x: argpart_t const &amp;</div>
</div>
<div class="epy_par">
<strong class="epy_sig">resize(self, _newsize)</strong><div class="epy_nested">
_newsize: size_t</div>
</div></div>
</dd>
<dt id="ida_typeinf.argpartvec_t.size"><code class="name flex">
<span>def <span class="ident">size</span></span>(<span>self, *args) &#8209;&gt;&#160;size_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">size(self) -&gt; size_t</strong></div></div>
</dd>
<dt id="ida_typeinf.argpartvec_t.swap"><code class="name flex">
<span>def <span class="ident">swap</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">swap(self, r)</strong><div class="epy_nested">
r: qvector&lt; argpart_t &gt; &amp;</div>
</div></div>
</dd>
<dt id="ida_typeinf.argpartvec_t.truncate"><code class="name flex">
<span>def <span class="ident">truncate</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">truncate(self)</strong></div></div>
</dd>
</dl>
</dd>
<dt id="ida_typeinf.argtinfo_helper_t"><code class="flex name class">
<span>class <span class="ident">argtinfo_helper_t</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ argtinfo_helper_t class.</div>
<div class="epy_par">
<strong class="epy_sig">__init__(self) -&gt; argtinfo_helper_t</strong><div class="epy_nested">
self: PyObject *</div>
</div></div>
<h3>Instance variables</h3>
<dl>
<dt id="ida_typeinf.argtinfo_helper_t.reserved"><code class="name">var <span class="ident">reserved</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">argtinfo_helper_t_reserved_get(self) -&gt; size_t</strong></div></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ida_typeinf.argtinfo_helper_t.has_delay_slot"><code class="name flex">
<span>def <span class="ident">has_delay_slot</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
The call instruction with a delay slot?.</div>
<div class="epy_par">
<strong class="epy_sig">has_delay_slot(self, arg0) -&gt; bool</strong><div class="epy_nested">
arg0: ea_t</div>
</div></div>
</dd>
<dt id="ida_typeinf.argtinfo_helper_t.is_stkarg_load"><code class="name flex">
<span>def <span class="ident">is_stkarg_load</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is the current insn a stkarg load?. if yes:src: index of the source
operand in \insn_t{ops}
dst: index of the destination operand in</div>
<div class="epy_par">
\insn_t{ops}<div class="epy_nested">
\insn_t{ops}[dst].addr is expected to have the stack
offset</div>
</div>
<div class="epy_par">
<strong class="epy_sig">is_stkarg_load(self, insn, src, dst) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">insn</strong>
- an ida_ua.insn_t, or an address (C++: const insn_t &amp;)</div>
<div class="epy_nested">
<strong class="epy_parameter">src</strong> (C++: int *)</div>
<div class="epy_nested">
<strong class="epy_parameter">dst</strong> (C++: int *)</div>
</div></div>
</dd>
<dt id="ida_typeinf.argtinfo_helper_t.set_op_tinfo"><code class="name flex">
<span>def <span class="ident">set_op_tinfo</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Set the operand type as specified.</div>
<div class="epy_par">
<strong class="epy_sig">set_op_tinfo(self, insn, x, tif, name) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">insn</strong>
- an ida_ua.insn_t, or an address (C++: const insn_t &amp;)</div>
<div class="epy_nested">
<strong class="epy_parameter">x</strong> (C++: const
op_t
&amp;)</div>
<div class="epy_nested">
<strong class="epy_parameter">tif</strong> (C++: const
tinfo_t
&amp;)</div>
<div class="epy_nested">
<strong class="epy_parameter">name</strong> (C++: const char *)</div>
</div></div>
</dd>
<dt id="ida_typeinf.argtinfo_helper_t.use_arg_tinfos"><code class="name flex">
<span>def <span class="ident">use_arg_tinfos</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
This function is to be called by the processor module in response to
ev_use_arg_types.</div>
<div class="epy_par">
<strong class="epy_sig">use_arg_tinfos(self, caller, fti, rargs)</strong><div class="epy_nested">
<strong class="epy_parameter">caller</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">fti</strong> (C++: func_type_data_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">rargs</strong> (C++: funcargvec_t
*)</div>
</div></div>
</dd>
</dl>
</dd>
<dt id="ida_typeinf.array_type_data_t"><code class="flex name class">
<span>class <span class="ident">array_type_data_t</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ array_type_data_t class.</div>
<div class="epy_par">
<strong class="epy_sig">__init__(self, b=0, n=0) -&gt; array_type_data_t</strong><div class="epy_nested">
b: size_t
n: size_t</div>
</div></div>
<h3>Instance variables</h3>
<dl>
<dt id="ida_typeinf.array_type_data_t.base"><code class="name">var <span class="ident">base</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">array_type_data_t_base_get(self) -&gt; uint32</strong></div></div>
</dd>
<dt id="ida_typeinf.array_type_data_t.elem_type"><code class="name">var <span class="ident">elem_type</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">array_type_data_t_elem_type_get(self) -&gt; tinfo_t</strong></div></div>
</dd>
<dt id="ida_typeinf.array_type_data_t.nelems"><code class="name">var <span class="ident">nelems</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">array_type_data_t_nelems_get(self) -&gt; uint32</strong></div></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ida_typeinf.array_type_data_t.swap"><code class="name flex">
<span>def <span class="ident">swap</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
set this = r and r = this</div>
<div class="epy_par">
<strong class="epy_sig">swap(self, r)</strong><div class="epy_nested">
<strong class="epy_parameter">r</strong> (C++: array_type_data_t
&amp;)</div>
</div></div>
</dd>
</dl>
</dd>
<dt id="ida_typeinf.bitfield_type_data_t"><code class="flex name class">
<span>class <span class="ident">bitfield_type_data_t</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ bitfield_type_data_t class.</div>
<div class="epy_par">
<strong class="epy_sig">__init__(self, _nbytes=0, _width=0, _is_unsigned=False) -&gt; bitfield_type_data_t</strong><div class="epy_nested">
_nbytes: uchar
_width: uchar
_is_unsigned: bool</div>
</div></div>
<h3>Instance variables</h3>
<dl>
<dt id="ida_typeinf.bitfield_type_data_t.is_unsigned"><code class="name">var <span class="ident">is_unsigned</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">bitfield_type_data_t_is_unsigned_get(self) -&gt; bool</strong></div></div>
</dd>
<dt id="ida_typeinf.bitfield_type_data_t.nbytes"><code class="name">var <span class="ident">nbytes</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">bitfield_type_data_t_nbytes_get(self) -&gt; uchar</strong></div></div>
</dd>
<dt id="ida_typeinf.bitfield_type_data_t.width"><code class="name">var <span class="ident">width</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">bitfield_type_data_t_width_get(self) -&gt; uchar</strong></div></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ida_typeinf.bitfield_type_data_t.compare"><code class="name flex">
<span>def <span class="ident">compare</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">compare(self, r) -&gt; int</strong><div class="epy_nested">
r: bitfield_type_data_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_typeinf.bitfield_type_data_t.swap"><code class="name flex">
<span>def <span class="ident">swap</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">swap(self, r)</strong><div class="epy_nested">
<strong class="epy_parameter">r</strong> (C++: bitfield_type_data_t
&amp;)</div>
</div></div>
</dd>
</dl>
</dd>
<dt id="ida_typeinf.callregs_t"><code class="flex name class">
<span>class <span class="ident">callregs_t</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ callregs_t class.</div>
<div class="epy_par">
<strong class="epy_sig">__init__(self) -&gt; callregs_t</strong><div class="epy_nested">
cc: cm_t</div>
</div></div>
<h3>Static methods</h3>
<dl>
<dt id="ida_typeinf.callregs_t.regcount"><code class="name flex">
<span>def <span class="ident">regcount</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">regcount(cc) -&gt; int</strong><div class="epy_nested">
cc: cm_t</div>
</div></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="ida_typeinf.callregs_t.fpregs"><code class="name">var <span class="ident">fpregs</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">callregs_t_fpregs_get(self) -&gt; intvec_t *</strong></div></div>
</dd>
<dt id="ida_typeinf.callregs_t.gpregs"><code class="name">var <span class="ident">gpregs</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">callregs_t_gpregs_get(self) -&gt; intvec_t *</strong></div></div>
</dd>
<dt id="ida_typeinf.callregs_t.nregs"><code class="name">var <span class="ident">nregs</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">callregs_t_nregs_get(self) -&gt; int</strong></div></div>
</dd>
<dt id="ida_typeinf.callregs_t.policy"><code class="name">var <span class="ident">policy</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">callregs_t_policy_get(self) -&gt; argreg_policy_t</strong></div></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ida_typeinf.callregs_t.by_slots"><code class="name flex">
<span>def <span class="ident">by_slots</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">by_slots(self) -&gt; bool</strong></div></div>
</dd>
<dt id="ida_typeinf.callregs_t.init_regs"><code class="name flex">
<span>def <span class="ident">init_regs</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Init policy &amp; registers for given CC.</div>
<div class="epy_par">
<strong class="epy_sig">init_regs(self, cc)</strong><div class="epy_nested">
<strong class="epy_parameter">cc</strong> (C++: cm_t)</div>
</div></div>
</dd>
<dt id="ida_typeinf.callregs_t.reginds"><code class="name flex">
<span>def <span class="ident">reginds</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get register indexes within GP/FP arrays. (-1 -&gt; is not present in the
corresponding array)</div>
<div class="epy_par">
<strong class="epy_sig">reginds(self, gp_ind, fp_ind, r) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">gp_ind</strong> (C++: int *)</div>
<div class="epy_nested">
<strong class="epy_parameter">fp_ind</strong> (C++: int *)</div>
<div class="epy_nested">
<strong class="epy_parameter">r</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_typeinf.callregs_t.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Set policy and registers to invalid values.</div></div>
</dd>
<dt id="ida_typeinf.callregs_t.set"><code class="name flex">
<span>def <span class="ident">set</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Init policy &amp; registers (arrays are -1-terminated)</div>
<div class="epy_par">
<strong class="epy_sig">set(self, _policy, gprs, fprs)</strong><div class="epy_nested">
<strong class="epy_parameter">_policy</strong> (C++: argreg_policy_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">gprs</strong> (C++: const int *)</div>
<div class="epy_nested">
<strong class="epy_parameter">fprs</strong> (C++: const int *)</div>
</div></div>
</dd>
</dl>
</dd>
<dt id="ida_typeinf.const_aloc_visitor_t"><code class="flex name class">
<span>class <span class="ident">const_aloc_visitor_t</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ const_aloc_visitor_t class.</div>
<div class="epy_par">
<strong class="epy_sig">__init__(self) -&gt; const_aloc_visitor_t</strong><div class="epy_nested">
self: PyObject *</div>
</div></div>
<h3>Methods</h3>
<dl>
<dt id="ida_typeinf.const_aloc_visitor_t.visit_location"><code class="name flex">
<span>def <span class="ident">visit_location</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">visit_location(self, v, off, size) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">v</strong> (C++: const
argloc_t
&amp;)</div>
<div class="epy_nested">
<strong class="epy_parameter">off</strong> (C++: int)</div>
<div class="epy_nested">
<strong class="epy_parameter">size</strong> (C++: int)</div>
</div></div>
</dd>
</dl>
</dd>
<dt id="ida_typeinf.enum_member_t"><code class="flex name class">
<span>class <span class="ident">enum_member_t</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ enum_member_t class.</div>
<div class="epy_par">
<strong class="epy_sig">__init__(self) -&gt; enum_member_t</strong></div></div>
<h3>Instance variables</h3>
<dl>
<dt id="ida_typeinf.enum_member_t.cmt"><code class="name">var <span class="ident">cmt</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">enum_member_t_cmt_get(self) -&gt; qstring *</strong></div></div>
</dd>
<dt id="ida_typeinf.enum_member_t.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">enum_member_t_name_get(self) -&gt; qstring *</strong></div></div>
</dd>
<dt id="ida_typeinf.enum_member_t.value"><code class="name">var <span class="ident">value</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">enum_member_t_value_get(self) -&gt; uint64</strong></div></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ida_typeinf.enum_member_t.swap"><code class="name flex">
<span>def <span class="ident">swap</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">swap(self, r)</strong><div class="epy_nested">
<strong class="epy_parameter">r</strong> (C++: enum_member_t
&amp;)</div>
</div></div>
</dd>
</dl>
</dd>
<dt id="ida_typeinf.enum_member_vec_t"><code class="flex name class">
<span>class <span class="ident">enum_member_vec_t</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ qvector&lt; enum_member_t &gt; class.</div>
<div class="epy_par">
<strong class="epy_sig">__init__(self) -&gt; enum_member_vec_t</strong><div class="epy_nested">
x: qvector&lt; enum_member_t &gt; const &amp;</div>
</div></div>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="ida_typeinf.enum_type_data_t" href="#ida_typeinf.enum_type_data_t">enum_type_data_t</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="ida_typeinf.enum_member_vec_t.add_unique"><code class="name flex">
<span>def <span class="ident">add_unique</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">add_unique(self, x) -&gt; bool</strong><div class="epy_nested">
x: enum_member_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_typeinf.enum_member_vec_t.at"><code class="name flex">
<span>def <span class="ident">at</span></span>(<span>self, *args) &#8209;&gt;&#160;<a title="ida_typeinf.enum_member_t" href="#ida_typeinf.enum_member_t">enum_member_t</a>&#160;const&#160;&amp;</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">at(self, _idx) -&gt; enum_member_t</strong><div class="epy_nested">
_idx: size_t</div>
</div></div>
</dd>
<dt id="ida_typeinf.enum_member_vec_t.back"><code class="name flex">
<span>def <span class="ident">back</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"/>
</dd>
<dt id="ida_typeinf.enum_member_vec_t.begin"><code class="name flex">
<span>def <span class="ident">begin</span></span>(<span>self, *args) &#8209;&gt;&#160;qvectorenum_member_t&#160;&gt;::const_iterator</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">begin(self) -&gt; enum_member_t</strong></div>
<div class="epy_par">
<strong class="epy_sig">begin(self) -&gt; enum_member_t</strong></div></div>
</dd>
<dt id="ida_typeinf.enum_member_vec_t.capacity"><code class="name flex">
<span>def <span class="ident">capacity</span></span>(<span>self, *args) &#8209;&gt;&#160;size_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">capacity(self) -&gt; size_t</strong></div></div>
</dd>
<dt id="ida_typeinf.enum_member_vec_t.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">clear(self)</strong></div></div>
</dd>
<dt id="ida_typeinf.enum_member_vec_t.empty"><code class="name flex">
<span>def <span class="ident">empty</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">empty(self) -&gt; bool</strong></div></div>
</dd>
<dt id="ida_typeinf.enum_member_vec_t.end"><code class="name flex">
<span>def <span class="ident">end</span></span>(<span>self, *args) &#8209;&gt;&#160;qvectorenum_member_t&#160;&gt;::const_iterator</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">end(self) -&gt; enum_member_t</strong></div>
<div class="epy_par">
<strong class="epy_sig">end(self) -&gt; enum_member_t</strong></div></div>
</dd>
<dt id="ida_typeinf.enum_member_vec_t.erase"><code class="name flex">
<span>def <span class="ident">erase</span></span>(<span>self, *args) &#8209;&gt;&#160;qvectorenum_member_t&#160;&gt;::iterator</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">erase(self, it) -&gt; enum_member_t</strong><div class="epy_nested">
it: qvector&lt; enum_member_t &gt;::iterator</div>
</div>
<div class="epy_par">
<strong class="epy_sig">erase(self, first, last) -&gt; enum_member_t</strong><div class="epy_nested">
first: qvector&lt; enum_member_t &gt;::iterator
last: qvector&lt; enum_member_t &gt;::iterator</div>
</div></div>
</dd>
<dt id="ida_typeinf.enum_member_vec_t.extract"><code class="name flex">
<span>def <span class="ident">extract</span></span>(<span>self, *args) &#8209;&gt;&#160;<a title="ida_typeinf.enum_member_t" href="#ida_typeinf.enum_member_t">enum_member_t</a>&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">extract(self) -&gt; enum_member_t</strong></div></div>
</dd>
<dt id="ida_typeinf.enum_member_vec_t.find"><code class="name flex">
<span>def <span class="ident">find</span></span>(<span>self, *args) &#8209;&gt;&#160;qvectorenum_member_t&#160;&gt;::const_iterator</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">find(self, x) -&gt; enum_member_t</strong><div class="epy_nested">
x: enum_member_t const &amp;</div>
</div>
<div class="epy_par">
<strong class="epy_sig">find(self, x) -&gt; enum_member_t</strong><div class="epy_nested">
x: enum_member_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_typeinf.enum_member_vec_t.front"><code class="name flex">
<span>def <span class="ident">front</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"/>
</dd>
<dt id="ida_typeinf.enum_member_vec_t.grow"><code class="name flex">
<span>def <span class="ident">grow</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
grow(self, x=enum_member_t())<div class="epy_nested">
x: enum_member_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_typeinf.enum_member_vec_t.has"><code class="name flex">
<span>def <span class="ident">has</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">has(self, x) -&gt; bool</strong><div class="epy_nested">
x: enum_member_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_typeinf.enum_member_vec_t.inject"><code class="name flex">
<span>def <span class="ident">inject</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">inject(self, s, len)</strong><div class="epy_nested">
s: enum_member_t *
len: size_t</div>
</div></div>
</dd>
<dt id="ida_typeinf.enum_member_vec_t.insert"><code class="name flex">
<span>def <span class="ident">insert</span></span>(<span>self, *args) &#8209;&gt;&#160;qvectorenum_member_t&#160;&gt;::iterator</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">insert(self, it, x) -&gt; enum_member_t</strong><div class="epy_nested">
it: qvector&lt; enum_member_t &gt;::iterator
x: enum_member_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_typeinf.enum_member_vec_t.pop_back"><code class="name flex">
<span>def <span class="ident">pop_back</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">pop_back(self)</strong></div></div>
</dd>
<dt id="ida_typeinf.enum_member_vec_t.push_back"><code class="name flex">
<span>def <span class="ident">push_back</span></span>(<span>self, *args) &#8209;&gt;&#160;<a title="ida_typeinf.enum_member_t" href="#ida_typeinf.enum_member_t">enum_member_t</a>&#160;&amp;</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">push_back(self, x)</strong><div class="epy_nested">
x: enum_member_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_typeinf.enum_member_vec_t.qclear"><code class="name flex">
<span>def <span class="ident">qclear</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">qclear(self)</strong></div></div>
</dd>
<dt id="ida_typeinf.enum_member_vec_t.reserve"><code class="name flex">
<span>def <span class="ident">reserve</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">reserve(self, cnt)</strong><div class="epy_nested">
cnt: size_t</div>
</div></div>
</dd>
<dt id="ida_typeinf.enum_member_vec_t.resize"><code class="name flex">
<span>def <span class="ident">resize</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">resize(self, _newsize, x)</strong><div class="epy_nested">
_newsize: size_t
x: enum_member_t const &amp;</div>
</div>
<div class="epy_par">
<strong class="epy_sig">resize(self, _newsize)</strong><div class="epy_nested">
_newsize: size_t</div>
</div></div>
</dd>
<dt id="ida_typeinf.enum_member_vec_t.size"><code class="name flex">
<span>def <span class="ident">size</span></span>(<span>self, *args) &#8209;&gt;&#160;size_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">size(self) -&gt; size_t</strong></div></div>
</dd>
<dt id="ida_typeinf.enum_member_vec_t.swap"><code class="name flex">
<span>def <span class="ident">swap</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">swap(self, r)</strong><div class="epy_nested">
r: qvector&lt; enum_member_t &gt; &amp;</div>
</div></div>
</dd>
<dt id="ida_typeinf.enum_member_vec_t.truncate"><code class="name flex">
<span>def <span class="ident">truncate</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">truncate(self)</strong></div></div>
</dd>
</dl>
</dd>
<dt id="ida_typeinf.enum_type_data_t"><code class="flex name class">
<span>class <span class="ident">enum_type_data_t</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ enum_type_data_t class.</div>
<div class="epy_par">
<strong class="epy_sig">__init__(self, _bte=BTE_ALWAYS|BTE_HEX) -&gt; enum_type_data_t</strong><div class="epy_nested">
_bte: bte_t</div>
</div></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="ida_typeinf.enum_member_vec_t" href="#ida_typeinf.enum_member_vec_t">enum_member_vec_t</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="ida_typeinf.enum_type_data_t.bte"><code class="name">var <span class="ident">bte</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">enum_type_data_t_bte_get(self) -&gt; bte_t</strong></div></div>
</dd>
<dt id="ida_typeinf.enum_type_data_t.group_sizes"><code class="name">var <span class="ident">group_sizes</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">enum_type_data_t_group_sizes_get(self) -&gt; intvec_t *</strong></div></div>
</dd>
<dt id="ida_typeinf.enum_type_data_t.taenum_bits"><code class="name">var <span class="ident">taenum_bits</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">enum_type_data_t_taenum_bits_get(self) -&gt; uint32</strong></div></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ida_typeinf.enum_type_data_t.calc_mask"><code class="name flex">
<span>def <span class="ident">calc_mask</span></span>(<span>self, *args) &#8209;&gt;&#160;uint64</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">calc_mask(self) -&gt; uint64</strong></div></div>
</dd>
<dt id="ida_typeinf.enum_type_data_t.calc_nbytes"><code class="name flex">
<span>def <span class="ident">calc_nbytes</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">calc_nbytes(self) -&gt; int</strong></div></div>
</dd>
<dt id="ida_typeinf.enum_type_data_t.is_64bit"><code class="name flex">
<span>def <span class="ident">is_64bit</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">is_64bit(self) -&gt; bool</strong></div></div>
</dd>
<dt id="ida_typeinf.enum_type_data_t.is_char"><code class="name flex">
<span>def <span class="ident">is_char</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">is_char(self) -&gt; bool</strong></div></div>
</dd>
<dt id="ida_typeinf.enum_type_data_t.is_hex"><code class="name flex">
<span>def <span class="ident">is_hex</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">is_hex(self) -&gt; bool</strong></div></div>
</dd>
<dt id="ida_typeinf.enum_type_data_t.is_sdec"><code class="name flex">
<span>def <span class="ident">is_sdec</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">is_sdec(self) -&gt; bool</strong></div></div>
</dd>
<dt id="ida_typeinf.enum_type_data_t.is_udec"><code class="name flex">
<span>def <span class="ident">is_udec</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">is_udec(self) -&gt; bool</strong></div></div>
</dd>
<dt id="ida_typeinf.enum_type_data_t.swap"><code class="name flex">
<span>def <span class="ident">swap</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
swap two instances</div>
<div class="epy_par">
<strong class="epy_sig">swap(self, r)</strong><div class="epy_nested">
<strong class="epy_parameter">r</strong> (C++: enum_type_data_t
&amp;)</div>
</div></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="ida_typeinf.enum_member_vec_t" href="#ida_typeinf.enum_member_vec_t">enum_member_vec_t</a></b></code>:
<ul class="hlist">
<li><code><a title="ida_typeinf.enum_member_vec_t.add_unique" href="#ida_typeinf.enum_member_vec_t.add_unique">add_unique</a></code></li>
<li><code><a title="ida_typeinf.enum_member_vec_t.at" href="#ida_typeinf.enum_member_vec_t.at">at</a></code></li>
<li><code><a title="ida_typeinf.enum_member_vec_t.begin" href="#ida_typeinf.enum_member_vec_t.begin">begin</a></code></li>
<li><code><a title="ida_typeinf.enum_member_vec_t.capacity" href="#ida_typeinf.enum_member_vec_t.capacity">capacity</a></code></li>
<li><code><a title="ida_typeinf.enum_member_vec_t.clear" href="#ida_typeinf.enum_member_vec_t.clear">clear</a></code></li>
<li><code><a title="ida_typeinf.enum_member_vec_t.empty" href="#ida_typeinf.enum_member_vec_t.empty">empty</a></code></li>
<li><code><a title="ida_typeinf.enum_member_vec_t.end" href="#ida_typeinf.enum_member_vec_t.end">end</a></code></li>
<li><code><a title="ida_typeinf.enum_member_vec_t.erase" href="#ida_typeinf.enum_member_vec_t.erase">erase</a></code></li>
<li><code><a title="ida_typeinf.enum_member_vec_t.extract" href="#ida_typeinf.enum_member_vec_t.extract">extract</a></code></li>
<li><code><a title="ida_typeinf.enum_member_vec_t.find" href="#ida_typeinf.enum_member_vec_t.find">find</a></code></li>
<li><code><a title="ida_typeinf.enum_member_vec_t.grow" href="#ida_typeinf.enum_member_vec_t.grow">grow</a></code></li>
<li><code><a title="ida_typeinf.enum_member_vec_t.has" href="#ida_typeinf.enum_member_vec_t.has">has</a></code></li>
<li><code><a title="ida_typeinf.enum_member_vec_t.inject" href="#ida_typeinf.enum_member_vec_t.inject">inject</a></code></li>
<li><code><a title="ida_typeinf.enum_member_vec_t.insert" href="#ida_typeinf.enum_member_vec_t.insert">insert</a></code></li>
<li><code><a title="ida_typeinf.enum_member_vec_t.pop_back" href="#ida_typeinf.enum_member_vec_t.pop_back">pop_back</a></code></li>
<li><code><a title="ida_typeinf.enum_member_vec_t.push_back" href="#ida_typeinf.enum_member_vec_t.push_back">push_back</a></code></li>
<li><code><a title="ida_typeinf.enum_member_vec_t.qclear" href="#ida_typeinf.enum_member_vec_t.qclear">qclear</a></code></li>
<li><code><a title="ida_typeinf.enum_member_vec_t.reserve" href="#ida_typeinf.enum_member_vec_t.reserve">reserve</a></code></li>
<li><code><a title="ida_typeinf.enum_member_vec_t.resize" href="#ida_typeinf.enum_member_vec_t.resize">resize</a></code></li>
<li><code><a title="ida_typeinf.enum_member_vec_t.size" href="#ida_typeinf.enum_member_vec_t.size">size</a></code></li>
<li><code><a title="ida_typeinf.enum_member_vec_t.truncate" href="#ida_typeinf.enum_member_vec_t.truncate">truncate</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="ida_typeinf.func_type_data_t"><code class="flex name class">
<span>class <span class="ident">func_type_data_t</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ func_type_data_t class.</div>
<div class="epy_par">
<strong class="epy_sig">__init__(self) -&gt; func_type_data_t</strong></div></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="ida_typeinf.funcargvec_t" href="#ida_typeinf.funcargvec_t">funcargvec_t</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="ida_typeinf.func_type_data_t.cc"><code class="name">var <span class="ident">cc</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">func_type_data_t_cc_get(self) -&gt; cm_t</strong></div></div>
</dd>
<dt id="ida_typeinf.func_type_data_t.flags"><code class="name">var <span class="ident">flags</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">func_type_data_t_flags_get(self) -&gt; int</strong></div></div>
</dd>
<dt id="ida_typeinf.func_type_data_t.retloc"><code class="name">var <span class="ident">retloc</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">func_type_data_t_retloc_get(self) -&gt; argloc_t</strong></div></div>
</dd>
<dt id="ida_typeinf.func_type_data_t.rettype"><code class="name">var <span class="ident">rettype</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">func_type_data_t_rettype_get(self) -&gt; tinfo_t</strong></div></div>
</dd>
<dt id="ida_typeinf.func_type_data_t.spoiled"><code class="name">var <span class="ident">spoiled</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">func_type_data_t_spoiled_get(self) -&gt; reginfovec_t</strong></div></div>
</dd>
<dt id="ida_typeinf.func_type_data_t.stkargs"><code class="name">var <span class="ident">stkargs</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">func_type_data_t_stkargs_get(self) -&gt; uval_t</strong></div></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ida_typeinf.func_type_data_t.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Dump information that is not always visible in the function prototype.
(argument locations, return location, total stkarg size)</div>
<div class="epy_par">
<strong class="epy_sig">dump(self, praloc_bits=0x02) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">praloc_bits</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_typeinf.func_type_data_t.get_call_method"><code class="name flex">
<span>def <span class="ident">get_call_method</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">get_call_method(self) -&gt; int</strong></div></div>
</dd>
<dt id="ida_typeinf.func_type_data_t.guess_cc"><code class="name flex">
<span>def <span class="ident">guess_cc</span></span>(<span>self, *args) &#8209;&gt;&#160;cm_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Guess function calling convention use the following info: argument
locations and 'stkargs'</div>
<div class="epy_par">
<strong class="epy_sig">guess_cc(self, purged, cc_flags) -&gt; cm_t</strong><div class="epy_nested">
<strong class="epy_parameter">purged</strong> (C++: int)</div>
<div class="epy_nested">
<strong class="epy_parameter">cc_flags</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_typeinf.func_type_data_t.is_golang_cc"><code class="name flex">
<span>def <span class="ident">is_golang_cc</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">is_golang_cc(self) -&gt; bool</strong></div></div>
</dd>
<dt id="ida_typeinf.func_type_data_t.is_high"><code class="name flex">
<span>def <span class="ident">is_high</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">is_high(self) -&gt; bool</strong></div></div>
</dd>
<dt id="ida_typeinf.func_type_data_t.is_noret"><code class="name flex">
<span>def <span class="ident">is_noret</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">is_noret(self) -&gt; bool</strong></div></div>
</dd>
<dt id="ida_typeinf.func_type_data_t.is_pure"><code class="name flex">
<span>def <span class="ident">is_pure</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">is_pure(self) -&gt; bool</strong></div></div>
</dd>
<dt id="ida_typeinf.func_type_data_t.is_vararg_cc"><code class="name flex">
<span>def <span class="ident">is_vararg_cc</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">is_vararg_cc(self) -&gt; bool</strong></div></div>
</dd>
<dt id="ida_typeinf.func_type_data_t.swap"><code class="name flex">
<span>def <span class="ident">swap</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">swap(self, r)</strong><div class="epy_nested">
<strong class="epy_parameter">r</strong> (C++: func_type_data_t
&amp;)</div>
</div></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="ida_typeinf.funcargvec_t" href="#ida_typeinf.funcargvec_t">funcargvec_t</a></b></code>:
<ul class="hlist">
<li><code><a title="ida_typeinf.funcargvec_t.add_unique" href="#ida_typeinf.funcargvec_t.add_unique">add_unique</a></code></li>
<li><code><a title="ida_typeinf.funcargvec_t.at" href="#ida_typeinf.funcargvec_t.at">at</a></code></li>
<li><code><a title="ida_typeinf.funcargvec_t.begin" href="#ida_typeinf.funcargvec_t.begin">begin</a></code></li>
<li><code><a title="ida_typeinf.funcargvec_t.capacity" href="#ida_typeinf.funcargvec_t.capacity">capacity</a></code></li>
<li><code><a title="ida_typeinf.funcargvec_t.clear" href="#ida_typeinf.funcargvec_t.clear">clear</a></code></li>
<li><code><a title="ida_typeinf.funcargvec_t.empty" href="#ida_typeinf.funcargvec_t.empty">empty</a></code></li>
<li><code><a title="ida_typeinf.funcargvec_t.end" href="#ida_typeinf.funcargvec_t.end">end</a></code></li>
<li><code><a title="ida_typeinf.funcargvec_t.erase" href="#ida_typeinf.funcargvec_t.erase">erase</a></code></li>
<li><code><a title="ida_typeinf.funcargvec_t.extract" href="#ida_typeinf.funcargvec_t.extract">extract</a></code></li>
<li><code><a title="ida_typeinf.funcargvec_t.find" href="#ida_typeinf.funcargvec_t.find">find</a></code></li>
<li><code><a title="ida_typeinf.funcargvec_t.grow" href="#ida_typeinf.funcargvec_t.grow">grow</a></code></li>
<li><code><a title="ida_typeinf.funcargvec_t.has" href="#ida_typeinf.funcargvec_t.has">has</a></code></li>
<li><code><a title="ida_typeinf.funcargvec_t.inject" href="#ida_typeinf.funcargvec_t.inject">inject</a></code></li>
<li><code><a title="ida_typeinf.funcargvec_t.insert" href="#ida_typeinf.funcargvec_t.insert">insert</a></code></li>
<li><code><a title="ida_typeinf.funcargvec_t.pop_back" href="#ida_typeinf.funcargvec_t.pop_back">pop_back</a></code></li>
<li><code><a title="ida_typeinf.funcargvec_t.push_back" href="#ida_typeinf.funcargvec_t.push_back">push_back</a></code></li>
<li><code><a title="ida_typeinf.funcargvec_t.qclear" href="#ida_typeinf.funcargvec_t.qclear">qclear</a></code></li>
<li><code><a title="ida_typeinf.funcargvec_t.reserve" href="#ida_typeinf.funcargvec_t.reserve">reserve</a></code></li>
<li><code><a title="ida_typeinf.funcargvec_t.resize" href="#ida_typeinf.funcargvec_t.resize">resize</a></code></li>
<li><code><a title="ida_typeinf.funcargvec_t.size" href="#ida_typeinf.funcargvec_t.size">size</a></code></li>
<li><code><a title="ida_typeinf.funcargvec_t.truncate" href="#ida_typeinf.funcargvec_t.truncate">truncate</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="ida_typeinf.funcarg_t"><code class="flex name class">
<span>class <span class="ident">funcarg_t</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ funcarg_t class.</div>
<div class="epy_par">
<strong class="epy_sig">__init__(self) -&gt; funcarg_t</strong></div></div>
<h3>Instance variables</h3>
<dl>
<dt id="ida_typeinf.funcarg_t.argloc"><code class="name">var <span class="ident">argloc</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">funcarg_t_argloc_get(self) -&gt; argloc_t</strong></div></div>
</dd>
<dt id="ida_typeinf.funcarg_t.cmt"><code class="name">var <span class="ident">cmt</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">funcarg_t_cmt_get(self) -&gt; qstring *</strong></div></div>
</dd>
<dt id="ida_typeinf.funcarg_t.flags"><code class="name">var <span class="ident">flags</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">funcarg_t_flags_get(self) -&gt; uint32</strong></div></div>
</dd>
<dt id="ida_typeinf.funcarg_t.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">funcarg_t_name_get(self) -&gt; qstring *</strong></div></div>
</dd>
<dt id="ida_typeinf.funcarg_t.type"><code class="name">var <span class="ident">type</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">funcarg_t_type_get(self) -&gt; tinfo_t</strong></div></div>
</dd>
</dl>
</dd>
<dt id="ida_typeinf.funcargvec_t"><code class="flex name class">
<span>class <span class="ident">funcargvec_t</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ qvector&lt; funcarg_t &gt; class.</div>
<div class="epy_par">
<strong class="epy_sig">__init__(self) -&gt; funcargvec_t</strong><div class="epy_nested">
x: qvector&lt; funcarg_t &gt; const &amp;</div>
</div></div>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="ida_typeinf.func_type_data_t" href="#ida_typeinf.func_type_data_t">func_type_data_t</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="ida_typeinf.funcargvec_t.add_unique"><code class="name flex">
<span>def <span class="ident">add_unique</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">add_unique(self, x) -&gt; bool</strong><div class="epy_nested">
x: funcarg_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_typeinf.funcargvec_t.at"><code class="name flex">
<span>def <span class="ident">at</span></span>(<span>self, *args) &#8209;&gt;&#160;<a title="ida_typeinf.funcarg_t" href="#ida_typeinf.funcarg_t">funcarg_t</a>&#160;const&#160;&amp;</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">at(self, _idx) -&gt; funcarg_t</strong><div class="epy_nested">
_idx: size_t</div>
</div></div>
</dd>
<dt id="ida_typeinf.funcargvec_t.back"><code class="name flex">
<span>def <span class="ident">back</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"/>
</dd>
<dt id="ida_typeinf.funcargvec_t.begin"><code class="name flex">
<span>def <span class="ident">begin</span></span>(<span>self, *args) &#8209;&gt;&#160;qvectorfuncarg_t&#160;&gt;::const_iterator</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">begin(self) -&gt; funcarg_t</strong></div>
<div class="epy_par">
<strong class="epy_sig">begin(self) -&gt; funcarg_t</strong></div></div>
</dd>
<dt id="ida_typeinf.funcargvec_t.capacity"><code class="name flex">
<span>def <span class="ident">capacity</span></span>(<span>self, *args) &#8209;&gt;&#160;size_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">capacity(self) -&gt; size_t</strong></div></div>
</dd>
<dt id="ida_typeinf.funcargvec_t.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">clear(self)</strong></div></div>
</dd>
<dt id="ida_typeinf.funcargvec_t.empty"><code class="name flex">
<span>def <span class="ident">empty</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">empty(self) -&gt; bool</strong></div></div>
</dd>
<dt id="ida_typeinf.funcargvec_t.end"><code class="name flex">
<span>def <span class="ident">end</span></span>(<span>self, *args) &#8209;&gt;&#160;qvectorfuncarg_t&#160;&gt;::const_iterator</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">end(self) -&gt; funcarg_t</strong></div>
<div class="epy_par">
<strong class="epy_sig">end(self) -&gt; funcarg_t</strong></div></div>
</dd>
<dt id="ida_typeinf.funcargvec_t.erase"><code class="name flex">
<span>def <span class="ident">erase</span></span>(<span>self, *args) &#8209;&gt;&#160;qvectorfuncarg_t&#160;&gt;::iterator</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">erase(self, it) -&gt; funcarg_t</strong><div class="epy_nested">
it: qvector&lt; funcarg_t &gt;::iterator</div>
</div>
<div class="epy_par">
<strong class="epy_sig">erase(self, first, last) -&gt; funcarg_t</strong><div class="epy_nested">
first: qvector&lt; funcarg_t &gt;::iterator
last: qvector&lt; funcarg_t &gt;::iterator</div>
</div></div>
</dd>
<dt id="ida_typeinf.funcargvec_t.extract"><code class="name flex">
<span>def <span class="ident">extract</span></span>(<span>self, *args) &#8209;&gt;&#160;<a title="ida_typeinf.funcarg_t" href="#ida_typeinf.funcarg_t">funcarg_t</a>&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">extract(self) -&gt; funcarg_t</strong></div></div>
</dd>
<dt id="ida_typeinf.funcargvec_t.find"><code class="name flex">
<span>def <span class="ident">find</span></span>(<span>self, *args) &#8209;&gt;&#160;qvectorfuncarg_t&#160;&gt;::const_iterator</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">find(self, x) -&gt; funcarg_t</strong><div class="epy_nested">
x: funcarg_t const &amp;</div>
</div>
<div class="epy_par">
<strong class="epy_sig">find(self, x) -&gt; funcarg_t</strong><div class="epy_nested">
x: funcarg_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_typeinf.funcargvec_t.front"><code class="name flex">
<span>def <span class="ident">front</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"/>
</dd>
<dt id="ida_typeinf.funcargvec_t.grow"><code class="name flex">
<span>def <span class="ident">grow</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
grow(self, x=funcarg_t())<div class="epy_nested">
x: funcarg_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_typeinf.funcargvec_t.has"><code class="name flex">
<span>def <span class="ident">has</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">has(self, x) -&gt; bool</strong><div class="epy_nested">
x: funcarg_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_typeinf.funcargvec_t.inject"><code class="name flex">
<span>def <span class="ident">inject</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">inject(self, s, len)</strong><div class="epy_nested">
s: funcarg_t *
len: size_t</div>
</div></div>
</dd>
<dt id="ida_typeinf.funcargvec_t.insert"><code class="name flex">
<span>def <span class="ident">insert</span></span>(<span>self, *args) &#8209;&gt;&#160;qvectorfuncarg_t&#160;&gt;::iterator</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">insert(self, it, x) -&gt; funcarg_t</strong><div class="epy_nested">
it: qvector&lt; funcarg_t &gt;::iterator
x: funcarg_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_typeinf.funcargvec_t.pop_back"><code class="name flex">
<span>def <span class="ident">pop_back</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">pop_back(self)</strong></div></div>
</dd>
<dt id="ida_typeinf.funcargvec_t.push_back"><code class="name flex">
<span>def <span class="ident">push_back</span></span>(<span>self, *args) &#8209;&gt;&#160;<a title="ida_typeinf.funcarg_t" href="#ida_typeinf.funcarg_t">funcarg_t</a>&#160;&amp;</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">push_back(self, x)</strong><div class="epy_nested">
x: funcarg_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_typeinf.funcargvec_t.qclear"><code class="name flex">
<span>def <span class="ident">qclear</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">qclear(self)</strong></div></div>
</dd>
<dt id="ida_typeinf.funcargvec_t.reserve"><code class="name flex">
<span>def <span class="ident">reserve</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">reserve(self, cnt)</strong><div class="epy_nested">
cnt: size_t</div>
</div></div>
</dd>
<dt id="ida_typeinf.funcargvec_t.resize"><code class="name flex">
<span>def <span class="ident">resize</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">resize(self, _newsize, x)</strong><div class="epy_nested">
_newsize: size_t
x: funcarg_t const &amp;</div>
</div>
<div class="epy_par">
<strong class="epy_sig">resize(self, _newsize)</strong><div class="epy_nested">
_newsize: size_t</div>
</div></div>
</dd>
<dt id="ida_typeinf.funcargvec_t.size"><code class="name flex">
<span>def <span class="ident">size</span></span>(<span>self, *args) &#8209;&gt;&#160;size_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">size(self) -&gt; size_t</strong></div></div>
</dd>
<dt id="ida_typeinf.funcargvec_t.swap"><code class="name flex">
<span>def <span class="ident">swap</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">swap(self, r)</strong><div class="epy_nested">
r: qvector&lt; funcarg_t &gt; &amp;</div>
</div></div>
</dd>
<dt id="ida_typeinf.funcargvec_t.truncate"><code class="name flex">
<span>def <span class="ident">truncate</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">truncate(self)</strong></div></div>
</dd>
</dl>
</dd>
<dt id="ida_typeinf.ida_lowertype_helper_t"><code class="flex name class">
<span>class <span class="ident">ida_lowertype_helper_t</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ ida_lowertype_helper_t class.</div>
<div class="epy_par">
<strong class="epy_sig">__init__(self, _tif, _ea, _pb) -&gt; ida_lowertype_helper_t</strong><div class="epy_nested">
_tif: tinfo_t const &amp;
_ea: ea_t
_pb: int</div>
</div></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="ida_typeinf.lowertype_helper_t" href="#ida_typeinf.lowertype_helper_t">lowertype_helper_t</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="ida_typeinf.ida_lowertype_helper_t.get_func_purged_bytes"><code class="name flex">
<span>def <span class="ident">get_func_purged_bytes</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">get_func_purged_bytes(self, candidate, arg3) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">candidate</strong> (C++: const
tinfo_t
&amp;)
arg3: func_type_data_t const &amp;</div>
</div></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="ida_typeinf.lowertype_helper_t" href="#ida_typeinf.lowertype_helper_t">lowertype_helper_t</a></b></code>:
<ul class="hlist">
<li><code><a title="ida_typeinf.lowertype_helper_t.func_has_stkframe_hole" href="#ida_typeinf.lowertype_helper_t.func_has_stkframe_hole">func_has_stkframe_hole</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="ida_typeinf.lowertype_helper_t"><code class="flex name class">
<span>class <span class="ident">lowertype_helper_t</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ lowertype_helper_t class.</div></div>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="ida_typeinf.ida_lowertype_helper_t" href="#ida_typeinf.ida_lowertype_helper_t">ida_lowertype_helper_t</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="ida_typeinf.lowertype_helper_t.func_has_stkframe_hole"><code class="name flex">
<span>def <span class="ident">func_has_stkframe_hole</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">func_has_stkframe_hole(self, candidate, candidate_data) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">candidate</strong> (C++: const
tinfo_t
&amp;)</div>
<div class="epy_nested">
<strong class="epy_parameter">candidate_data</strong> (C++: const
func_type_data_t
&amp;)</div>
</div></div>
</dd>
<dt id="ida_typeinf.lowertype_helper_t.get_func_purged_bytes"><code class="name flex">
<span>def <span class="ident">get_func_purged_bytes</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">get_func_purged_bytes(self, candidate, candidate_data) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">candidate</strong> (C++: const
tinfo_t
&amp;)</div>
<div class="epy_nested">
<strong class="epy_parameter">candidate_data</strong> (C++: const
func_type_data_t
&amp;)</div>
</div></div>
</dd>
</dl>
</dd>
<dt id="ida_typeinf.predicate_t"><code class="flex name class">
<span>class <span class="ident">predicate_t</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ predicate_t class.</div>
<div class="epy_par">
<strong class="epy_sig">__init__(self) -&gt; predicate_t</strong><div class="epy_nested">
self: PyObject *</div>
</div></div>
<h3>Methods</h3>
<dl>
<dt id="ida_typeinf.predicate_t.should_display"><code class="name flex">
<span>def <span class="ident">should_display</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">should_display(self, til, name, type, fields) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">til</strong> (C++: const
til_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">name</strong> (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">type</strong> (C++: const
type_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">fields</strong> (C++: const
p_list
*)</div>
</div></div>
</dd>
</dl>
</dd>
<dt id="ida_typeinf.ptr_type_data_t"><code class="flex name class">
<span>class <span class="ident">ptr_type_data_t</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ ptr_type_data_t class.</div>
<div class="epy_par">
__init__(self, c=tinfo_t(), bps=0, p=tinfo_t(), d=0) -&gt; ptr_type_data_t<div class="epy_nested">
c: tinfo_t
bps: uchar
p: tinfo_t
d: int32</div>
</div></div>
<h3>Instance variables</h3>
<dl>
<dt id="ida_typeinf.ptr_type_data_t.based_ptr_size"><code class="name">var <span class="ident">based_ptr_size</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">ptr_type_data_t_based_ptr_size_get(self) -&gt; uchar</strong></div></div>
</dd>
<dt id="ida_typeinf.ptr_type_data_t.closure"><code class="name">var <span class="ident">closure</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">ptr_type_data_t_closure_get(self) -&gt; tinfo_t</strong></div></div>
</dd>
<dt id="ida_typeinf.ptr_type_data_t.delta"><code class="name">var <span class="ident">delta</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">ptr_type_data_t_delta_get(self) -&gt; int32</strong></div></div>
</dd>
<dt id="ida_typeinf.ptr_type_data_t.obj_type"><code class="name">var <span class="ident">obj_type</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">ptr_type_data_t_obj_type_get(self) -&gt; tinfo_t</strong></div></div>
</dd>
<dt id="ida_typeinf.ptr_type_data_t.parent"><code class="name">var <span class="ident">parent</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">ptr_type_data_t_parent_get(self) -&gt; tinfo_t</strong></div></div>
</dd>
<dt id="ida_typeinf.ptr_type_data_t.taptr_bits"><code class="name">var <span class="ident">taptr_bits</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">ptr_type_data_t_taptr_bits_get(self) -&gt; uchar</strong></div></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ida_typeinf.ptr_type_data_t.is_code_ptr"><code class="name flex">
<span>def <span class="ident">is_code_ptr</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Are we pointing to code?</div></div>
</dd>
<dt id="ida_typeinf.ptr_type_data_t.is_shifted"><code class="name flex">
<span>def <span class="ident">is_shifted</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">is_shifted(self) -&gt; bool</strong></div></div>
</dd>
<dt id="ida_typeinf.ptr_type_data_t.swap"><code class="name flex">
<span>def <span class="ident">swap</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Set this = r and r = this.</div>
<div class="epy_par">
<strong class="epy_sig">swap(self, r)</strong><div class="epy_nested">
<strong class="epy_parameter">r</strong> (C++: ptr_type_data_t
&amp;)</div>
</div></div>
</dd>
</dl>
</dd>
<dt id="ida_typeinf.reginfovec_t"><code class="flex name class">
<span>class <span class="ident">reginfovec_t</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ qvector&lt; reg_info_t &gt; class.</div>
<div class="epy_par">
<strong class="epy_sig">__init__(self) -&gt; reginfovec_t</strong><div class="epy_nested">
x: qvector&lt; reg_info_t &gt; const &amp;</div>
</div></div>
<h3>Methods</h3>
<dl>
<dt id="ida_typeinf.reginfovec_t.add_unique"><code class="name flex">
<span>def <span class="ident">add_unique</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">add_unique(self, x) -&gt; bool</strong><div class="epy_nested">
x: reg_info_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_typeinf.reginfovec_t.append"><code class="name flex">
<span>def <span class="ident">append</span></span>(<span>self, *args) &#8209;&gt;&#160;reg_info_t&#160;&amp;</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">push_back(self, x)</strong><div class="epy_nested">
x: reg_info_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_typeinf.reginfovec_t.at"><code class="name flex">
<span>def <span class="ident">at</span></span>(<span>self, *args) &#8209;&gt;&#160;reg_info_t&#160;const&#160;&amp;</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">__getitem__(self, i) -&gt; reg_info_t</strong><div class="epy_nested">
i: size_t</div>
</div></div>
</dd>
<dt id="ida_typeinf.reginfovec_t.back"><code class="name flex">
<span>def <span class="ident">back</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"/>
</dd>
<dt id="ida_typeinf.reginfovec_t.begin"><code class="name flex">
<span>def <span class="ident">begin</span></span>(<span>self, *args) &#8209;&gt;&#160;qvector::const_iterator</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">begin(self) -&gt; reg_info_t</strong></div>
<div class="epy_par">
<strong class="epy_sig">begin(self) -&gt; reg_info_t</strong></div></div>
</dd>
<dt id="ida_typeinf.reginfovec_t.capacity"><code class="name flex">
<span>def <span class="ident">capacity</span></span>(<span>self, *args) &#8209;&gt;&#160;size_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">capacity(self) -&gt; size_t</strong></div></div>
</dd>
<dt id="ida_typeinf.reginfovec_t.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">clear(self)</strong></div></div>
</dd>
<dt id="ida_typeinf.reginfovec_t.empty"><code class="name flex">
<span>def <span class="ident">empty</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">empty(self) -&gt; bool</strong></div></div>
</dd>
<dt id="ida_typeinf.reginfovec_t.end"><code class="name flex">
<span>def <span class="ident">end</span></span>(<span>self, *args) &#8209;&gt;&#160;qvector::const_iterator</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">end(self) -&gt; reg_info_t</strong></div>
<div class="epy_par">
<strong class="epy_sig">end(self) -&gt; reg_info_t</strong></div></div>
</dd>
<dt id="ida_typeinf.reginfovec_t.erase"><code class="name flex">
<span>def <span class="ident">erase</span></span>(<span>self, *args) &#8209;&gt;&#160;qvector::iterator</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">erase(self, it) -&gt; reg_info_t</strong><div class="epy_nested">
it: qvector&lt; reg_info_t &gt;::iterator</div>
</div>
<div class="epy_par">
<strong class="epy_sig">erase(self, first, last) -&gt; reg_info_t</strong><div class="epy_nested">
first: qvector&lt; reg_info_t &gt;::iterator
last: qvector&lt; reg_info_t &gt;::iterator</div>
</div></div>
</dd>
<dt id="ida_typeinf.reginfovec_t.extract"><code class="name flex">
<span>def <span class="ident">extract</span></span>(<span>self, *args) &#8209;&gt;&#160;reg_info_t&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">extract(self) -&gt; reg_info_t</strong></div></div>
</dd>
<dt id="ida_typeinf.reginfovec_t.find"><code class="name flex">
<span>def <span class="ident">find</span></span>(<span>self, *args) &#8209;&gt;&#160;qvector::const_iterator</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">find(self, x) -&gt; reg_info_t</strong><div class="epy_nested">
x: reg_info_t const &amp;</div>
</div>
<div class="epy_par">
<strong class="epy_sig">find(self, x) -&gt; reg_info_t</strong><div class="epy_nested">
x: reg_info_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_typeinf.reginfovec_t.front"><code class="name flex">
<span>def <span class="ident">front</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"/>
</dd>
<dt id="ida_typeinf.reginfovec_t.grow"><code class="name flex">
<span>def <span class="ident">grow</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
grow(self, x=reg_info_t())<div class="epy_nested">
x: reg_info_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_typeinf.reginfovec_t.has"><code class="name flex">
<span>def <span class="ident">has</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">has(self, x) -&gt; bool</strong><div class="epy_nested">
x: reg_info_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_typeinf.reginfovec_t.inject"><code class="name flex">
<span>def <span class="ident">inject</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">inject(self, s, len)</strong><div class="epy_nested">
s: reg_info_t *
len: size_t</div>
</div></div>
</dd>
<dt id="ida_typeinf.reginfovec_t.insert"><code class="name flex">
<span>def <span class="ident">insert</span></span>(<span>self, *args) &#8209;&gt;&#160;qvector::iterator</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">insert(self, it, x) -&gt; reg_info_t</strong><div class="epy_nested">
it: qvector&lt; reg_info_t &gt;::iterator
x: reg_info_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_typeinf.reginfovec_t.pop_back"><code class="name flex">
<span>def <span class="ident">pop_back</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">pop_back(self)</strong></div></div>
</dd>
<dt id="ida_typeinf.reginfovec_t.push_back"><code class="name flex">
<span>def <span class="ident">push_back</span></span>(<span>self, *args) &#8209;&gt;&#160;reg_info_t&#160;&amp;</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">push_back(self, x)</strong><div class="epy_nested">
x: reg_info_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_typeinf.reginfovec_t.qclear"><code class="name flex">
<span>def <span class="ident">qclear</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">qclear(self)</strong></div></div>
</dd>
<dt id="ida_typeinf.reginfovec_t.reserve"><code class="name flex">
<span>def <span class="ident">reserve</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">reserve(self, cnt)</strong><div class="epy_nested">
cnt: size_t</div>
</div></div>
</dd>
<dt id="ida_typeinf.reginfovec_t.resize"><code class="name flex">
<span>def <span class="ident">resize</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">resize(self, _newsize, x)</strong><div class="epy_nested">
_newsize: size_t
x: reg_info_t const &amp;</div>
</div>
<div class="epy_par">
<strong class="epy_sig">resize(self, _newsize)</strong><div class="epy_nested">
_newsize: size_t</div>
</div></div>
</dd>
<dt id="ida_typeinf.reginfovec_t.size"><code class="name flex">
<span>def <span class="ident">size</span></span>(<span>self, *args) &#8209;&gt;&#160;size_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">size(self) -&gt; size_t</strong></div></div>
</dd>
<dt id="ida_typeinf.reginfovec_t.swap"><code class="name flex">
<span>def <span class="ident">swap</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">swap(self, r)</strong><div class="epy_nested">
r: qvector&lt; reg_info_t &gt; &amp;</div>
</div></div>
</dd>
<dt id="ida_typeinf.reginfovec_t.truncate"><code class="name flex">
<span>def <span class="ident">truncate</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">truncate(self)</strong></div></div>
</dd>
</dl>
</dd>
<dt id="ida_typeinf.regobj_t"><code class="flex name class">
<span>class <span class="ident">regobj_t</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ regobj_t class.</div>
<div class="epy_par">
<strong class="epy_sig">__init__(self) -&gt; regobj_t</strong></div></div>
<h3>Instance variables</h3>
<dl>
<dt id="ida_typeinf.regobj_t.regidx"><code class="name">var <span class="ident">regidx</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">regobj_t_regidx_get(self) -&gt; int</strong></div></div>
</dd>
<dt id="ida_typeinf.regobj_t.relocate"><code class="name">var <span class="ident">relocate</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">regobj_t_relocate_get(self) -&gt; int</strong></div></div>
</dd>
<dt id="ida_typeinf.regobj_t.value"><code class="name">var <span class="ident">value</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">regobj_t_value_get(self) -&gt; bytevec_t *</strong></div></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ida_typeinf.regobj_t.size"><code class="name flex">
<span>def <span class="ident">size</span></span>(<span>self, *args) &#8209;&gt;&#160;size_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">size(self) -&gt; size_t</strong></div></div>
</dd>
</dl>
</dd>
<dt id="ida_typeinf.regobjs_t"><code class="flex name class">
<span>class <span class="ident">regobjs_t</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ regobjs_t class.</div>
<div class="epy_par">
<strong class="epy_sig">__init__(self) -&gt; regobjs_t</strong></div></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="ida_typeinf.regobjvec_t" href="#ida_typeinf.regobjvec_t">regobjvec_t</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="ida_typeinf.regobjvec_t" href="#ida_typeinf.regobjvec_t">regobjvec_t</a></b></code>:
<ul class="hlist">
<li><code><a title="ida_typeinf.regobjvec_t.at" href="#ida_typeinf.regobjvec_t.at">at</a></code></li>
<li><code><a title="ida_typeinf.regobjvec_t.begin" href="#ida_typeinf.regobjvec_t.begin">begin</a></code></li>
<li><code><a title="ida_typeinf.regobjvec_t.capacity" href="#ida_typeinf.regobjvec_t.capacity">capacity</a></code></li>
<li><code><a title="ida_typeinf.regobjvec_t.clear" href="#ida_typeinf.regobjvec_t.clear">clear</a></code></li>
<li><code><a title="ida_typeinf.regobjvec_t.empty" href="#ida_typeinf.regobjvec_t.empty">empty</a></code></li>
<li><code><a title="ida_typeinf.regobjvec_t.end" href="#ida_typeinf.regobjvec_t.end">end</a></code></li>
<li><code><a title="ida_typeinf.regobjvec_t.erase" href="#ida_typeinf.regobjvec_t.erase">erase</a></code></li>
<li><code><a title="ida_typeinf.regobjvec_t.extract" href="#ida_typeinf.regobjvec_t.extract">extract</a></code></li>
<li><code><a title="ida_typeinf.regobjvec_t.grow" href="#ida_typeinf.regobjvec_t.grow">grow</a></code></li>
<li><code><a title="ida_typeinf.regobjvec_t.inject" href="#ida_typeinf.regobjvec_t.inject">inject</a></code></li>
<li><code><a title="ida_typeinf.regobjvec_t.insert" href="#ida_typeinf.regobjvec_t.insert">insert</a></code></li>
<li><code><a title="ida_typeinf.regobjvec_t.pop_back" href="#ida_typeinf.regobjvec_t.pop_back">pop_back</a></code></li>
<li><code><a title="ida_typeinf.regobjvec_t.push_back" href="#ida_typeinf.regobjvec_t.push_back">push_back</a></code></li>
<li><code><a title="ida_typeinf.regobjvec_t.qclear" href="#ida_typeinf.regobjvec_t.qclear">qclear</a></code></li>
<li><code><a title="ida_typeinf.regobjvec_t.reserve" href="#ida_typeinf.regobjvec_t.reserve">reserve</a></code></li>
<li><code><a title="ida_typeinf.regobjvec_t.resize" href="#ida_typeinf.regobjvec_t.resize">resize</a></code></li>
<li><code><a title="ida_typeinf.regobjvec_t.size" href="#ida_typeinf.regobjvec_t.size">size</a></code></li>
<li><code><a title="ida_typeinf.regobjvec_t.swap" href="#ida_typeinf.regobjvec_t.swap">swap</a></code></li>
<li><code><a title="ida_typeinf.regobjvec_t.truncate" href="#ida_typeinf.regobjvec_t.truncate">truncate</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="ida_typeinf.regobjvec_t"><code class="flex name class">
<span>class <span class="ident">regobjvec_t</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ qvector&lt; regobj_t &gt; class.</div>
<div class="epy_par">
<strong class="epy_sig">__init__(self) -&gt; regobjvec_t</strong><div class="epy_nested">
x: qvector&lt; regobj_t &gt; const &amp;</div>
</div></div>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="ida_typeinf.regobjs_t" href="#ida_typeinf.regobjs_t">regobjs_t</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="ida_typeinf.regobjvec_t.at"><code class="name flex">
<span>def <span class="ident">at</span></span>(<span>self, *args) &#8209;&gt;&#160;<a title="ida_typeinf.regobj_t" href="#ida_typeinf.regobj_t">regobj_t</a>&#160;const&#160;&amp;</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">at(self, _idx) -&gt; regobj_t</strong><div class="epy_nested">
_idx: size_t</div>
</div></div>
</dd>
<dt id="ida_typeinf.regobjvec_t.back"><code class="name flex">
<span>def <span class="ident">back</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"/>
</dd>
<dt id="ida_typeinf.regobjvec_t.begin"><code class="name flex">
<span>def <span class="ident">begin</span></span>(<span>self, *args) &#8209;&gt;&#160;qvectorregobj_t&#160;&gt;::const_iterator</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">begin(self) -&gt; regobj_t</strong></div>
<div class="epy_par">
<strong class="epy_sig">begin(self) -&gt; regobj_t</strong></div></div>
</dd>
<dt id="ida_typeinf.regobjvec_t.capacity"><code class="name flex">
<span>def <span class="ident">capacity</span></span>(<span>self, *args) &#8209;&gt;&#160;size_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">capacity(self) -&gt; size_t</strong></div></div>
</dd>
<dt id="ida_typeinf.regobjvec_t.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">clear(self)</strong></div></div>
</dd>
<dt id="ida_typeinf.regobjvec_t.empty"><code class="name flex">
<span>def <span class="ident">empty</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">empty(self) -&gt; bool</strong></div></div>
</dd>
<dt id="ida_typeinf.regobjvec_t.end"><code class="name flex">
<span>def <span class="ident">end</span></span>(<span>self, *args) &#8209;&gt;&#160;qvectorregobj_t&#160;&gt;::const_iterator</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">end(self) -&gt; regobj_t</strong></div>
<div class="epy_par">
<strong class="epy_sig">end(self) -&gt; regobj_t</strong></div></div>
</dd>
<dt id="ida_typeinf.regobjvec_t.erase"><code class="name flex">
<span>def <span class="ident">erase</span></span>(<span>self, *args) &#8209;&gt;&#160;qvectorregobj_t&#160;&gt;::iterator</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">erase(self, it) -&gt; regobj_t</strong><div class="epy_nested">
it: qvector&lt; regobj_t &gt;::iterator</div>
</div>
<div class="epy_par">
<strong class="epy_sig">erase(self, first, last) -&gt; regobj_t</strong><div class="epy_nested">
first: qvector&lt; regobj_t &gt;::iterator
last: qvector&lt; regobj_t &gt;::iterator</div>
</div></div>
</dd>
<dt id="ida_typeinf.regobjvec_t.extract"><code class="name flex">
<span>def <span class="ident">extract</span></span>(<span>self, *args) &#8209;&gt;&#160;<a title="ida_typeinf.regobj_t" href="#ida_typeinf.regobj_t">regobj_t</a>&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">extract(self) -&gt; regobj_t</strong></div></div>
</dd>
<dt id="ida_typeinf.regobjvec_t.front"><code class="name flex">
<span>def <span class="ident">front</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"/>
</dd>
<dt id="ida_typeinf.regobjvec_t.grow"><code class="name flex">
<span>def <span class="ident">grow</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
grow(self, x=regobj_t())<div class="epy_nested">
x: regobj_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_typeinf.regobjvec_t.inject"><code class="name flex">
<span>def <span class="ident">inject</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">inject(self, s, len)</strong><div class="epy_nested">
s: regobj_t *
len: size_t</div>
</div></div>
</dd>
<dt id="ida_typeinf.regobjvec_t.insert"><code class="name flex">
<span>def <span class="ident">insert</span></span>(<span>self, *args) &#8209;&gt;&#160;qvectorregobj_t&#160;&gt;::iterator</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">insert(self, it, x) -&gt; regobj_t</strong><div class="epy_nested">
it: qvector&lt; regobj_t &gt;::iterator
x: regobj_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_typeinf.regobjvec_t.pop_back"><code class="name flex">
<span>def <span class="ident">pop_back</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">pop_back(self)</strong></div></div>
</dd>
<dt id="ida_typeinf.regobjvec_t.push_back"><code class="name flex">
<span>def <span class="ident">push_back</span></span>(<span>self, *args) &#8209;&gt;&#160;<a title="ida_typeinf.regobj_t" href="#ida_typeinf.regobj_t">regobj_t</a>&#160;&amp;</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">push_back(self, x)</strong><div class="epy_nested">
x: regobj_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_typeinf.regobjvec_t.qclear"><code class="name flex">
<span>def <span class="ident">qclear</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">qclear(self)</strong></div></div>
</dd>
<dt id="ida_typeinf.regobjvec_t.reserve"><code class="name flex">
<span>def <span class="ident">reserve</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">reserve(self, cnt)</strong><div class="epy_nested">
cnt: size_t</div>
</div></div>
</dd>
<dt id="ida_typeinf.regobjvec_t.resize"><code class="name flex">
<span>def <span class="ident">resize</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">resize(self, _newsize, x)</strong><div class="epy_nested">
_newsize: size_t
x: regobj_t const &amp;</div>
</div>
<div class="epy_par">
<strong class="epy_sig">resize(self, _newsize)</strong><div class="epy_nested">
_newsize: size_t</div>
</div></div>
</dd>
<dt id="ida_typeinf.regobjvec_t.size"><code class="name flex">
<span>def <span class="ident">size</span></span>(<span>self, *args) &#8209;&gt;&#160;size_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">size(self) -&gt; size_t</strong></div></div>
</dd>
<dt id="ida_typeinf.regobjvec_t.swap"><code class="name flex">
<span>def <span class="ident">swap</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">swap(self, r)</strong><div class="epy_nested">
r: qvector&lt; regobj_t &gt; &amp;</div>
</div></div>
</dd>
<dt id="ida_typeinf.regobjvec_t.truncate"><code class="name flex">
<span>def <span class="ident">truncate</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">truncate(self)</strong></div></div>
</dd>
</dl>
</dd>
<dt id="ida_typeinf.rrel_t"><code class="flex name class">
<span>class <span class="ident">rrel_t</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ rrel_t class.</div>
<div class="epy_par">
<strong class="epy_sig">__init__(self) -&gt; rrel_t</strong></div></div>
<h3>Instance variables</h3>
<dl>
<dt id="ida_typeinf.rrel_t.off"><code class="name">var <span class="ident">off</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">rrel_t_off_get(self) -&gt; sval_t</strong></div></div>
</dd>
<dt id="ida_typeinf.rrel_t.reg"><code class="name">var <span class="ident">reg</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">rrel_t_reg_get(self) -&gt; int</strong></div></div>
</dd>
</dl>
</dd>
<dt id="ida_typeinf.scattered_aloc_t"><code class="flex name class">
<span>class <span class="ident">scattered_aloc_t</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ scattered_aloc_t class.</div>
<div class="epy_par">
<strong class="epy_sig">__init__(self) -&gt; scattered_aloc_t</strong></div></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="ida_typeinf.argpartvec_t" href="#ida_typeinf.argpartvec_t">argpartvec_t</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="ida_typeinf.argpartvec_t" href="#ida_typeinf.argpartvec_t">argpartvec_t</a></b></code>:
<ul class="hlist">
<li><code><a title="ida_typeinf.argpartvec_t.add_unique" href="#ida_typeinf.argpartvec_t.add_unique">add_unique</a></code></li>
<li><code><a title="ida_typeinf.argpartvec_t.at" href="#ida_typeinf.argpartvec_t.at">at</a></code></li>
<li><code><a title="ida_typeinf.argpartvec_t.begin" href="#ida_typeinf.argpartvec_t.begin">begin</a></code></li>
<li><code><a title="ida_typeinf.argpartvec_t.capacity" href="#ida_typeinf.argpartvec_t.capacity">capacity</a></code></li>
<li><code><a title="ida_typeinf.argpartvec_t.clear" href="#ida_typeinf.argpartvec_t.clear">clear</a></code></li>
<li><code><a title="ida_typeinf.argpartvec_t.empty" href="#ida_typeinf.argpartvec_t.empty">empty</a></code></li>
<li><code><a title="ida_typeinf.argpartvec_t.end" href="#ida_typeinf.argpartvec_t.end">end</a></code></li>
<li><code><a title="ida_typeinf.argpartvec_t.erase" href="#ida_typeinf.argpartvec_t.erase">erase</a></code></li>
<li><code><a title="ida_typeinf.argpartvec_t.extract" href="#ida_typeinf.argpartvec_t.extract">extract</a></code></li>
<li><code><a title="ida_typeinf.argpartvec_t.find" href="#ida_typeinf.argpartvec_t.find">find</a></code></li>
<li><code><a title="ida_typeinf.argpartvec_t.grow" href="#ida_typeinf.argpartvec_t.grow">grow</a></code></li>
<li><code><a title="ida_typeinf.argpartvec_t.has" href="#ida_typeinf.argpartvec_t.has">has</a></code></li>
<li><code><a title="ida_typeinf.argpartvec_t.inject" href="#ida_typeinf.argpartvec_t.inject">inject</a></code></li>
<li><code><a title="ida_typeinf.argpartvec_t.insert" href="#ida_typeinf.argpartvec_t.insert">insert</a></code></li>
<li><code><a title="ida_typeinf.argpartvec_t.pop_back" href="#ida_typeinf.argpartvec_t.pop_back">pop_back</a></code></li>
<li><code><a title="ida_typeinf.argpartvec_t.push_back" href="#ida_typeinf.argpartvec_t.push_back">push_back</a></code></li>
<li><code><a title="ida_typeinf.argpartvec_t.qclear" href="#ida_typeinf.argpartvec_t.qclear">qclear</a></code></li>
<li><code><a title="ida_typeinf.argpartvec_t.reserve" href="#ida_typeinf.argpartvec_t.reserve">reserve</a></code></li>
<li><code><a title="ida_typeinf.argpartvec_t.resize" href="#ida_typeinf.argpartvec_t.resize">resize</a></code></li>
<li><code><a title="ida_typeinf.argpartvec_t.size" href="#ida_typeinf.argpartvec_t.size">size</a></code></li>
<li><code><a title="ida_typeinf.argpartvec_t.swap" href="#ida_typeinf.argpartvec_t.swap">swap</a></code></li>
<li><code><a title="ida_typeinf.argpartvec_t.truncate" href="#ida_typeinf.argpartvec_t.truncate">truncate</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="ida_typeinf.simd_info_t"><code class="flex name class">
<span>class <span class="ident">simd_info_t</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ simd_info_t class.</div>
<div class="epy_par">
<strong class="epy_sig">__init__(self, nm=None, sz=0, memt=BTF_UNK) -&gt; simd_info_t</strong><div class="epy_nested">
nm: char const *
sz: uint16
memt: type_t</div>
</div></div>
<h3>Instance variables</h3>
<dl>
<dt id="ida_typeinf.simd_info_t.memtype"><code class="name">var <span class="ident">memtype</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">simd_info_t_memtype_get(self) -&gt; type_t</strong></div></div>
</dd>
<dt id="ida_typeinf.simd_info_t.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">simd_info_t_name_get(self) -&gt; char const *</strong></div></div>
</dd>
<dt id="ida_typeinf.simd_info_t.size"><code class="name">var <span class="ident">size</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">simd_info_t_size_get(self) -&gt; uint16</strong></div></div>
</dd>
<dt id="ida_typeinf.simd_info_t.tif"><code class="name">var <span class="ident">tif</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">simd_info_t_tif_get(self) -&gt; tinfo_t</strong></div></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ida_typeinf.simd_info_t.match_pattern"><code class="name flex">
<span>def <span class="ident">match_pattern</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">match_pattern(self, pattern) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">pattern</strong> (C++: const
simd_info_t
*)</div>
</div></div>
</dd>
</dl>
</dd>
<dt id="ida_typeinf.text_sink_t"><code class="flex name class">
<span>class <span class="ident">text_sink_t</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ text_sink_t class.</div>
<div class="epy_par">
<strong class="epy_sig">__init__(self) -&gt; text_sink_t</strong><div class="epy_nested">
self: PyObject *</div>
</div></div>
</dd>
<dt id="ida_typeinf.til_symbol_t"><code class="flex name class">
<span>class <span class="ident">til_symbol_t</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ til_symbol_t class.</div>
<div class="epy_par">
<strong class="epy_sig">__init__(self, n=None, t=None) -&gt; til_symbol_t</strong><div class="epy_nested">
n: char const *
t: til_t const *</div>
</div></div>
<h3>Instance variables</h3>
<dl>
<dt id="ida_typeinf.til_symbol_t.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">til_symbol_t_name_get(self) -&gt; char const *</strong></div></div>
</dd>
<dt id="ida_typeinf.til_symbol_t.til"><code class="name">var <span class="ident">til</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">til_symbol_t_til_get(self) -&gt; til_t</strong></div></div>
</dd>
</dl>
</dd>
<dt id="ida_typeinf.til_t"><code class="flex name class">
<span>class <span class="ident">til_t</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ til_t class.</div>
<div class="epy_par">
<strong class="epy_sig">__init__(self) -&gt; til_t</strong></div></div>
<h3>Instance variables</h3>
<dl>
<dt id="ida_typeinf.til_t.cc"><code class="name">var <span class="ident">cc</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">til_t_cc_get(self) -&gt; compiler_info_t</strong></div></div>
</dd>
<dt id="ida_typeinf.til_t.desc"><code class="name">var <span class="ident">desc</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">til_t_desc_get(self) -&gt; char *</strong></div></div>
</dd>
<dt id="ida_typeinf.til_t.flags"><code class="name">var <span class="ident">flags</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">til_t_flags_get(self) -&gt; uint32</strong></div></div>
</dd>
<dt id="ida_typeinf.til_t.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">til_t_name_get(self) -&gt; char *</strong></div></div>
</dd>
<dt id="ida_typeinf.til_t.nbases"><code class="name">var <span class="ident">nbases</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">til_t_nbases_get(self) -&gt; int</strong></div></div>
</dd>
<dt id="ida_typeinf.til_t.nrefs"><code class="name">var <span class="ident">nrefs</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">til_t_nrefs_get(self) -&gt; int</strong></div></div>
</dd>
<dt id="ida_typeinf.til_t.nstreams"><code class="name">var <span class="ident">nstreams</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">til_t_nstreams_get(self) -&gt; int</strong></div></div>
</dd>
<dt id="ida_typeinf.til_t.streams"><code class="name">var <span class="ident">streams</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">til_t_streams_get(self) -&gt; til_stream_t **</strong></div></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ida_typeinf.til_t.base"><code class="name flex">
<span>def <span class="ident">base</span></span>(<span>self, *args) &#8209;&gt;&#160;<a title="ida_typeinf.til_t" href="#ida_typeinf.til_t">til_t</a>&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">base(self, n) -&gt; til_t</strong><div class="epy_nested">
n: int</div>
</div></div>
</dd>
<dt id="ida_typeinf.til_t.is_dirty"><code class="name flex">
<span>def <span class="ident">is_dirty</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Has the til been modified? ( 'TIL_MOD' )</div></div>
</dd>
<dt id="ida_typeinf.til_t.set_dirty"><code class="name flex">
<span>def <span class="ident">set_dirty</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Mark the til as modified ( 'TIL_MOD' )</div></div>
</dd>
</dl>
</dd>
<dt id="ida_typeinf.tinfo_t"><code class="flex name class">
<span>class <span class="ident">tinfo_t</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ tinfo_t class.</div>
<div class="epy_par">
<strong class="epy_sig">__init__(self) -&gt; tinfo_t</strong><div class="epy_nested">
decl_type: type_t</div>
</div>
<div class="epy_par">
<strong class="epy_sig">__init__(self, r) -&gt; tinfo_t</strong><div class="epy_nested">
r: tinfo_t const &amp;</div>
</div></div>
<h3>Static methods</h3>
<dl>
<dt id="ida_typeinf.tinfo_t.get_stock"><code class="name flex">
<span>def <span class="ident">get_stock</span></span>(<span>*args) &#8209;&gt;&#160;<a title="ida_typeinf.tinfo_t" href="#ida_typeinf.tinfo_t">tinfo_t</a></span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">get_stock(id) -&gt; tinfo_t</strong><div class="epy_nested">
id: enum stock_type_id_t</div>
</div></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ida_typeinf.tinfo_t.append_covered"><code class="name flex">
<span>def <span class="ident">append_covered</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Calculate set of covered bytes for the type</div>
<div class="epy_par">
<strong class="epy_sig">append_covered(self, out, offset=0) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">out</strong>: pointer to the output buffer. covered bytes will be<div class="epy_nested">
appended to it. (C++: rangeset_t
*)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">offset</strong> (C++: uint64)</div>
</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.calc_gaps"><code class="name flex">
<span>def <span class="ident">calc_gaps</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Calculate set of padding bytes for the type</div>
<div class="epy_par">
<strong class="epy_sig">calc_gaps(self, out) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">out</strong>: pointer to the output buffer; old buffer contents will be<div class="epy_nested">
lost. (C++: rangeset_t
*)</div>
</div>
</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.calc_purged_bytes"><code class="name flex">
<span>def <span class="ident">calc_purged_bytes</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
'BT_FUNC' : Calculate number of purged bytes</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.calc_score"><code class="name flex">
<span>def <span class="ident">calc_score</span></span>(<span>self, *args) &#8209;&gt;&#160;uint32</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Calculate the type score (the higher - the nicer is the type)</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.calc_udt_aligns"><code class="name flex">
<span>def <span class="ident">calc_udt_aligns</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Calculate the udt alignments using the field offsets/sizes and the
total udt size This function does not work on typerefs</div>
<div class="epy_par">
<strong class="epy_sig">calc_udt_aligns(self, sudt_flags=0x0004) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">sudt_flags</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.change_sign"><code class="name flex">
<span>def <span class="ident">change_sign</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Change the type sign. Works only for the types that may have sign.</div>
<div class="epy_par">
<strong class="epy_sig">change_sign(self, sign) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">sign</strong> (C++: type_sign_t)</div>
</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Clear contents of this tinfo, and remove from the type system.</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.clr_const"><code class="name flex">
<span>def <span class="ident">clr_const</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">clr_const(self)</strong></div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.clr_const_volatile"><code class="name flex">
<span>def <span class="ident">clr_const_volatile</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">clr_const_volatile(self)</strong></div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.clr_volatile"><code class="name flex">
<span>def <span class="ident">clr_volatile</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">clr_volatile(self)</strong></div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.compare"><code class="name flex">
<span>def <span class="ident">compare</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">compare(self, r) -&gt; int</strong><div class="epy_nested">
r: tinfo_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.compare_with"><code class="name flex">
<span>def <span class="ident">compare_with</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Compare two types, based on given flags (see 'tinfo_t comparison
flags' )</div>
<div class="epy_par">
<strong class="epy_sig">compare_with(self, r, tcflags=0) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">r</strong> (C++: const
tinfo_t
&amp;)</div>
<div class="epy_nested">
<strong class="epy_parameter">tcflags</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.convert_array_to_ptr"><code class="name flex">
<span>def <span class="ident">convert_array_to_ptr</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Convert an array into a pointer. type[] =&gt; type *</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self, *args) &#8209;&gt;&#160;<a title="ida_typeinf.tinfo_t" href="#ida_typeinf.tinfo_t">tinfo_t</a></span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">copy(self) -&gt; tinfo_t</strong></div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.create_array"><code class="name flex">
<span>def <span class="ident">create_array</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">create_array(self, p, decl_type=BT_ARRAY) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">p</strong> (C++: const
array_type_data_t
&amp;)</div>
<div class="epy_nested">
<strong class="epy_parameter">decl_type</strong> (C++: type_t)</div>
</div>
<div class="epy_par">
<strong class="epy_sig">create_array(self, tif, nelems=0, base=0, decl_type=BT_ARRAY) -&gt; bool</strong><div class="epy_nested">
tif: tinfo_t const &amp;
nelems: uint32
base: uint32</div>
<div class="epy_nested">
<strong class="epy_parameter">decl_type</strong> (C++: type_t)</div>
</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.create_bitfield"><code class="name flex">
<span>def <span class="ident">create_bitfield</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">create_bitfield(self, p, decl_type=BT_BITFIELD) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">p</strong> (C++: const
bitfield_type_data_t
&amp;)</div>
<div class="epy_nested">
<strong class="epy_parameter">decl_type</strong> (C++: type_t)</div>
</div>
<div class="epy_par">
<strong class="epy_sig">create_bitfield(self, nbytes, width, is_unsigned=False, decl_type=BT_BITFIELD) -&gt; bool</strong><div class="epy_nested">
nbytes: uchar
width: uchar
is_unsigned: bool</div>
<div class="epy_nested">
<strong class="epy_parameter">decl_type</strong> (C++: type_t)</div>
</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.create_enum"><code class="name flex">
<span>def <span class="ident">create_enum</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">create_enum(self, p, decl_type=BTF_ENUM) -&gt; bool</strong><div class="epy_nested">
p: enum_type_data_t &amp;
decl_type: type_t</div>
</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.create_forward_decl"><code class="name flex">
<span>def <span class="ident">create_forward_decl</span></span>(<span>self, *args) &#8209;&gt;&#160;tinfo_code_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Create a forward declaration. decl_type: 'BTF_STRUCT' , 'BTF_UNION' ,
or 'BTF_ENUM'</div>
<div class="epy_par">
<strong class="epy_sig">create_forward_decl(self, til, decl_type, name, ntf_flags=0) -&gt; tinfo_code_t</strong><div class="epy_nested">
<strong class="epy_parameter">til</strong> (C++: til_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">decl_type</strong> (C++: type_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">name</strong> (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">ntf_flags</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.create_func"><code class="name flex">
<span>def <span class="ident">create_func</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">create_func(self, p, decl_type=BT_FUNC) -&gt; bool</strong><div class="epy_nested">
p: func_type_data_t &amp;
decl_type: type_t</div>
</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.create_ptr"><code class="name flex">
<span>def <span class="ident">create_ptr</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">create_ptr(self, p, decl_type=BT_PTR) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">p</strong> (C++: const
ptr_type_data_t
&amp;)</div>
<div class="epy_nested">
<strong class="epy_parameter">decl_type</strong> (C++: type_t)</div>
</div>
<div class="epy_par">
<strong class="epy_sig">create_ptr(self, tif, bps=0, decl_type=BT_PTR) -&gt; bool</strong><div class="epy_nested">
tif: tinfo_t const &amp;
bps: uchar</div>
<div class="epy_nested">
<strong class="epy_parameter">decl_type</strong> (C++: type_t)</div>
</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.create_simple_type"><code class="name flex">
<span>def <span class="ident">create_simple_type</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">create_simple_type(self, decl_type) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">decl_type</strong> (C++: type_t)</div>
</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.create_typedef"><code class="name flex">
<span>def <span class="ident">create_typedef</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">create_typedef(self, p, decl_type=BTF_TYPEDEF, try_ordinal=True) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">p</strong> (C++: const
typedef_type_data_t
&amp;)</div>
<div class="epy_nested">
<strong class="epy_parameter">decl_type</strong> (C++: type_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">try_ordinal</strong> (C++: bool)</div>
</div>
<div class="epy_par">
<strong class="epy_sig">create_typedef(self, til, name, decl_type=BTF_TYPEDEF, try_ordinal=True)</strong><div class="epy_nested">
til: til_t const *
name: char const *</div>
<div class="epy_nested">
<strong class="epy_parameter">decl_type</strong> (C++: type_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">try_ordinal</strong> (C++: bool)</div>
</div>
<div class="epy_par">
<strong class="epy_sig">create_typedef(self, til, ord, decl_type=BTF_TYPEDEF)</strong><div class="epy_nested">
til: til_t const *
ord: uint</div>
<div class="epy_nested">
<strong class="epy_parameter">decl_type</strong> (C++: type_t)</div>
</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.create_udt"><code class="name flex">
<span>def <span class="ident">create_udt</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">create_udt(self, p, decl_type) -&gt; bool</strong><div class="epy_nested">
p: udt_type_data_t &amp;
decl_type: type_t</div>
</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.del_attr"><code class="name flex">
<span>def <span class="ident">del_attr</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Del a type attribute. typerefs cannot be modified by this function.</div>
<div class="epy_par">
<strong class="epy_sig">del_attr(self, key, make_copy=True) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">key</strong> (C++: const
qstring
&amp;)</div>
<div class="epy_nested">
<strong class="epy_parameter">make_copy</strong> (C++: bool)</div>
</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.del_attrs"><code class="name flex">
<span>def <span class="ident">del_attrs</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Del all type attributes. typerefs cannot be modified by this function.</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.deserialize"><code class="name flex">
<span>def <span class="ident">deserialize</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Deserialize a type string into a 'tinfo_t' object.</div>
<div class="epy_par">
<strong class="epy_sig">deserialize(self, til, ptype, pfields=None, pfldcmts=None) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">til</strong> (C++: const
til_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">ptype</strong> (C++: const
type_t
**)</div>
<div class="epy_nested">
<strong class="epy_parameter">pfields</strong> (C++: const
p_list
**)</div>
<div class="epy_nested">
<strong class="epy_parameter">pfldcmts</strong> (C++: const
p_list
**)</div>
</div>
<div class="epy_par">
<strong class="epy_sig">deserialize(self, til, type, fields, cmts=None) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">til</strong> (C++: const
til_t
*)
type: type_t const *
fields: p_list const *
cmts: p_list const *</div>
</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.dstr"><code class="name flex">
<span>def <span class="ident">dstr</span></span>(<span>self, *args) &#8209;&gt;&#160;char&#160;const&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Function to facilitate debugging.</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.empty"><code class="name flex">
<span>def <span class="ident">empty</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Was 'tinfo_t' initialized with some type info or not?</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.equals_to"><code class="name flex">
<span>def <span class="ident">equals_to</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">equals_to(self, r) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">r</strong> (C++: const
tinfo_t
&amp;)</div>
</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.find_udt_member"><code class="name flex">
<span>def <span class="ident">find_udt_member</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
'BTF_STRUCT' , 'BTF_UNION' : Find a udt member.at the specified
offset ( 'STRMEM_OFFSET' )with the specified index ( 'STRMEM_INDEX'
)with the specified type ( 'STRMEM_TYPE' )with the specified name (
'STRMEM_NAME' )</div>
<div class="epy_par">
<strong class="epy_sig">find_udt_member(self, udm, strmem_flags) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">udm</strong> (C++: struct
udt_member_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">strmem_flags</strong> (C++: int)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: the index of the found member or -1</div>
</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.get_array_details"><code class="name flex">
<span>def <span class="ident">get_array_details</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get the array specific info.</div>
<div class="epy_par">
<strong class="epy_sig">get_array_details(self, ai) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ai</strong> (C++: array_type_data_t
*)</div>
</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.get_array_element"><code class="name flex">
<span>def <span class="ident">get_array_element</span></span>(<span>self, *args) &#8209;&gt;&#160;<a title="ida_typeinf.tinfo_t" href="#ida_typeinf.tinfo_t">tinfo_t</a></span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
'BT_ARRAY' : get type of array element. See also
'get_ptrarr_object()'</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.get_array_nelems"><code class="name flex">
<span>def <span class="ident">get_array_nelems</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
'BT_ARRAY' : get number of elements (-1 means error)</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.get_attr"><code class="name flex">
<span>def <span class="ident">get_attr</span></span>(<span>self, *args) &#8209;&gt;&#160;PyObject&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get a type attribute.</div>
<div class="epy_par">
<strong class="epy_sig">get_attr(self, key, all_attrs=True) -&gt; PyObject *</strong><div class="epy_nested">
<strong class="epy_parameter">key</strong> (C++: const
qstring
&amp;)</div>
<div class="epy_nested">
<strong class="epy_parameter">all_attrs</strong> (C++: bool)</div>
</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.get_attrs"><code class="name flex">
<span>def <span class="ident">get_attrs</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get type attributes (all_attrs: include attributes of referenced
types, if any)</div>
<div class="epy_par">
<strong class="epy_sig">get_attrs(self, tav, all_attrs=False) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">tav</strong> (C++: type_attrs_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">all_attrs</strong> (C++: bool)</div>
</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.get_bitfield_details"><code class="name flex">
<span>def <span class="ident">get_bitfield_details</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get the bitfield specific info.</div>
<div class="epy_par">
<strong class="epy_sig">get_bitfield_details(self, bi) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">bi</strong> (C++: bitfield_type_data_t
*)</div>
</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.get_declalign"><code class="name flex">
<span>def <span class="ident">get_declalign</span></span>(<span>self, *args) &#8209;&gt;&#160;uchar</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get declared alignment of the type.</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.get_decltype"><code class="name flex">
<span>def <span class="ident">get_decltype</span></span>(<span>self, *args) &#8209;&gt;&#160;type_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get declared type (without resolving type references; they are
returned as is). Obviously this is a very fast function and should be
used instead of 'get_realtype()' if possible.</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.get_enum_base_type"><code class="name flex">
<span>def <span class="ident">get_enum_base_type</span></span>(<span>self, *args) &#8209;&gt;&#160;type_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get enum base type (convert enum to integer type) Returns 'BT_UNK' if
failed to convert</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.get_enum_details"><code class="name flex">
<span>def <span class="ident">get_enum_details</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get the enum specific info.</div>
<div class="epy_par">
<strong class="epy_sig">get_enum_details(self, ei) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ei</strong> (C++: enum_type_data_t
*)</div>
</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.get_final_ordinal"><code class="name flex">
<span>def <span class="ident">get_final_ordinal</span></span>(<span>self, *args) &#8209;&gt;&#160;uint32</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get final type ordinal (0 is none)</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.get_final_type_name"><code class="name flex">
<span>def <span class="ident">get_final_type_name</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Use in the case of typedef chain (TYPE1 -&gt; TYPE2 -&gt; TYPE3...TYPEn).</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.get_func_details"><code class="name flex">
<span>def <span class="ident">get_func_details</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get only the function specific info for this 'tinfo_t' .</div>
<div class="epy_par">
<strong class="epy_sig">get_func_details(self, fi, gtd=GTD_CALC_ARGLOCS) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">fi</strong> (C++: func_type_data_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">gtd</strong> (C++: gtd_func_t)</div>
</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.get_modifiers"><code class="name flex">
<span>def <span class="ident">get_modifiers</span></span>(<span>self, *args) &#8209;&gt;&#160;type_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">get_modifiers(self) -&gt; type_t</strong></div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.get_named_type"><code class="name flex">
<span>def <span class="ident">get_named_type</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Create a 'tinfo_t' object for an existing named type.</div>
<div class="epy_par">
<strong class="epy_sig">get_named_type(self, til, name, decl_type=BTF_TYPEDEF, resolve=True, try_ordinal=True) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">til</strong>: type library to use (C++: const
til_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">name</strong>: name of the type to link to (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">decl_type</strong>: if the reference was explicitly specified with the<div class="epy_nested">
type tag
( BTF_STRUCT / BTF_UNION / BTF_ENUM )
you may specify it.
the kernel will accept only
the specified tag after resolving
the type. If
the resolved type does not correspond to the
explicitly specified tag, the type will be
considered as undefined (C++: type_t)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">resolve</strong>: true: immediately resolve the type and return success<div class="epy_nested">
code. false: return true but do not immediately
resolve the type (C++: bool)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">try_ordinal</strong>: true: try to replace name reference by an ordinal<div class="epy_nested">
reference (C++: bool)</div>
</div>
</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.get_nargs"><code class="name flex">
<span>def <span class="ident">get_nargs</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
'BT_FUNC' or 'BT_PTR'
'BT_FUNC' : Calculate number of arguments (-1</div>
<ul class="epy_ul">
<li class="epy_li"><span class="epy_par">
error)</span>
</li>
</ul></div>
</dd>
<dt id="ida_typeinf.tinfo_t.get_next_type_name"><code class="name flex">
<span>def <span class="ident">get_next_type_name</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Use In the case of typedef chain (TYPE1 -&gt; TYPE2 -&gt; TYPE3...TYPEn).</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.get_nth_arg"><code class="name flex">
<span>def <span class="ident">get_nth_arg</span></span>(<span>self, *args) &#8209;&gt;&#160;<a title="ida_typeinf.tinfo_t" href="#ida_typeinf.tinfo_t">tinfo_t</a></span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
'BT_FUNC' or 'BT_PTR'
'BT_FUNC' : Get type of n-th arg (-1 means
return type, see 'get_rettype()' )</div>
<div class="epy_par">
<strong class="epy_sig">get_nth_arg(self, n) -&gt; tinfo_t</strong><div class="epy_nested">
<strong class="epy_parameter">n</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.get_numbered_type"><code class="name flex">
<span>def <span class="ident">get_numbered_type</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Create a 'tinfo_t' object for an existing ordinal type.</div>
<div class="epy_par">
<strong class="epy_sig">get_numbered_type(self, til, ordinal, decl_type=BTF_TYPEDEF, resolve=True) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">til</strong>: type library to use (C++: const
til_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">ordinal</strong>: number of the type to link to (C++: uint32)</div>
<div class="epy_nested">
<strong class="epy_parameter">decl_type</strong>: if the reference was explicitly specified with the<div class="epy_nested">
type tag (BTF_STRUCT/BTF_UNION/BTF_ENUM) you may
specify it. the kernel will accept only the
specified tag after resolving the type. If the
resolved type does not correspond to the explicitly
specified tag, the type will be considered as
undefined (C++: type_t)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">resolve</strong>: true: immediately resolve the type and return success<div class="epy_nested">
code false: return true but do not immediately resolve
the type (C++: bool)</div>
</div>
</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.get_onemember_type"><code class="name flex">
<span>def <span class="ident">get_onemember_type</span></span>(<span>self, *args) &#8209;&gt;&#160;<a title="ida_typeinf.tinfo_t" href="#ida_typeinf.tinfo_t">tinfo_t</a></span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
For objects consisting of one member entirely: return type of the
member.</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.get_ordinal"><code class="name flex">
<span>def <span class="ident">get_ordinal</span></span>(<span>self, *args) &#8209;&gt;&#160;uint32</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get type ordinal (only if the type was created as a numbered type, 0
if none)</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.get_pointed_object"><code class="name flex">
<span>def <span class="ident">get_pointed_object</span></span>(<span>self, *args) &#8209;&gt;&#160;<a title="ida_typeinf.tinfo_t" href="#ida_typeinf.tinfo_t">tinfo_t</a></span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
'BT_PTR' : get type of pointed object. If the current type is not a
pointer, return empty type info. See also 'get_ptrarr_object()' and
'remove_pointer()'</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.get_ptr_details"><code class="name flex">
<span>def <span class="ident">get_ptr_details</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get the pointer info.</div>
<div class="epy_par">
<strong class="epy_sig">get_ptr_details(self, pi) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">pi</strong> (C++: ptr_type_data_t
*)</div>
</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.get_ptrarr_object"><code class="name flex">
<span>def <span class="ident">get_ptrarr_object</span></span>(<span>self, *args) &#8209;&gt;&#160;<a title="ida_typeinf.tinfo_t" href="#ida_typeinf.tinfo_t">tinfo_t</a></span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
'BT_PTR' &amp; 'BT_ARRAY' : get the pointed object or array element. If
the current type is not a pointer or array, return empty type info.</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.get_ptrarr_objsize"><code class="name flex">
<span>def <span class="ident">get_ptrarr_objsize</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
'BT_PTR' &amp; 'BT_ARRAY' : get size of pointed object or array element.
On error returns -1</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.get_realtype"><code class="name flex">
<span>def <span class="ident">get_realtype</span></span>(<span>self, *args) &#8209;&gt;&#160;type_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get the resolved base type. Deserialization options:if full=true, the
referenced type will be deserialized fully, this may not always be
desirable (slows down things)if full=false, we just return the base
type, the referenced type will be resolved again later if necessary
(this may lead to multiple resolvings of the same type) imho
full=false is a better approach because it does not perform
unnecessary actions just in case. however, in some cases the caller
knows that it is very likely that full type info will be required. in
those cases full=true makes sense</div>
<div class="epy_par">
<strong class="epy_sig">get_realtype(self, full=False) -&gt; type_t</strong><div class="epy_nested">
<strong class="epy_parameter">full</strong> (C++: bool)</div>
</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.get_rettype"><code class="name flex">
<span>def <span class="ident">get_rettype</span></span>(<span>self, *args) &#8209;&gt;&#160;<a title="ida_typeinf.tinfo_t" href="#ida_typeinf.tinfo_t">tinfo_t</a></span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
'BT_FUNC' or 'BT_PTR'
'BT_FUNC' : Get the function's return type</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.get_sign"><code class="name flex">
<span>def <span class="ident">get_sign</span></span>(<span>self, *args) &#8209;&gt;&#160;type_sign_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get type sign.</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.get_size"><code class="name flex">
<span>def <span class="ident">get_size</span></span>(<span>self, *args) &#8209;&gt;&#160;size_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get the type size in bytes.</div>
<div class="epy_par">
<strong class="epy_sig">get_size(self, p_effalign=None, gts_code=0) -&gt; size_t</strong><div class="epy_nested">
<strong class="epy_parameter">p_effalign</strong>: buffer for the alignment value (C++: uint32
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">gts_code</strong>: combination of GTS_... constants (C++: int)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: BADSIZE
in case of problems</div>
</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.get_til"><code class="name flex">
<span>def <span class="ident">get_til</span></span>(<span>self, *args) &#8209;&gt;&#160;<a title="ida_typeinf.til_t" href="#ida_typeinf.til_t">til_t</a>&#160;const&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get the type library for 'tinfo_t' .</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.get_type_name"><code class="name flex">
<span>def <span class="ident">get_type_name</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Does a type refer to a name?. If yes, fill the provided buffer with
the type name and return true. Names are returned for numbered types
too: either a user-defined nice name or, if a user-provided name does
not exist, an ordinal name (like #xx, see
'create_numbered_type_name()' ).</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.get_udt_details"><code class="name flex">
<span>def <span class="ident">get_udt_details</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get the udt specific info.</div>
<div class="epy_par">
<strong class="epy_sig">get_udt_details(self, udt, gtd=GTD_CALC_LAYOUT) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">udt</strong> (C++: udt_type_data_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">gtd</strong> (C++: gtd_udt_t)</div>
</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.get_udt_nmembers"><code class="name flex">
<span>def <span class="ident">get_udt_nmembers</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get number of udt members. -1-error.</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.get_unpadded_size"><code class="name flex">
<span>def <span class="ident">get_unpadded_size</span></span>(<span>self, *args) &#8209;&gt;&#160;size_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get the type size in bytes without the final padding, in bytes. For
some UDTs 'get_unpadded_size()' != 'get_size()'</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.has_details"><code class="name flex">
<span>def <span class="ident">has_details</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Does this type refer to a nontrivial type?</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.has_vftable"><code class="name flex">
<span>def <span class="ident">has_vftable</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Has a vftable?</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_anonymous_udt"><code class="name flex">
<span>def <span class="ident">is_anonymous_udt</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is an anonymous struct/union? We assume that types with names are
anonymous if the name starts with $</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_arithmetic"><code class="name flex">
<span>def <span class="ident">is_arithmetic</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
\isreal{is_type_arithmetic}</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_array"><code class="name flex">
<span>def <span class="ident">is_array</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
\isreal{is_type_array}</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_bitfield"><code class="name flex">
<span>def <span class="ident">is_bitfield</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
\isreal{is_type_bitfld}</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_bool"><code class="name flex">
<span>def <span class="ident">is_bool</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
\isreal{is_type_bool}</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_castable_to"><code class="name flex">
<span>def <span class="ident">is_castable_to</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">is_castable_to(self, target) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">target</strong> (C++: const
tinfo_t
&amp;)</div>
</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_char"><code class="name flex">
<span>def <span class="ident">is_char</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
\isreal{is_type_char}</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_complex"><code class="name flex">
<span>def <span class="ident">is_complex</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
\isreal{is_type_complex}</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_const"><code class="name flex">
<span>def <span class="ident">is_const</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
\isreal{is_type_const}</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_correct"><code class="name flex">
<span>def <span class="ident">is_correct</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is the type object correct?. It is possible to create incorrect types.
For example, we can define a function that returns a enum and then
delete the enum type. If this function returns false, the type should
not be used in disassembly. Please note that this function does not
verify all involved types: for example, pointers to undefined types
are permitted.</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_decl_array"><code class="name flex">
<span>def <span class="ident">is_decl_array</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
\isdecl{is_type_array}</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_decl_bitfield"><code class="name flex">
<span>def <span class="ident">is_decl_bitfield</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
\isdecl{is_type_bitfld}</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_decl_bool"><code class="name flex">
<span>def <span class="ident">is_decl_bool</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
\isdecl{is_type_bool}</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_decl_char"><code class="name flex">
<span>def <span class="ident">is_decl_char</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
\isdecl{is_type_char}</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_decl_complex"><code class="name flex">
<span>def <span class="ident">is_decl_complex</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
\isdecl{is_type_complex}</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_decl_const"><code class="name flex">
<span>def <span class="ident">is_decl_const</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
\isdecl{is_type_const}</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_decl_double"><code class="name flex">
<span>def <span class="ident">is_decl_double</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
\isdecl{is_type_double}</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_decl_enum"><code class="name flex">
<span>def <span class="ident">is_decl_enum</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
\isdecl{is_type_enum}</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_decl_float"><code class="name flex">
<span>def <span class="ident">is_decl_float</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
\isdecl{is_type_float}</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_decl_floating"><code class="name flex">
<span>def <span class="ident">is_decl_floating</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
\isdecl{is_type_floating}</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_decl_func"><code class="name flex">
<span>def <span class="ident">is_decl_func</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
\isdecl{is_type_func}</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_decl_int"><code class="name flex">
<span>def <span class="ident">is_decl_int</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
\isdecl{is_type_int}</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_decl_int128"><code class="name flex">
<span>def <span class="ident">is_decl_int128</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
\isdecl{is_type_int128}</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_decl_int16"><code class="name flex">
<span>def <span class="ident">is_decl_int16</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
\isdecl{is_type_int16}</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_decl_int32"><code class="name flex">
<span>def <span class="ident">is_decl_int32</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
\isdecl{is_type_int32}</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_decl_int64"><code class="name flex">
<span>def <span class="ident">is_decl_int64</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
\isdecl{is_type_int64}</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_decl_last"><code class="name flex">
<span>def <span class="ident">is_decl_last</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
\isdecl{is_typeid_last}</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_decl_ldouble"><code class="name flex">
<span>def <span class="ident">is_decl_ldouble</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
\isdecl{is_type_ldouble}</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_decl_paf"><code class="name flex">
<span>def <span class="ident">is_decl_paf</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
\isdecl{is_type_paf}</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_decl_partial"><code class="name flex">
<span>def <span class="ident">is_decl_partial</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
\isdecl{is_type_partial}</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_decl_ptr"><code class="name flex">
<span>def <span class="ident">is_decl_ptr</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
\isdecl{is_type_ptr}</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_decl_struct"><code class="name flex">
<span>def <span class="ident">is_decl_struct</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
\isdecl{is_type_struct}</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_decl_sue"><code class="name flex">
<span>def <span class="ident">is_decl_sue</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
\isdecl{is_type_sue}</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_decl_tbyte"><code class="name flex">
<span>def <span class="ident">is_decl_tbyte</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
\isdecl{is_type_tbyte}</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_decl_typedef"><code class="name flex">
<span>def <span class="ident">is_decl_typedef</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
\isdecl{is_type_typedef}</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_decl_uchar"><code class="name flex">
<span>def <span class="ident">is_decl_uchar</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
\isdecl{is_type_uchar}</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_decl_udt"><code class="name flex">
<span>def <span class="ident">is_decl_udt</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
\isdecl{is_type_struni}</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_decl_uint"><code class="name flex">
<span>def <span class="ident">is_decl_uint</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
\isdecl{is_type_uint}</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_decl_uint128"><code class="name flex">
<span>def <span class="ident">is_decl_uint128</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
\isdecl{is_type_uint128}</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_decl_uint16"><code class="name flex">
<span>def <span class="ident">is_decl_uint16</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
\isdecl{is_type_uint16}</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_decl_uint32"><code class="name flex">
<span>def <span class="ident">is_decl_uint32</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
\isdecl{is_type_uint32}</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_decl_uint64"><code class="name flex">
<span>def <span class="ident">is_decl_uint64</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
\isdecl{is_type_uint64}</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_decl_union"><code class="name flex">
<span>def <span class="ident">is_decl_union</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
\isdecl{is_type_union}</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_decl_unknown"><code class="name flex">
<span>def <span class="ident">is_decl_unknown</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
\isdecl{is_type_unknown}</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_decl_void"><code class="name flex">
<span>def <span class="ident">is_decl_void</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
\isdecl{is_type_void}</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_decl_volatile"><code class="name flex">
<span>def <span class="ident">is_decl_volatile</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
\isdecl{is_type_volatile}</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_double"><code class="name flex">
<span>def <span class="ident">is_double</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
\isreal{is_type_double}</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_empty_udt"><code class="name flex">
<span>def <span class="ident">is_empty_udt</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is an empty struct/union? (has no fields)</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_enum"><code class="name flex">
<span>def <span class="ident">is_enum</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
\isreal{is_type_enum}</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_ext_arithmetic"><code class="name flex">
<span>def <span class="ident">is_ext_arithmetic</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
\isreal{is_type_ext_arithmetic}</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_ext_integral"><code class="name flex">
<span>def <span class="ident">is_ext_integral</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
\isreal{is_type_ext_integral}</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_float"><code class="name flex">
<span>def <span class="ident">is_float</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
\isreal{is_type_float}</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_floating"><code class="name flex">
<span>def <span class="ident">is_floating</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
\isreal{is_type_floating}</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_forward_decl"><code class="name flex">
<span>def <span class="ident">is_forward_decl</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is this a forward declaration?. Forward declarations are placeholders:
the type definition does not exist</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_from_subtil"><code class="name flex">
<span>def <span class="ident">is_from_subtil</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Was the named type found in some base type library (not the top level
type library)?. If yes, it usually means that the type comes from some
loaded type library, not the local type library for the database</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_func"><code class="name flex">
<span>def <span class="ident">is_func</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
\isreal{is_type_func}</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_funcptr"><code class="name flex">
<span>def <span class="ident">is_funcptr</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is this pointer to a function?</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_high_func"><code class="name flex">
<span>def <span class="ident">is_high_func</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
'BT_FUNC' : Is high level type?</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_int"><code class="name flex">
<span>def <span class="ident">is_int</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
\isreal{is_type_int}</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_int128"><code class="name flex">
<span>def <span class="ident">is_int128</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
\isreal{is_type_int128}</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_int16"><code class="name flex">
<span>def <span class="ident">is_int16</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
\isreal{is_type_int16}</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_int32"><code class="name flex">
<span>def <span class="ident">is_int32</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
\isreal{is_type_int32}</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_int64"><code class="name flex">
<span>def <span class="ident">is_int64</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
\isreal{is_type_int64}</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_integral"><code class="name flex">
<span>def <span class="ident">is_integral</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
\isreal{is_type_integral}</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_ldouble"><code class="name flex">
<span>def <span class="ident">is_ldouble</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
\isreal{is_type_ldouble}</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_manually_castable_to"><code class="name flex">
<span>def <span class="ident">is_manually_castable_to</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">is_manually_castable_to(self, target) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">target</strong> (C++: const
tinfo_t
&amp;)</div>
</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_one_fpval"><code class="name flex">
<span>def <span class="ident">is_one_fpval</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Floating value or an object consisting of one floating member
entirely.</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_paf"><code class="name flex">
<span>def <span class="ident">is_paf</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
\isreal{is_type_paf}</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_partial"><code class="name flex">
<span>def <span class="ident">is_partial</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
\isreal{is_type_partial}</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_ptr"><code class="name flex">
<span>def <span class="ident">is_ptr</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
\isreal{is_type_ptr}</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_ptr_or_array"><code class="name flex">
<span>def <span class="ident">is_ptr_or_array</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
\isreal{is_type_ptr_or_array}</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_purging_cc"><code class="name flex">
<span>def <span class="ident">is_purging_cc</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
\tinfocc{is_purging_cc}</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_pvoid"><code class="name flex">
<span>def <span class="ident">is_pvoid</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is "void *"?. This function does not check the pointer attributes and
type modifiers.</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_scalar"><code class="name flex">
<span>def <span class="ident">is_scalar</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Does the type represent a single number?</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_shifted_ptr"><code class="name flex">
<span>def <span class="ident">is_shifted_ptr</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is a shifted pointer?</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_signed"><code class="name flex">
<span>def <span class="ident">is_signed</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is this a signed type?</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_small_udt"><code class="name flex">
<span>def <span class="ident">is_small_udt</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is a small udt? (can fit a register or a pair of registers)</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_sse_type"><code class="name flex">
<span>def <span class="ident">is_sse_type</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is a SSE vector type?</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_struct"><code class="name flex">
<span>def <span class="ident">is_struct</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
\isreal{is_type_struct}</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_sue"><code class="name flex">
<span>def <span class="ident">is_sue</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
\isreal{is_type_sue}</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_tbyte"><code class="name flex">
<span>def <span class="ident">is_tbyte</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
\isreal{is_type_tbyte}</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_typeref"><code class="name flex">
<span>def <span class="ident">is_typeref</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is this type a type reference?. Type references cannot be modified.
Once created, they do not change. Because of this, the set_...
functions applied to typerefs create a new type id. Other types are
modified directly.</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_uchar"><code class="name flex">
<span>def <span class="ident">is_uchar</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
\isreal{is_type_uchar}</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_udt"><code class="name flex">
<span>def <span class="ident">is_udt</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
\isreal{is_type_struni}</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_uint"><code class="name flex">
<span>def <span class="ident">is_uint</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
\isreal{is_type_uint}</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_uint128"><code class="name flex">
<span>def <span class="ident">is_uint128</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
\isreal{is_type_uint128}</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_uint16"><code class="name flex">
<span>def <span class="ident">is_uint16</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
\isreal{is_type_uint16}</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_uint32"><code class="name flex">
<span>def <span class="ident">is_uint32</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
\isreal{is_type_uint32}</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_uint64"><code class="name flex">
<span>def <span class="ident">is_uint64</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
\isreal{is_type_uint64}</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_union"><code class="name flex">
<span>def <span class="ident">is_union</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
\isreal{is_type_union}</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_unknown"><code class="name flex">
<span>def <span class="ident">is_unknown</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
\isreal{is_type_unknown}</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_unsigned"><code class="name flex">
<span>def <span class="ident">is_unsigned</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is this an unsigned type?</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_user_cc"><code class="name flex">
<span>def <span class="ident">is_user_cc</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
\tinfocc{is_user_cc}</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_vararg_cc"><code class="name flex">
<span>def <span class="ident">is_vararg_cc</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
\tinfocc{is_vararg_cc}</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_varstruct"><code class="name flex">
<span>def <span class="ident">is_varstruct</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is a variable-size structure?</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_vftable"><code class="name flex">
<span>def <span class="ident">is_vftable</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is a vftable type?</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_void"><code class="name flex">
<span>def <span class="ident">is_void</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
\isreal{is_type_void}</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_volatile"><code class="name flex">
<span>def <span class="ident">is_volatile</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
\isreal{is_type_volatile}</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.is_well_defined"><code class="name flex">
<span>def <span class="ident">is_well_defined</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
!( 'empty()' ) &amp;&amp; !( 'is_decl_partial()' )</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.present"><code class="name flex">
<span>def <span class="ident">present</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is the type really present? (not a reference to a missing type, for
example)</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.read_bitfield_value"><code class="name flex">
<span>def <span class="ident">read_bitfield_value</span></span>(<span>self, *args) &#8209;&gt;&#160;uint64</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">read_bitfield_value(self, v, bitoff) -&gt; uint64</strong><div class="epy_nested">
v: uint64
bitoff: int</div>
</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.remove_ptr_or_array"><code class="name flex">
<span>def <span class="ident">remove_ptr_or_array</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Replace the current type with the ptr obj or array element. This
function performs one of the following conversions:type[] =&gt; typetype*
=&gt; type If the conversion is performed successfully, return true</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.requires_qualifier"><code class="name flex">
<span>def <span class="ident">requires_qualifier</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Requires full qualifier? (name is not unique)</div>
<div class="epy_par">
<strong class="epy_sig">requires_qualifier(self, name, offset) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">name</strong>: field name (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">offset</strong> (C++: uint64)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: if the name is not unique, returns true</div>
</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.serialize"><code class="name flex">
<span>def <span class="ident">serialize</span></span>(<span>self, *args) &#8209;&gt;&#160;PyObject&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Serialize 'tinfo_t' object into a type string.</div>
<div class="epy_par">
<strong class="epy_sig">serialize(self, sudt_flags=SUDT_FAST|SUDT_TRUNC) -&gt; PyObject *</strong><div class="epy_nested">
<strong class="epy_parameter">sudt_flags</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.set_attr"><code class="name flex">
<span>def <span class="ident">set_attr</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Set a type attribute. If necessary, a new typid will be created.</div>
<div class="epy_par">
<strong class="epy_sig">set_attr(self, ta, may_overwrite=True) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ta</strong> (C++: const
type_attr_t
&amp;)</div>
<div class="epy_nested">
<strong class="epy_parameter">may_overwrite</strong> (C++: bool)</div>
</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.set_attrs"><code class="name flex">
<span>def <span class="ident">set_attrs</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Set type attributes. If necessary, a new typid will be created. this
function modifies tav! (returns old attributes, if any)</div>
<div class="epy_par">
<strong class="epy_sig">set_attrs(self, tav) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">tav</strong> (C++: type_attrs_t
*)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: false: bad attributes</div>
</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.set_const"><code class="name flex">
<span>def <span class="ident">set_const</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">set_const(self)</strong></div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.set_declalign"><code class="name flex">
<span>def <span class="ident">set_declalign</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Set declared alignment of the type.</div>
<div class="epy_par">
<strong class="epy_sig">set_declalign(self, declalign) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">declalign</strong> (C++: uchar)</div>
</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.set_modifiers"><code class="name flex">
<span>def <span class="ident">set_modifiers</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">set_modifiers(self, mod)</strong><div class="epy_nested">
mod: type_t</div>
</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.set_named_type"><code class="name flex">
<span>def <span class="ident">set_named_type</span></span>(<span>self, *args) &#8209;&gt;&#160;tinfo_code_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">set_named_type(self, til, name, ntf_flags=0) -&gt; tinfo_code_t</strong><div class="epy_nested">
til: til_t *
name: char const *
ntf_flags: int</div>
</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.set_numbered_type"><code class="name flex">
<span>def <span class="ident">set_numbered_type</span></span>(<span>self, *args) &#8209;&gt;&#160;tinfo_code_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">set_numbered_type(self, til, ord, ntf_flags=0, name=None) -&gt; tinfo_code_t</strong><div class="epy_nested">
til: til_t *
ord: uint32
ntf_flags: int
name: char const *</div>
</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.set_symbol_type"><code class="name flex">
<span>def <span class="ident">set_symbol_type</span></span>(<span>self, *args) &#8209;&gt;&#160;tinfo_code_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">set_symbol_type(self, til, name, ntf_flags=0) -&gt; tinfo_code_t</strong><div class="epy_nested">
til: til_t *
name: char const *
ntf_flags: int</div>
</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.set_volatile"><code class="name flex">
<span>def <span class="ident">set_volatile</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">set_volatile(self)</strong></div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.swap"><code class="name flex">
<span>def <span class="ident">swap</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Assign this = r and r = this.</div>
<div class="epy_par">
<strong class="epy_sig">swap(self, r)</strong><div class="epy_nested">
<strong class="epy_parameter">r</strong> (C++: tinfo_t
&amp;)</div>
</div></div>
</dd>
<dt id="ida_typeinf.tinfo_t.write_bitfield_value"><code class="name flex">
<span>def <span class="ident">write_bitfield_value</span></span>(<span>self, *args) &#8209;&gt;&#160;uint64</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">write_bitfield_value(self, dst, v, bitoff) -&gt; uint64</strong><div class="epy_nested">
dst: uint64
v: uint64
bitoff: int</div>
</div></div>
</dd>
</dl>
</dd>
<dt id="ida_typeinf.tinfo_visitor_t"><code class="flex name class">
<span>class <span class="ident">tinfo_visitor_t</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ tinfo_visitor_t class.</div>
<div class="epy_par">
<strong class="epy_sig">__init__(self, s=0) -&gt; tinfo_visitor_t</strong><div class="epy_nested">
s: int</div>
</div></div>
<h3>Instance variables</h3>
<dl>
<dt id="ida_typeinf.tinfo_visitor_t.state"><code class="name">var <span class="ident">state</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">tinfo_visitor_t_state_get(self) -&gt; int</strong></div></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ida_typeinf.tinfo_visitor_t.apply_to"><code class="name flex">
<span>def <span class="ident">apply_to</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Call this function to initiate the traversal.</div>
<div class="epy_par">
<strong class="epy_sig">apply_to(self, tif, out=None, name=None, cmt=None) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">tif</strong> (C++: const
tinfo_t
&amp;)</div>
<div class="epy_nested">
<strong class="epy_parameter">out</strong> (C++: type_mods_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">name</strong> (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">cmt</strong> (C++: const char *)</div>
</div></div>
</dd>
<dt id="ida_typeinf.tinfo_visitor_t.prune_now"><code class="name flex">
<span>def <span class="ident">prune_now</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
To refuse to visit children of the current type, use this:</div></div>
</dd>
<dt id="ida_typeinf.tinfo_visitor_t.visit_type"><code class="name flex">
<span>def <span class="ident">visit_type</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Visit a subtype. this function must be implemented in the derived
class. it may optionally fill out with the new type info. this can be
used to modify types (in this case the 'out' argument of 'apply_to()'
may not be NULL) return 0 to continue the traversal. return !=0 to
stop the traversal.</div>
<div class="epy_par">
<strong class="epy_sig">visit_type(self, out, tif, name, cmt) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">out</strong> (C++: type_mods_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">tif</strong> (C++: const
tinfo_t
&amp;)</div>
<div class="epy_nested">
<strong class="epy_parameter">name</strong> (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">cmt</strong> (C++: const char *)</div>
</div></div>
</dd>
</dl>
</dd>
<dt id="ida_typeinf.type_attr_t"><code class="flex name class">
<span>class <span class="ident">type_attr_t</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ type_attr_t class.</div>
<div class="epy_par">
<strong class="epy_sig">__init__(self) -&gt; type_attr_t</strong></div></div>
<h3>Instance variables</h3>
<dl>
<dt id="ida_typeinf.type_attr_t.key"><code class="name">var <span class="ident">key</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">type_attr_t_key_get(self) -&gt; qstring *</strong></div></div>
</dd>
<dt id="ida_typeinf.type_attr_t.value"><code class="name">var <span class="ident">value</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">type_attr_t_value_get(self) -&gt; bytevec_t *</strong></div></div>
</dd>
</dl>
</dd>
<dt id="ida_typeinf.type_attrs_t"><code class="flex name class">
<span>class <span class="ident">type_attrs_t</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ qvector&lt; type_attr_t &gt; class.</div>
<div class="epy_par">
<strong class="epy_sig">__init__(self) -&gt; type_attrs_t</strong><div class="epy_nested">
x: qvector&lt; type_attr_t &gt; const &amp;</div>
</div></div>
<h3>Methods</h3>
<dl>
<dt id="ida_typeinf.type_attrs_t.at"><code class="name flex">
<span>def <span class="ident">at</span></span>(<span>self, *args) &#8209;&gt;&#160;<a title="ida_typeinf.type_attr_t" href="#ida_typeinf.type_attr_t">type_attr_t</a>&#160;const&#160;&amp;</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">at(self, _idx) -&gt; type_attr_t</strong><div class="epy_nested">
_idx: size_t</div>
</div></div>
</dd>
<dt id="ida_typeinf.type_attrs_t.back"><code class="name flex">
<span>def <span class="ident">back</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"/>
</dd>
<dt id="ida_typeinf.type_attrs_t.begin"><code class="name flex">
<span>def <span class="ident">begin</span></span>(<span>self, *args) &#8209;&gt;&#160;qvectortype_attr_t&#160;&gt;::const_iterator</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">begin(self) -&gt; type_attr_t</strong></div>
<div class="epy_par">
<strong class="epy_sig">begin(self) -&gt; type_attr_t</strong></div></div>
</dd>
<dt id="ida_typeinf.type_attrs_t.capacity"><code class="name flex">
<span>def <span class="ident">capacity</span></span>(<span>self, *args) &#8209;&gt;&#160;size_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">capacity(self) -&gt; size_t</strong></div></div>
</dd>
<dt id="ida_typeinf.type_attrs_t.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">clear(self)</strong></div></div>
</dd>
<dt id="ida_typeinf.type_attrs_t.empty"><code class="name flex">
<span>def <span class="ident">empty</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">empty(self) -&gt; bool</strong></div></div>
</dd>
<dt id="ida_typeinf.type_attrs_t.end"><code class="name flex">
<span>def <span class="ident">end</span></span>(<span>self, *args) &#8209;&gt;&#160;qvectortype_attr_t&#160;&gt;::const_iterator</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">end(self) -&gt; type_attr_t</strong></div>
<div class="epy_par">
<strong class="epy_sig">end(self) -&gt; type_attr_t</strong></div></div>
</dd>
<dt id="ida_typeinf.type_attrs_t.erase"><code class="name flex">
<span>def <span class="ident">erase</span></span>(<span>self, *args) &#8209;&gt;&#160;qvectortype_attr_t&#160;&gt;::iterator</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">erase(self, it) -&gt; type_attr_t</strong><div class="epy_nested">
it: qvector&lt; type_attr_t &gt;::iterator</div>
</div>
<div class="epy_par">
<strong class="epy_sig">erase(self, first, last) -&gt; type_attr_t</strong><div class="epy_nested">
first: qvector&lt; type_attr_t &gt;::iterator
last: qvector&lt; type_attr_t &gt;::iterator</div>
</div></div>
</dd>
<dt id="ida_typeinf.type_attrs_t.extract"><code class="name flex">
<span>def <span class="ident">extract</span></span>(<span>self, *args) &#8209;&gt;&#160;<a title="ida_typeinf.type_attr_t" href="#ida_typeinf.type_attr_t">type_attr_t</a>&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">extract(self) -&gt; type_attr_t</strong></div></div>
</dd>
<dt id="ida_typeinf.type_attrs_t.front"><code class="name flex">
<span>def <span class="ident">front</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"/>
</dd>
<dt id="ida_typeinf.type_attrs_t.grow"><code class="name flex">
<span>def <span class="ident">grow</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
grow(self, x=type_attr_t())<div class="epy_nested">
x: type_attr_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_typeinf.type_attrs_t.inject"><code class="name flex">
<span>def <span class="ident">inject</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">inject(self, s, len)</strong><div class="epy_nested">
s: type_attr_t *
len: size_t</div>
</div></div>
</dd>
<dt id="ida_typeinf.type_attrs_t.insert"><code class="name flex">
<span>def <span class="ident">insert</span></span>(<span>self, *args) &#8209;&gt;&#160;qvectortype_attr_t&#160;&gt;::iterator</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">insert(self, it, x) -&gt; type_attr_t</strong><div class="epy_nested">
it: qvector&lt; type_attr_t &gt;::iterator
x: type_attr_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_typeinf.type_attrs_t.pop_back"><code class="name flex">
<span>def <span class="ident">pop_back</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">pop_back(self)</strong></div></div>
</dd>
<dt id="ida_typeinf.type_attrs_t.push_back"><code class="name flex">
<span>def <span class="ident">push_back</span></span>(<span>self, *args) &#8209;&gt;&#160;<a title="ida_typeinf.type_attr_t" href="#ida_typeinf.type_attr_t">type_attr_t</a>&#160;&amp;</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">push_back(self, x)</strong><div class="epy_nested">
x: type_attr_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_typeinf.type_attrs_t.qclear"><code class="name flex">
<span>def <span class="ident">qclear</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">qclear(self)</strong></div></div>
</dd>
<dt id="ida_typeinf.type_attrs_t.reserve"><code class="name flex">
<span>def <span class="ident">reserve</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">reserve(self, cnt)</strong><div class="epy_nested">
cnt: size_t</div>
</div></div>
</dd>
<dt id="ida_typeinf.type_attrs_t.resize"><code class="name flex">
<span>def <span class="ident">resize</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">resize(self, _newsize, x)</strong><div class="epy_nested">
_newsize: size_t
x: type_attr_t const &amp;</div>
</div>
<div class="epy_par">
<strong class="epy_sig">resize(self, _newsize)</strong><div class="epy_nested">
_newsize: size_t</div>
</div></div>
</dd>
<dt id="ida_typeinf.type_attrs_t.size"><code class="name flex">
<span>def <span class="ident">size</span></span>(<span>self, *args) &#8209;&gt;&#160;size_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">size(self) -&gt; size_t</strong></div></div>
</dd>
<dt id="ida_typeinf.type_attrs_t.swap"><code class="name flex">
<span>def <span class="ident">swap</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">swap(self, r)</strong><div class="epy_nested">
r: qvector&lt; type_attr_t &gt; &amp;</div>
</div></div>
</dd>
<dt id="ida_typeinf.type_attrs_t.truncate"><code class="name flex">
<span>def <span class="ident">truncate</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">truncate(self)</strong></div></div>
</dd>
</dl>
</dd>
<dt id="ida_typeinf.type_mods_t"><code class="flex name class">
<span>class <span class="ident">type_mods_t</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ type_mods_t class.</div>
<div class="epy_par">
<strong class="epy_sig">__init__(self) -&gt; type_mods_t</strong></div></div>
<h3>Instance variables</h3>
<dl>
<dt id="ida_typeinf.type_mods_t.cmt"><code class="name">var <span class="ident">cmt</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">type_mods_t_cmt_get(self) -&gt; qstring *</strong></div></div>
</dd>
<dt id="ida_typeinf.type_mods_t.flags"><code class="name">var <span class="ident">flags</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">type_mods_t_flags_get(self) -&gt; int</strong></div></div>
</dd>
<dt id="ida_typeinf.type_mods_t.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">type_mods_t_name_get(self) -&gt; qstring *</strong></div></div>
</dd>
<dt id="ida_typeinf.type_mods_t.type"><code class="name">var <span class="ident">type</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">type_mods_t_type_get(self) -&gt; tinfo_t</strong></div></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ida_typeinf.type_mods_t.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">clear(self)</strong></div></div>
</dd>
<dt id="ida_typeinf.type_mods_t.has_cmt"><code class="name flex">
<span>def <span class="ident">has_cmt</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">has_cmt(self) -&gt; bool</strong></div></div>
</dd>
<dt id="ida_typeinf.type_mods_t.has_info"><code class="name flex">
<span>def <span class="ident">has_info</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">has_info(self) -&gt; bool</strong></div></div>
</dd>
<dt id="ida_typeinf.type_mods_t.has_name"><code class="name flex">
<span>def <span class="ident">has_name</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">has_name(self) -&gt; bool</strong></div></div>
</dd>
<dt id="ida_typeinf.type_mods_t.has_type"><code class="name flex">
<span>def <span class="ident">has_type</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">has_type(self) -&gt; bool</strong></div></div>
</dd>
<dt id="ida_typeinf.type_mods_t.set_new_cmt"><code class="name flex">
<span>def <span class="ident">set_new_cmt</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">set_new_cmt(self, c)</strong><div class="epy_nested">
<strong class="epy_parameter">c</strong> (C++: const
qstring
&amp;)</div>
</div></div>
</dd>
<dt id="ida_typeinf.type_mods_t.set_new_name"><code class="name flex">
<span>def <span class="ident">set_new_name</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">set_new_name(self, n)</strong><div class="epy_nested">
<strong class="epy_parameter">n</strong> (C++: const
qstring
&amp;)</div>
</div></div>
</dd>
<dt id="ida_typeinf.type_mods_t.set_new_type"><code class="name flex">
<span>def <span class="ident">set_new_type</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
The visit_type() function may optionally save the modified type info.
Use the following functions for that. The new name and comment will be
applied only if the current tinfo element has storage for them.</div>
<div class="epy_par">
<strong class="epy_sig">set_new_type(self, t)</strong><div class="epy_nested">
<strong class="epy_parameter">t</strong> (C++: const
tinfo_t
&amp;)</div>
</div></div>
</dd>
</dl>
</dd>
<dt id="ida_typeinf.typedef_type_data_t"><code class="flex name class">
<span>class <span class="ident">typedef_type_data_t</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ typedef_type_data_t class.</div>
<div class="epy_par">
<strong class="epy_sig">__init__(self, _til, _name, _resolve=False) -&gt; typedef_type_data_t</strong><div class="epy_nested">
_til: til_t const *
_name: char const *
_resolve: bool</div>
</div>
<div class="epy_par">
<strong class="epy_sig">__init__(self, _til, ord, _resolve=False) -&gt; typedef_type_data_t</strong><div class="epy_nested">
_til: til_t const *
ord: uint32
_resolve: bool</div>
</div></div>
<h3>Instance variables</h3>
<dl>
<dt id="ida_typeinf.typedef_type_data_t.is_ordref"><code class="name">var <span class="ident">is_ordref</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">typedef_type_data_t_is_ordref_get(self) -&gt; bool</strong></div></div>
</dd>
<dt id="ida_typeinf.typedef_type_data_t.resolve"><code class="name">var <span class="ident">resolve</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">typedef_type_data_t_resolve_get(self) -&gt; bool</strong></div></div>
</dd>
<dt id="ida_typeinf.typedef_type_data_t.til"><code class="name">var <span class="ident">til</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">typedef_type_data_t_til_get(self) -&gt; til_t</strong></div></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ida_typeinf.typedef_type_data_t.swap"><code class="name flex">
<span>def <span class="ident">swap</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">swap(self, r)</strong><div class="epy_nested">
<strong class="epy_parameter">r</strong> (C++: typedef_type_data_t
&amp;)</div>
</div></div>
</dd>
</dl>
</dd>
<dt id="ida_typeinf.udt_member_t"><code class="flex name class">
<span>class <span class="ident">udt_member_t</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ udt_member_t class.</div>
<div class="epy_par">
<strong class="epy_sig">__init__(self) -&gt; udt_member_t</strong></div></div>
<h3>Instance variables</h3>
<dl>
<dt id="ida_typeinf.udt_member_t.cmt"><code class="name">var <span class="ident">cmt</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">udt_member_t_cmt_get(self) -&gt; qstring *</strong></div></div>
</dd>
<dt id="ida_typeinf.udt_member_t.effalign"><code class="name">var <span class="ident">effalign</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">udt_member_t_effalign_get(self) -&gt; int</strong></div></div>
</dd>
<dt id="ida_typeinf.udt_member_t.fda"><code class="name">var <span class="ident">fda</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">udt_member_t_fda_get(self) -&gt; uchar</strong></div></div>
</dd>
<dt id="ida_typeinf.udt_member_t.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">udt_member_t_name_get(self) -&gt; qstring *</strong></div></div>
</dd>
<dt id="ida_typeinf.udt_member_t.offset"><code class="name">var <span class="ident">offset</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">udt_member_t_offset_get(self) -&gt; uint64</strong></div></div>
</dd>
<dt id="ida_typeinf.udt_member_t.size"><code class="name">var <span class="ident">size</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">udt_member_t_size_get(self) -&gt; uint64</strong></div></div>
</dd>
<dt id="ida_typeinf.udt_member_t.tafld_bits"><code class="name">var <span class="ident">tafld_bits</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">udt_member_t_tafld_bits_get(self) -&gt; uint32</strong></div></div>
</dd>
<dt id="ida_typeinf.udt_member_t.type"><code class="name">var <span class="ident">type</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">udt_member_t_type_get(self) -&gt; tinfo_t</strong></div></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ida_typeinf.udt_member_t.begin"><code class="name flex">
<span>def <span class="ident">begin</span></span>(<span>self, *args) &#8209;&gt;&#160;uint64</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">begin(self) -&gt; uint64</strong></div></div>
</dd>
<dt id="ida_typeinf.udt_member_t.clr_baseclass"><code class="name flex">
<span>def <span class="ident">clr_baseclass</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">clr_baseclass(self)</strong></div></div>
</dd>
<dt id="ida_typeinf.udt_member_t.clr_unaligned"><code class="name flex">
<span>def <span class="ident">clr_unaligned</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">clr_unaligned(self)</strong></div></div>
</dd>
<dt id="ida_typeinf.udt_member_t.clr_vftable"><code class="name flex">
<span>def <span class="ident">clr_vftable</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">clr_vftable(self)</strong></div></div>
</dd>
<dt id="ida_typeinf.udt_member_t.clr_virtbase"><code class="name flex">
<span>def <span class="ident">clr_virtbase</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">clr_virtbase(self)</strong></div></div>
</dd>
<dt id="ida_typeinf.udt_member_t.end"><code class="name flex">
<span>def <span class="ident">end</span></span>(<span>self, *args) &#8209;&gt;&#160;uint64</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">end(self) -&gt; uint64</strong></div></div>
</dd>
<dt id="ida_typeinf.udt_member_t.is_anonymous_udm"><code class="name flex">
<span>def <span class="ident">is_anonymous_udm</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">is_anonymous_udm(self) -&gt; bool</strong></div></div>
</dd>
<dt id="ida_typeinf.udt_member_t.is_baseclass"><code class="name flex">
<span>def <span class="ident">is_baseclass</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">is_baseclass(self) -&gt; bool</strong></div></div>
</dd>
<dt id="ida_typeinf.udt_member_t.is_bitfield"><code class="name flex">
<span>def <span class="ident">is_bitfield</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">is_bitfield(self) -&gt; bool</strong></div></div>
</dd>
<dt id="ida_typeinf.udt_member_t.is_unaligned"><code class="name flex">
<span>def <span class="ident">is_unaligned</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">is_unaligned(self) -&gt; bool</strong></div></div>
</dd>
<dt id="ida_typeinf.udt_member_t.is_vftable"><code class="name flex">
<span>def <span class="ident">is_vftable</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">is_vftable(self) -&gt; bool</strong></div></div>
</dd>
<dt id="ida_typeinf.udt_member_t.is_virtbase"><code class="name flex">
<span>def <span class="ident">is_virtbase</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">is_virtbase(self) -&gt; bool</strong></div></div>
</dd>
<dt id="ida_typeinf.udt_member_t.is_zero_bitfield"><code class="name flex">
<span>def <span class="ident">is_zero_bitfield</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">is_zero_bitfield(self) -&gt; bool</strong></div></div>
</dd>
<dt id="ida_typeinf.udt_member_t.set_baseclass"><code class="name flex">
<span>def <span class="ident">set_baseclass</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">set_baseclass(self)</strong></div></div>
</dd>
<dt id="ida_typeinf.udt_member_t.set_unaligned"><code class="name flex">
<span>def <span class="ident">set_unaligned</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">set_unaligned(self)</strong></div></div>
</dd>
<dt id="ida_typeinf.udt_member_t.set_vftable"><code class="name flex">
<span>def <span class="ident">set_vftable</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">set_vftable(self)</strong></div></div>
</dd>
<dt id="ida_typeinf.udt_member_t.set_virtbase"><code class="name flex">
<span>def <span class="ident">set_virtbase</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">set_virtbase(self)</strong></div></div>
</dd>
<dt id="ida_typeinf.udt_member_t.swap"><code class="name flex">
<span>def <span class="ident">swap</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">swap(self, r)</strong><div class="epy_nested">
<strong class="epy_parameter">r</strong> (C++: udt_member_t
&amp;)</div>
</div></div>
</dd>
</dl>
</dd>
<dt id="ida_typeinf.udt_type_data_t"><code class="flex name class">
<span>class <span class="ident">udt_type_data_t</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ udt_type_data_t class.</div>
<div class="epy_par">
<strong class="epy_sig">__init__(self) -&gt; udt_type_data_t</strong></div></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="ida_typeinf.udtmembervec_t" href="#ida_typeinf.udtmembervec_t">udtmembervec_t</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="ida_typeinf.udt_type_data_t.effalign"><code class="name">var <span class="ident">effalign</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">udt_type_data_t_effalign_get(self) -&gt; uint32</strong></div></div>
</dd>
<dt id="ida_typeinf.udt_type_data_t.is_union"><code class="name">var <span class="ident">is_union</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">udt_type_data_t_is_union_get(self) -&gt; bool</strong></div></div>
</dd>
<dt id="ida_typeinf.udt_type_data_t.pack"><code class="name">var <span class="ident">pack</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">udt_type_data_t_pack_get(self) -&gt; uchar</strong></div></div>
</dd>
<dt id="ida_typeinf.udt_type_data_t.sda"><code class="name">var <span class="ident">sda</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">udt_type_data_t_sda_get(self) -&gt; uchar</strong></div></div>
</dd>
<dt id="ida_typeinf.udt_type_data_t.taudt_bits"><code class="name">var <span class="ident">taudt_bits</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">udt_type_data_t_taudt_bits_get(self) -&gt; uint32</strong></div></div>
</dd>
<dt id="ida_typeinf.udt_type_data_t.total_size"><code class="name">var <span class="ident">total_size</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">udt_type_data_t_total_size_get(self) -&gt; size_t</strong></div></div>
</dd>
<dt id="ida_typeinf.udt_type_data_t.unpadded_size"><code class="name">var <span class="ident">unpadded_size</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">udt_type_data_t_unpadded_size_get(self) -&gt; size_t</strong></div></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ida_typeinf.udt_type_data_t.is_cppobj"><code class="name flex">
<span>def <span class="ident">is_cppobj</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">is_cppobj(self) -&gt; bool</strong></div></div>
</dd>
<dt id="ida_typeinf.udt_type_data_t.is_last_baseclass"><code class="name flex">
<span>def <span class="ident">is_last_baseclass</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">is_last_baseclass(self, idx) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">idx</strong> (C++: size_t)</div>
</div></div>
</dd>
<dt id="ida_typeinf.udt_type_data_t.is_msstruct"><code class="name flex">
<span>def <span class="ident">is_msstruct</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">is_msstruct(self) -&gt; bool</strong></div></div>
</dd>
<dt id="ida_typeinf.udt_type_data_t.is_unaligned"><code class="name flex">
<span>def <span class="ident">is_unaligned</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">is_unaligned(self) -&gt; bool</strong></div></div>
</dd>
<dt id="ida_typeinf.udt_type_data_t.is_vftable"><code class="name flex">
<span>def <span class="ident">is_vftable</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">is_vftable(self) -&gt; bool</strong></div></div>
</dd>
<dt id="ida_typeinf.udt_type_data_t.set_vftable"><code class="name flex">
<span>def <span class="ident">set_vftable</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">set_vftable(self)</strong></div></div>
</dd>
<dt id="ida_typeinf.udt_type_data_t.swap"><code class="name flex">
<span>def <span class="ident">swap</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">swap(self, r)</strong><div class="epy_nested">
<strong class="epy_parameter">r</strong> (C++: udt_type_data_t
&amp;)</div>
</div></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="ida_typeinf.udtmembervec_t" href="#ida_typeinf.udtmembervec_t">udtmembervec_t</a></b></code>:
<ul class="hlist">
<li><code><a title="ida_typeinf.udtmembervec_t.add_unique" href="#ida_typeinf.udtmembervec_t.add_unique">add_unique</a></code></li>
<li><code><a title="ida_typeinf.udtmembervec_t.at" href="#ida_typeinf.udtmembervec_t.at">at</a></code></li>
<li><code><a title="ida_typeinf.udtmembervec_t.begin" href="#ida_typeinf.udtmembervec_t.begin">begin</a></code></li>
<li><code><a title="ida_typeinf.udtmembervec_t.capacity" href="#ida_typeinf.udtmembervec_t.capacity">capacity</a></code></li>
<li><code><a title="ida_typeinf.udtmembervec_t.clear" href="#ida_typeinf.udtmembervec_t.clear">clear</a></code></li>
<li><code><a title="ida_typeinf.udtmembervec_t.empty" href="#ida_typeinf.udtmembervec_t.empty">empty</a></code></li>
<li><code><a title="ida_typeinf.udtmembervec_t.end" href="#ida_typeinf.udtmembervec_t.end">end</a></code></li>
<li><code><a title="ida_typeinf.udtmembervec_t.erase" href="#ida_typeinf.udtmembervec_t.erase">erase</a></code></li>
<li><code><a title="ida_typeinf.udtmembervec_t.extract" href="#ida_typeinf.udtmembervec_t.extract">extract</a></code></li>
<li><code><a title="ida_typeinf.udtmembervec_t.find" href="#ida_typeinf.udtmembervec_t.find">find</a></code></li>
<li><code><a title="ida_typeinf.udtmembervec_t.grow" href="#ida_typeinf.udtmembervec_t.grow">grow</a></code></li>
<li><code><a title="ida_typeinf.udtmembervec_t.has" href="#ida_typeinf.udtmembervec_t.has">has</a></code></li>
<li><code><a title="ida_typeinf.udtmembervec_t.inject" href="#ida_typeinf.udtmembervec_t.inject">inject</a></code></li>
<li><code><a title="ida_typeinf.udtmembervec_t.insert" href="#ida_typeinf.udtmembervec_t.insert">insert</a></code></li>
<li><code><a title="ida_typeinf.udtmembervec_t.pop_back" href="#ida_typeinf.udtmembervec_t.pop_back">pop_back</a></code></li>
<li><code><a title="ida_typeinf.udtmembervec_t.push_back" href="#ida_typeinf.udtmembervec_t.push_back">push_back</a></code></li>
<li><code><a title="ida_typeinf.udtmembervec_t.qclear" href="#ida_typeinf.udtmembervec_t.qclear">qclear</a></code></li>
<li><code><a title="ida_typeinf.udtmembervec_t.reserve" href="#ida_typeinf.udtmembervec_t.reserve">reserve</a></code></li>
<li><code><a title="ida_typeinf.udtmembervec_t.resize" href="#ida_typeinf.udtmembervec_t.resize">resize</a></code></li>
<li><code><a title="ida_typeinf.udtmembervec_t.size" href="#ida_typeinf.udtmembervec_t.size">size</a></code></li>
<li><code><a title="ida_typeinf.udtmembervec_t.truncate" href="#ida_typeinf.udtmembervec_t.truncate">truncate</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="ida_typeinf.udtmembervec_t"><code class="flex name class">
<span>class <span class="ident">udtmembervec_t</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ qvector&lt; udt_member_t &gt; class.</div>
<div class="epy_par">
<strong class="epy_sig">__init__(self) -&gt; udtmembervec_t</strong><div class="epy_nested">
x: qvector&lt; udt_member_t &gt; const &amp;</div>
</div></div>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="ida_typeinf.udt_type_data_t" href="#ida_typeinf.udt_type_data_t">udt_type_data_t</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="ida_typeinf.udtmembervec_t.add_unique"><code class="name flex">
<span>def <span class="ident">add_unique</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">add_unique(self, x) -&gt; bool</strong><div class="epy_nested">
x: udt_member_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_typeinf.udtmembervec_t.at"><code class="name flex">
<span>def <span class="ident">at</span></span>(<span>self, *args) &#8209;&gt;&#160;<a title="ida_typeinf.udt_member_t" href="#ida_typeinf.udt_member_t">udt_member_t</a>&#160;const&#160;&amp;</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">at(self, _idx) -&gt; udt_member_t</strong><div class="epy_nested">
_idx: size_t</div>
</div></div>
</dd>
<dt id="ida_typeinf.udtmembervec_t.back"><code class="name flex">
<span>def <span class="ident">back</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"/>
</dd>
<dt id="ida_typeinf.udtmembervec_t.begin"><code class="name flex">
<span>def <span class="ident">begin</span></span>(<span>self, *args) &#8209;&gt;&#160;qvectorudt_member_t&#160;&gt;::const_iterator</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">begin(self) -&gt; udt_member_t</strong></div>
<div class="epy_par">
<strong class="epy_sig">begin(self) -&gt; udt_member_t</strong></div></div>
</dd>
<dt id="ida_typeinf.udtmembervec_t.capacity"><code class="name flex">
<span>def <span class="ident">capacity</span></span>(<span>self, *args) &#8209;&gt;&#160;size_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">capacity(self) -&gt; size_t</strong></div></div>
</dd>
<dt id="ida_typeinf.udtmembervec_t.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">clear(self)</strong></div></div>
</dd>
<dt id="ida_typeinf.udtmembervec_t.empty"><code class="name flex">
<span>def <span class="ident">empty</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">empty(self) -&gt; bool</strong></div></div>
</dd>
<dt id="ida_typeinf.udtmembervec_t.end"><code class="name flex">
<span>def <span class="ident">end</span></span>(<span>self, *args) &#8209;&gt;&#160;qvectorudt_member_t&#160;&gt;::const_iterator</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">end(self) -&gt; udt_member_t</strong></div>
<div class="epy_par">
<strong class="epy_sig">end(self) -&gt; udt_member_t</strong></div></div>
</dd>
<dt id="ida_typeinf.udtmembervec_t.erase"><code class="name flex">
<span>def <span class="ident">erase</span></span>(<span>self, *args) &#8209;&gt;&#160;qvectorudt_member_t&#160;&gt;::iterator</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">erase(self, it) -&gt; udt_member_t</strong><div class="epy_nested">
it: qvector&lt; udt_member_t &gt;::iterator</div>
</div>
<div class="epy_par">
<strong class="epy_sig">erase(self, first, last) -&gt; udt_member_t</strong><div class="epy_nested">
first: qvector&lt; udt_member_t &gt;::iterator
last: qvector&lt; udt_member_t &gt;::iterator</div>
</div></div>
</dd>
<dt id="ida_typeinf.udtmembervec_t.extract"><code class="name flex">
<span>def <span class="ident">extract</span></span>(<span>self, *args) &#8209;&gt;&#160;<a title="ida_typeinf.udt_member_t" href="#ida_typeinf.udt_member_t">udt_member_t</a>&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">extract(self) -&gt; udt_member_t</strong></div></div>
</dd>
<dt id="ida_typeinf.udtmembervec_t.find"><code class="name flex">
<span>def <span class="ident">find</span></span>(<span>self, *args) &#8209;&gt;&#160;qvectorudt_member_t&#160;&gt;::const_iterator</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">find(self, x) -&gt; udt_member_t</strong><div class="epy_nested">
x: udt_member_t const &amp;</div>
</div>
<div class="epy_par">
<strong class="epy_sig">find(self, x) -&gt; udt_member_t</strong><div class="epy_nested">
x: udt_member_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_typeinf.udtmembervec_t.front"><code class="name flex">
<span>def <span class="ident">front</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"/>
</dd>
<dt id="ida_typeinf.udtmembervec_t.grow"><code class="name flex">
<span>def <span class="ident">grow</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
grow(self, x=udt_member_t())<div class="epy_nested">
x: udt_member_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_typeinf.udtmembervec_t.has"><code class="name flex">
<span>def <span class="ident">has</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">has(self, x) -&gt; bool</strong><div class="epy_nested">
x: udt_member_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_typeinf.udtmembervec_t.inject"><code class="name flex">
<span>def <span class="ident">inject</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">inject(self, s, len)</strong><div class="epy_nested">
s: udt_member_t *
len: size_t</div>
</div></div>
</dd>
<dt id="ida_typeinf.udtmembervec_t.insert"><code class="name flex">
<span>def <span class="ident">insert</span></span>(<span>self, *args) &#8209;&gt;&#160;qvectorudt_member_t&#160;&gt;::iterator</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">insert(self, it, x) -&gt; udt_member_t</strong><div class="epy_nested">
it: qvector&lt; udt_member_t &gt;::iterator
x: udt_member_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_typeinf.udtmembervec_t.pop_back"><code class="name flex">
<span>def <span class="ident">pop_back</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">pop_back(self)</strong></div></div>
</dd>
<dt id="ida_typeinf.udtmembervec_t.push_back"><code class="name flex">
<span>def <span class="ident">push_back</span></span>(<span>self, *args) &#8209;&gt;&#160;<a title="ida_typeinf.udt_member_t" href="#ida_typeinf.udt_member_t">udt_member_t</a>&#160;&amp;</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">push_back(self, x)</strong><div class="epy_nested">
x: udt_member_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_typeinf.udtmembervec_t.qclear"><code class="name flex">
<span>def <span class="ident">qclear</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">qclear(self)</strong></div></div>
</dd>
<dt id="ida_typeinf.udtmembervec_t.reserve"><code class="name flex">
<span>def <span class="ident">reserve</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">reserve(self, cnt)</strong><div class="epy_nested">
cnt: size_t</div>
</div></div>
</dd>
<dt id="ida_typeinf.udtmembervec_t.resize"><code class="name flex">
<span>def <span class="ident">resize</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">resize(self, _newsize, x)</strong><div class="epy_nested">
_newsize: size_t
x: udt_member_t const &amp;</div>
</div>
<div class="epy_par">
<strong class="epy_sig">resize(self, _newsize)</strong><div class="epy_nested">
_newsize: size_t</div>
</div></div>
</dd>
<dt id="ida_typeinf.udtmembervec_t.size"><code class="name flex">
<span>def <span class="ident">size</span></span>(<span>self, *args) &#8209;&gt;&#160;size_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">size(self) -&gt; size_t</strong></div></div>
</dd>
<dt id="ida_typeinf.udtmembervec_t.swap"><code class="name flex">
<span>def <span class="ident">swap</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">swap(self, r)</strong><div class="epy_nested">
r: qvector&lt; udt_member_t &gt; &amp;</div>
</div></div>
</dd>
<dt id="ida_typeinf.udtmembervec_t.truncate"><code class="name flex">
<span>def <span class="ident">truncate</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">truncate(self)</strong></div></div>
</dd>
</dl>
</dd>
<dt id="ida_typeinf.valstr_t"><code class="flex name class">
<span>class <span class="ident">valstr_t</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ valstr_t class.</div>
<div class="epy_par">
<strong class="epy_sig">__init__(self) -&gt; valstr_t</strong></div></div>
<h3>Instance variables</h3>
<dl>
<dt id="ida_typeinf.valstr_t.info"><code class="name">var <span class="ident">info</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">valstr_t_info_get(self) -&gt; valinfo_t *</strong></div></div>
</dd>
<dt id="ida_typeinf.valstr_t.length"><code class="name">var <span class="ident">length</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">valstr_t_length_get(self) -&gt; size_t</strong></div></div>
</dd>
<dt id="ida_typeinf.valstr_t.members"><code class="name">var <span class="ident">members</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">valstr_t_members_get(self) -&gt; valstrs_t</strong></div></div>
</dd>
<dt id="ida_typeinf.valstr_t.oneline"><code class="name">var <span class="ident">oneline</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">valstr_t_oneline_get(self) -&gt; qstring *</strong></div></div>
</dd>
<dt id="ida_typeinf.valstr_t.props"><code class="name">var <span class="ident">props</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">valstr_t_props_get(self) -&gt; int</strong></div></div>
</dd>
</dl>
</dd>
<dt id="ida_typeinf.valstrs_t"><code class="flex name class">
<span>class <span class="ident">valstrs_t</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ valstrs_t class.</div>
<div class="epy_par">
<strong class="epy_sig">__init__(self) -&gt; valstrs_t</strong></div></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="ida_typeinf.valstrvec_t" href="#ida_typeinf.valstrvec_t">valstrvec_t</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="ida_typeinf.valstrvec_t" href="#ida_typeinf.valstrvec_t">valstrvec_t</a></b></code>:
<ul class="hlist">
<li><code><a title="ida_typeinf.valstrvec_t.at" href="#ida_typeinf.valstrvec_t.at">at</a></code></li>
<li><code><a title="ida_typeinf.valstrvec_t.begin" href="#ida_typeinf.valstrvec_t.begin">begin</a></code></li>
<li><code><a title="ida_typeinf.valstrvec_t.capacity" href="#ida_typeinf.valstrvec_t.capacity">capacity</a></code></li>
<li><code><a title="ida_typeinf.valstrvec_t.clear" href="#ida_typeinf.valstrvec_t.clear">clear</a></code></li>
<li><code><a title="ida_typeinf.valstrvec_t.empty" href="#ida_typeinf.valstrvec_t.empty">empty</a></code></li>
<li><code><a title="ida_typeinf.valstrvec_t.end" href="#ida_typeinf.valstrvec_t.end">end</a></code></li>
<li><code><a title="ida_typeinf.valstrvec_t.erase" href="#ida_typeinf.valstrvec_t.erase">erase</a></code></li>
<li><code><a title="ida_typeinf.valstrvec_t.extract" href="#ida_typeinf.valstrvec_t.extract">extract</a></code></li>
<li><code><a title="ida_typeinf.valstrvec_t.grow" href="#ida_typeinf.valstrvec_t.grow">grow</a></code></li>
<li><code><a title="ida_typeinf.valstrvec_t.inject" href="#ida_typeinf.valstrvec_t.inject">inject</a></code></li>
<li><code><a title="ida_typeinf.valstrvec_t.insert" href="#ida_typeinf.valstrvec_t.insert">insert</a></code></li>
<li><code><a title="ida_typeinf.valstrvec_t.pop_back" href="#ida_typeinf.valstrvec_t.pop_back">pop_back</a></code></li>
<li><code><a title="ida_typeinf.valstrvec_t.push_back" href="#ida_typeinf.valstrvec_t.push_back">push_back</a></code></li>
<li><code><a title="ida_typeinf.valstrvec_t.qclear" href="#ida_typeinf.valstrvec_t.qclear">qclear</a></code></li>
<li><code><a title="ida_typeinf.valstrvec_t.reserve" href="#ida_typeinf.valstrvec_t.reserve">reserve</a></code></li>
<li><code><a title="ida_typeinf.valstrvec_t.resize" href="#ida_typeinf.valstrvec_t.resize">resize</a></code></li>
<li><code><a title="ida_typeinf.valstrvec_t.size" href="#ida_typeinf.valstrvec_t.size">size</a></code></li>
<li><code><a title="ida_typeinf.valstrvec_t.swap" href="#ida_typeinf.valstrvec_t.swap">swap</a></code></li>
<li><code><a title="ida_typeinf.valstrvec_t.truncate" href="#ida_typeinf.valstrvec_t.truncate">truncate</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="ida_typeinf.valstrvec_t"><code class="flex name class">
<span>class <span class="ident">valstrvec_t</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ qvector&lt; valstr_t &gt; class.</div>
<div class="epy_par">
<strong class="epy_sig">__init__(self) -&gt; valstrvec_t</strong><div class="epy_nested">
x: qvector&lt; valstr_t &gt; const &amp;</div>
</div></div>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="ida_typeinf.valstrs_t" href="#ida_typeinf.valstrs_t">valstrs_t</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="ida_typeinf.valstrvec_t.at"><code class="name flex">
<span>def <span class="ident">at</span></span>(<span>self, *args) &#8209;&gt;&#160;<a title="ida_typeinf.valstr_t" href="#ida_typeinf.valstr_t">valstr_t</a>&#160;const&#160;&amp;</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">at(self, _idx) -&gt; valstr_t</strong><div class="epy_nested">
_idx: size_t</div>
</div></div>
</dd>
<dt id="ida_typeinf.valstrvec_t.back"><code class="name flex">
<span>def <span class="ident">back</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"/>
</dd>
<dt id="ida_typeinf.valstrvec_t.begin"><code class="name flex">
<span>def <span class="ident">begin</span></span>(<span>self, *args) &#8209;&gt;&#160;qvectorvalstr_t&#160;&gt;::const_iterator</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">begin(self) -&gt; valstr_t</strong></div>
<div class="epy_par">
<strong class="epy_sig">begin(self) -&gt; valstr_t</strong></div></div>
</dd>
<dt id="ida_typeinf.valstrvec_t.capacity"><code class="name flex">
<span>def <span class="ident">capacity</span></span>(<span>self, *args) &#8209;&gt;&#160;size_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">capacity(self) -&gt; size_t</strong></div></div>
</dd>
<dt id="ida_typeinf.valstrvec_t.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">clear(self)</strong></div></div>
</dd>
<dt id="ida_typeinf.valstrvec_t.empty"><code class="name flex">
<span>def <span class="ident">empty</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">empty(self) -&gt; bool</strong></div></div>
</dd>
<dt id="ida_typeinf.valstrvec_t.end"><code class="name flex">
<span>def <span class="ident">end</span></span>(<span>self, *args) &#8209;&gt;&#160;qvectorvalstr_t&#160;&gt;::const_iterator</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">end(self) -&gt; valstr_t</strong></div>
<div class="epy_par">
<strong class="epy_sig">end(self) -&gt; valstr_t</strong></div></div>
</dd>
<dt id="ida_typeinf.valstrvec_t.erase"><code class="name flex">
<span>def <span class="ident">erase</span></span>(<span>self, *args) &#8209;&gt;&#160;qvectorvalstr_t&#160;&gt;::iterator</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">erase(self, it) -&gt; valstr_t</strong><div class="epy_nested">
it: qvector&lt; valstr_t &gt;::iterator</div>
</div>
<div class="epy_par">
<strong class="epy_sig">erase(self, first, last) -&gt; valstr_t</strong><div class="epy_nested">
first: qvector&lt; valstr_t &gt;::iterator
last: qvector&lt; valstr_t &gt;::iterator</div>
</div></div>
</dd>
<dt id="ida_typeinf.valstrvec_t.extract"><code class="name flex">
<span>def <span class="ident">extract</span></span>(<span>self, *args) &#8209;&gt;&#160;<a title="ida_typeinf.valstr_t" href="#ida_typeinf.valstr_t">valstr_t</a>&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">extract(self) -&gt; valstr_t</strong></div></div>
</dd>
<dt id="ida_typeinf.valstrvec_t.front"><code class="name flex">
<span>def <span class="ident">front</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"/>
</dd>
<dt id="ida_typeinf.valstrvec_t.grow"><code class="name flex">
<span>def <span class="ident">grow</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
grow(self, x=valstr_t())<div class="epy_nested">
x: valstr_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_typeinf.valstrvec_t.inject"><code class="name flex">
<span>def <span class="ident">inject</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">inject(self, s, len)</strong><div class="epy_nested">
s: valstr_t *
len: size_t</div>
</div></div>
</dd>
<dt id="ida_typeinf.valstrvec_t.insert"><code class="name flex">
<span>def <span class="ident">insert</span></span>(<span>self, *args) &#8209;&gt;&#160;qvectorvalstr_t&#160;&gt;::iterator</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">insert(self, it, x) -&gt; valstr_t</strong><div class="epy_nested">
it: qvector&lt; valstr_t &gt;::iterator
x: valstr_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_typeinf.valstrvec_t.pop_back"><code class="name flex">
<span>def <span class="ident">pop_back</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">pop_back(self)</strong></div></div>
</dd>
<dt id="ida_typeinf.valstrvec_t.push_back"><code class="name flex">
<span>def <span class="ident">push_back</span></span>(<span>self, *args) &#8209;&gt;&#160;<a title="ida_typeinf.valstr_t" href="#ida_typeinf.valstr_t">valstr_t</a>&#160;&amp;</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">push_back(self, x)</strong><div class="epy_nested">
x: valstr_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_typeinf.valstrvec_t.qclear"><code class="name flex">
<span>def <span class="ident">qclear</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">qclear(self)</strong></div></div>
</dd>
<dt id="ida_typeinf.valstrvec_t.reserve"><code class="name flex">
<span>def <span class="ident">reserve</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">reserve(self, cnt)</strong><div class="epy_nested">
cnt: size_t</div>
</div></div>
</dd>
<dt id="ida_typeinf.valstrvec_t.resize"><code class="name flex">
<span>def <span class="ident">resize</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">resize(self, _newsize, x)</strong><div class="epy_nested">
_newsize: size_t
x: valstr_t const &amp;</div>
</div>
<div class="epy_par">
<strong class="epy_sig">resize(self, _newsize)</strong><div class="epy_nested">
_newsize: size_t</div>
</div></div>
</dd>
<dt id="ida_typeinf.valstrvec_t.size"><code class="name flex">
<span>def <span class="ident">size</span></span>(<span>self, *args) &#8209;&gt;&#160;size_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">size(self) -&gt; size_t</strong></div></div>
</dd>
<dt id="ida_typeinf.valstrvec_t.swap"><code class="name flex">
<span>def <span class="ident">swap</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">swap(self, r)</strong><div class="epy_nested">
r: qvector&lt; valstr_t &gt; &amp;</div>
</div></div>
</dd>
<dt id="ida_typeinf.valstrvec_t.truncate"><code class="name flex">
<span>def <span class="ident">truncate</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">truncate(self)</strong></div></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
</main>
<footer id="footer">
<p>Copyright (c) 2021 Hex-Rays SA. <a href="/terms_of_use.shtml">Terms of use</a> and <a href="/privacy_policy.shtml">privacy policy</a>.</p>
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> ???</a>.</p>
</footer>
</body>
</html>