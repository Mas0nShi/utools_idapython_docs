<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1"/>
<meta name="generator" content="pdoc ???"/>
<title>ida_dbg API documentation</title>
<meta name="description" content="IDA Plugin SDK API wrapper: dbg"/>
<link rel="preload stylesheet" as="style" href="assets/sanitize.min.css"/>
<link rel="preload stylesheet" as="style" href="assets/typography.min.css"/>
<link rel="stylesheet preload" as="style" href="assets/github.min.css"/>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar &amp;gt; *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl &amp;gt; dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:-webkit-fill-available}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name &amp;gt; span:first-child{white-space:nowrap}.name.class &amp;gt; span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary &amp;gt; *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content: ',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width: 700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content padding:3em 4em;border-left:1px solid #ddd;lid #ddd;}pre code{font-size:1em}.item .name{font-size:1em}main{/* display:flex; *//* flex-direction:row-reverse; *//* justify-content:flex-end; */}.toc ul ul,#index ul{padding-left:1.5em}.toc &gt; ul &gt; li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer="defer" src="assets/highlight.min.js"/>
<script>window.addEventListener('DOMContentLoaded', () =&gt; hljs.initHighlighting())</script>
<style>
#section-intro .epy_par
{
margin-top: 18px;
}
</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ida_dbg</code></h1>
</header>
<section id="section-intro">
<div class="epy_par">
IDA Plugin SDK API wrapper: dbg</div>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="ida_dbg.BKPT_ACTIVE"><code class="name">var <span class="ident">BKPT_ACTIVE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
active?</div></div>
</dd>
<dt id="ida_dbg.BKPT_BADBPT"><code class="name">var <span class="ident">BKPT_BADBPT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
failed to write the bpt to the process memory (at least one location)</div></div>
</dd>
<dt id="ida_dbg.BKPT_CNDREADY"><code class="name">var <span class="ident">BKPT_CNDREADY</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
condition has been compiled</div></div>
</dd>
<dt id="ida_dbg.BKPT_FAKEPEND"><code class="name">var <span class="ident">BKPT_FAKEPEND</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
fake pending bpt: it is inactive but another bpt of the same type is
active at the same address(es)</div></div>
</dd>
<dt id="ida_dbg.BKPT_LISTBPT"><code class="name">var <span class="ident">BKPT_LISTBPT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
include in bpt list (user-defined bpt)</div></div>
</dd>
<dt id="ida_dbg.BKPT_PAGE"><code class="name">var <span class="ident">BKPT_PAGE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
written to the process as a page bpt. is available only after writing
the bpt to the process.</div></div>
</dd>
<dt id="ida_dbg.BKPT_PARTIAL"><code class="name">var <span class="ident">BKPT_PARTIAL</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
partially active? (some locations were not written yet)</div></div>
</dd>
<dt id="ida_dbg.BKPT_TRACE"><code class="name">var <span class="ident">BKPT_TRACE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
trace bpt; should not be deleted when the process gets suspended</div></div>
</dd>
<dt id="ida_dbg.BPLT_ABS"><code class="name">var <span class="ident">BPLT_ABS</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BPLT_ABS = 0</div></div>
</dd>
<dt id="ida_dbg.BPLT_REL"><code class="name">var <span class="ident">BPLT_REL</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BPLT_REL = 1</div></div>
</dd>
<dt id="ida_dbg.BPLT_SRC"><code class="name">var <span class="ident">BPLT_SRC</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BPLT_SRC = 3</div></div>
</dd>
<dt id="ida_dbg.BPLT_SYM"><code class="name">var <span class="ident">BPLT_SYM</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BPLT_SYM = 2</div></div>
</dd>
<dt id="ida_dbg.BPTCK_ACT"><code class="name">var <span class="ident">BPTCK_ACT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
breakpoint is active (written to the process)</div></div>
</dd>
<dt id="ida_dbg.BPTCK_NO"><code class="name">var <span class="ident">BPTCK_NO</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
breakpoint is disabled</div></div>
</dd>
<dt id="ida_dbg.BPTCK_NONE"><code class="name">var <span class="ident">BPTCK_NONE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
breakpoint does not exist</div></div>
</dd>
<dt id="ida_dbg.BPTCK_YES"><code class="name">var <span class="ident">BPTCK_YES</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
breakpoint is enabled</div></div>
</dd>
<dt id="ida_dbg.BPTEV_ADDED"><code class="name">var <span class="ident">BPTEV_ADDED</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Breakpoint has been added.</div></div>
</dd>
<dt id="ida_dbg.BPTEV_CHANGED"><code class="name">var <span class="ident">BPTEV_CHANGED</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Breakpoint has been modified.</div></div>
</dd>
<dt id="ida_dbg.BPTEV_REMOVED"><code class="name">var <span class="ident">BPTEV_REMOVED</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Breakpoint has been removed.</div></div>
</dd>
<dt id="ida_dbg.BPT_BRK"><code class="name">var <span class="ident">BPT_BRK</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
suspend execution upon hit</div></div>
</dd>
<dt id="ida_dbg.BPT_ELANG_MASK"><code class="name">var <span class="ident">BPT_ELANG_MASK</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BPT_ELANG_MASK = 4026531840</div></div>
</dd>
<dt id="ida_dbg.BPT_ELANG_SHIFT"><code class="name">var <span class="ident">BPT_ELANG_SHIFT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
index of the extlang (scripting language) of the condition</div></div>
</dd>
<dt id="ida_dbg.BPT_ENABLED"><code class="name">var <span class="ident">BPT_ENABLED</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
enabled?</div></div>
</dd>
<dt id="ida_dbg.BPT_LOWCND"><code class="name">var <span class="ident">BPT_LOWCND</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
condition is calculated at low level (on the server side)</div></div>
</dd>
<dt id="ida_dbg.BPT_TRACE"><code class="name">var <span class="ident">BPT_TRACE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
add trace information upon hit</div></div>
</dd>
<dt id="ida_dbg.BPT_TRACEON"><code class="name">var <span class="ident">BPT_TRACEON</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
enable tracing when the breakpoint is reached</div></div>
</dd>
<dt id="ida_dbg.BPT_TRACE_BBLK"><code class="name">var <span class="ident">BPT_TRACE_BBLK</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
basic block tracing</div></div>
</dd>
<dt id="ida_dbg.BPT_TRACE_FUNC"><code class="name">var <span class="ident">BPT_TRACE_FUNC</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
function tracing</div></div>
</dd>
<dt id="ida_dbg.BPT_TRACE_INSN"><code class="name">var <span class="ident">BPT_TRACE_INSN</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
instruction tracing</div></div>
</dd>
<dt id="ida_dbg.BPT_TRACE_TYPES"><code class="name">var <span class="ident">BPT_TRACE_TYPES</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
trace insns, functions, and basic blocks. if any of 'BPT_TRACE_TYPES'
bits are set but 'BPT_TRACEON' is clear, then turn off tracing for the
specified trace types</div></div>
</dd>
<dt id="ida_dbg.BPT_UPDMEM"><code class="name">var <span class="ident">BPT_UPDMEM</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
refresh the memory layout and contents before evaluating bpt condition</div></div>
</dd>
<dt id="ida_dbg.BT_LOG_INSTS"><code class="name">var <span class="ident">BT_LOG_INSTS</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
specific options for basic block tracing (see
'set_bblk_trace_options()' )</div>
<div class="epy_par">
log all instructions in the current basic block</div></div>
</dd>
<dt id="ida_dbg.DBGINV_ALL"><code class="name">var <span class="ident">DBGINV_ALL</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
invalidate everything</div></div>
</dd>
<dt id="ida_dbg.DBGINV_MEMCFG"><code class="name">var <span class="ident">DBGINV_MEMCFG</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
invalidate cached process segmentation</div></div>
</dd>
<dt id="ida_dbg.DBGINV_MEMORY"><code class="name">var <span class="ident">DBGINV_MEMORY</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
invalidate cached memory contents</div></div>
</dd>
<dt id="ida_dbg.DBGINV_NONE"><code class="name">var <span class="ident">DBGINV_NONE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
invalidate nothing</div></div>
</dd>
<dt id="ida_dbg.DBGINV_REDRAW"><code class="name">var <span class="ident">DBGINV_REDRAW</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
refresh the screen</div></div>
</dd>
<dt id="ida_dbg.DBGINV_REGS"><code class="name">var <span class="ident">DBGINV_REGS</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
invalidate cached register values</div></div>
</dd>
<dt id="ida_dbg.DEC_ERROR"><code class="name">var <span class="ident">DEC_ERROR</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
DEC_ERROR = -1</div></div>
</dd>
<dt id="ida_dbg.DEC_NOTASK"><code class="name">var <span class="ident">DEC_NOTASK</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
DEC_NOTASK = -2</div></div>
</dd>
<dt id="ida_dbg.DEC_TIMEOUT"><code class="name">var <span class="ident">DEC_TIMEOUT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
DEC_TIMEOUT = 0</div></div>
</dd>
<dt id="ida_dbg.DOPT_BPT_MSGS"><code class="name">var <span class="ident">DOPT_BPT_MSGS</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
log breakpoints</div></div>
</dd>
<dt id="ida_dbg.DOPT_END_BPT"><code class="name">var <span class="ident">DOPT_END_BPT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
evaluate event condition on process end</div></div>
</dd>
<dt id="ida_dbg.DOPT_ENTRY_BPT"><code class="name">var <span class="ident">DOPT_ENTRY_BPT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
break on program entry point</div></div>
</dd>
<dt id="ida_dbg.DOPT_EXCDLG"><code class="name">var <span class="ident">DOPT_EXCDLG</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
exception dialogs:</div></div>
</dd>
<dt id="ida_dbg.DOPT_FAST_STEP"><code class="name">var <span class="ident">DOPT_FAST_STEP</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
prevent debugger memory refreshes when single-stepping</div></div>
</dd>
<dt id="ida_dbg.DOPT_INFO_BPT"><code class="name">var <span class="ident">DOPT_INFO_BPT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
break on debugging information</div></div>
</dd>
<dt id="ida_dbg.DOPT_INFO_MSGS"><code class="name">var <span class="ident">DOPT_INFO_MSGS</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
log debugging info events</div></div>
</dd>
<dt id="ida_dbg.DOPT_LIB_BPT"><code class="name">var <span class="ident">DOPT_LIB_BPT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
break on library load/unload</div></div>
</dd>
<dt id="ida_dbg.DOPT_LIB_MSGS"><code class="name">var <span class="ident">DOPT_LIB_MSGS</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
log library loads/unloads</div></div>
</dd>
<dt id="ida_dbg.DOPT_LOAD_DINFO"><code class="name">var <span class="ident">DOPT_LOAD_DINFO</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
automatically load debug files (pdb)</div></div>
</dd>
<dt id="ida_dbg.DOPT_REAL_MEMORY"><code class="name">var <span class="ident">DOPT_REAL_MEMORY</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
do not hide breakpoint instructions</div></div>
</dd>
<dt id="ida_dbg.DOPT_REDO_STACK"><code class="name">var <span class="ident">DOPT_REDO_STACK</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
reconstruct the stack</div></div>
</dd>
<dt id="ida_dbg.DOPT_SEGM_MSGS"><code class="name">var <span class="ident">DOPT_SEGM_MSGS</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
log debugger segments modifications</div></div>
</dd>
<dt id="ida_dbg.DOPT_START_BPT"><code class="name">var <span class="ident">DOPT_START_BPT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
break on process start</div></div>
</dd>
<dt id="ida_dbg.DOPT_TEMP_HWBPT"><code class="name">var <span class="ident">DOPT_TEMP_HWBPT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
when possible use hardware bpts for temp bpts</div></div>
</dd>
<dt id="ida_dbg.DOPT_THREAD_BPT"><code class="name">var <span class="ident">DOPT_THREAD_BPT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
break on thread start/exit</div></div>
</dd>
<dt id="ida_dbg.DOPT_THREAD_MSGS"><code class="name">var <span class="ident">DOPT_THREAD_MSGS</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
log thread starts/exits</div></div>
</dd>
<dt id="ida_dbg.DSTATE_NOTASK"><code class="name">var <span class="ident">DSTATE_NOTASK</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
no process is currently debugged</div></div>
</dd>
<dt id="ida_dbg.DSTATE_RUN"><code class="name">var <span class="ident">DSTATE_RUN</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
process is running</div></div>
</dd>
<dt id="ida_dbg.DSTATE_SUSP"><code class="name">var <span class="ident">DSTATE_SUSP</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
process is suspended and will not continue</div></div>
</dd>
<dt id="ida_dbg.EXCDLG_ALWAYS"><code class="name">var <span class="ident">EXCDLG_ALWAYS</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
always display</div></div>
</dd>
<dt id="ida_dbg.EXCDLG_NEVER"><code class="name">var <span class="ident">EXCDLG_NEVER</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
never display exception dialogs</div></div>
</dd>
<dt id="ida_dbg.EXCDLG_UNKNOWN"><code class="name">var <span class="ident">EXCDLG_UNKNOWN</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
display for unknown exceptions</div></div>
</dd>
<dt id="ida_dbg.FT_LOG_RET"><code class="name">var <span class="ident">FT_LOG_RET</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
specific options for function tracing (see 'set_func_trace_options()'
)</div>
<div class="epy_par">
function tracing will log returning instructions</div></div>
</dd>
<dt id="ida_dbg.IT_LOG_SAME_IP"><code class="name">var <span class="ident">IT_LOG_SAME_IP</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
specific options for instruction tracing (see
'set_insn_trace_options()' )</div>
<div class="epy_par">
instruction tracing will log new instructions even when IP doesn't
change</div></div>
</dd>
<dt id="ida_dbg.MOVBPT_BAD_TYPE"><code class="name">var <span class="ident">MOVBPT_BAD_TYPE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
MOVBPT_BAD_TYPE = 3</div></div>
</dd>
<dt id="ida_dbg.MOVBPT_DEST_BUSY"><code class="name">var <span class="ident">MOVBPT_DEST_BUSY</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
MOVBPT_DEST_BUSY = 2</div></div>
</dd>
<dt id="ida_dbg.MOVBPT_NOT_FOUND"><code class="name">var <span class="ident">MOVBPT_NOT_FOUND</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
MOVBPT_NOT_FOUND = 1</div></div>
</dd>
<dt id="ida_dbg.MOVBPT_OK"><code class="name">var <span class="ident">MOVBPT_OK</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
MOVBPT_OK = 0</div></div>
</dd>
<dt id="ida_dbg.SAVE_ALL_VALUES"><code class="name">var <span class="ident">SAVE_ALL_VALUES</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
SAVE_ALL_VALUES = 0</div></div>
</dd>
<dt id="ida_dbg.SAVE_DIFF"><code class="name">var <span class="ident">SAVE_DIFF</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
SAVE_DIFF = 1</div></div>
</dd>
<dt id="ida_dbg.SAVE_NONE"><code class="name">var <span class="ident">SAVE_NONE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
SAVE_NONE = 2</div></div>
</dd>
<dt id="ida_dbg.SRCDBG_PROV_VERSION"><code class="name">var <span class="ident">SRCDBG_PROV_VERSION</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
SRCDBG_PROV_VERSION = 4</div></div>
</dd>
<dt id="ida_dbg.SRCIT_EXPR"><code class="name">var <span class="ident">SRCIT_EXPR</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
SRCIT_EXPR = 4</div></div>
</dd>
<dt id="ida_dbg.SRCIT_FUNC"><code class="name">var <span class="ident">SRCIT_FUNC</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
SRCIT_FUNC = 2</div></div>
</dd>
<dt id="ida_dbg.SRCIT_LOCVAR"><code class="name">var <span class="ident">SRCIT_LOCVAR</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
SRCIT_LOCVAR = 6</div></div>
</dd>
<dt id="ida_dbg.SRCIT_MODULE"><code class="name">var <span class="ident">SRCIT_MODULE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
SRCIT_MODULE = 1</div></div>
</dd>
<dt id="ida_dbg.SRCIT_NONE"><code class="name">var <span class="ident">SRCIT_NONE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
SRCIT_NONE = 0</div></div>
</dd>
<dt id="ida_dbg.SRCIT_STMT"><code class="name">var <span class="ident">SRCIT_STMT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
SRCIT_STMT = 3</div></div>
</dd>
<dt id="ida_dbg.SRCIT_STTVAR"><code class="name">var <span class="ident">SRCIT_STTVAR</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
SRCIT_STTVAR = 5</div></div>
</dd>
<dt id="ida_dbg.ST_ALREADY_LOGGED"><code class="name">var <span class="ident">ST_ALREADY_LOGGED</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
step tracing will be disabled when IP is already logged</div></div>
</dd>
<dt id="ida_dbg.ST_DIFFERENTIAL"><code class="name">var <span class="ident">ST_DIFFERENTIAL</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
tracing: log only new instructions (not previously logged)</div></div>
</dd>
<dt id="ida_dbg.ST_OPTIONS_DEFAULT"><code class="name">var <span class="ident">ST_OPTIONS_DEFAULT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
ST_OPTIONS_DEFAULT = 3</div></div>
</dd>
<dt id="ida_dbg.ST_OPTIONS_MASK"><code class="name">var <span class="ident">ST_OPTIONS_MASK</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
mask of available options, to ensure compatibility with newer IDA
versions</div></div>
</dd>
<dt id="ida_dbg.ST_OVER_DEBUG_SEG"><code class="name">var <span class="ident">ST_OVER_DEBUG_SEG</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
step tracing will be disabled when IP is in a debugger segment</div></div>
</dd>
<dt id="ida_dbg.ST_OVER_LIB_FUNC"><code class="name">var <span class="ident">ST_OVER_LIB_FUNC</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
step tracing will be disabled when IP is in a library function</div></div>
</dd>
<dt id="ida_dbg.ST_SKIP_LOOPS"><code class="name">var <span class="ident">ST_SKIP_LOOPS</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
step tracing will try to skip loops already recorded</div></div>
</dd>
<dt id="ida_dbg.WFNE_ANY"><code class="name">var <span class="ident">WFNE_ANY</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
return the first event (even if it doesn't suspend the process)</div></div>
</dd>
<dt id="ida_dbg.WFNE_CONT"><code class="name">var <span class="ident">WFNE_CONT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
continue from the suspended state</div></div>
</dd>
<dt id="ida_dbg.WFNE_NOWAIT"><code class="name">var <span class="ident">WFNE_NOWAIT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
do not wait for any event, immediately return 'DEC_TIMEOUT' (to be
used with 'WFNE_CONT' )</div></div>
</dd>
<dt id="ida_dbg.WFNE_SILENT"><code class="name">var <span class="ident">WFNE_SILENT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
1: be slient, 0:display modal boxes if necessary</div></div>
</dd>
<dt id="ida_dbg.WFNE_SUSP"><code class="name">var <span class="ident">WFNE_SUSP</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
wait until the process gets suspended</div></div>
</dd>
<dt id="ida_dbg.WFNE_USEC"><code class="name">var <span class="ident">WFNE_USEC</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
timeout is specified in microseconds (minimum non-zero timeout is
40000us)</div></div>
</dd>
<dt id="ida_dbg.dbg_bpt"><code class="name">var <span class="ident">dbg_bpt</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
dbg_bpt = 12</div></div>
</dd>
<dt id="ida_dbg.dbg_bpt_changed"><code class="name">var <span class="ident">dbg_bpt_changed</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
dbg_bpt_changed = 19</div></div>
</dd>
<dt id="ida_dbg.dbg_exception"><code class="name">var <span class="ident">dbg_exception</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
dbg_exception = 10</div></div>
</dd>
<dt id="ida_dbg.dbg_finished_loading_bpts"><code class="name">var <span class="ident">dbg_finished_loading_bpts</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
dbg_finished_loading_bpts = 21</div></div>
</dd>
<dt id="ida_dbg.dbg_information"><code class="name">var <span class="ident">dbg_information</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
dbg_information = 9</div></div>
</dd>
<dt id="ida_dbg.dbg_last"><code class="name">var <span class="ident">dbg_last</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
dbg_last = 22</div></div>
</dd>
<dt id="ida_dbg.dbg_library_load"><code class="name">var <span class="ident">dbg_library_load</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
dbg_library_load = 7</div></div>
</dd>
<dt id="ida_dbg.dbg_library_unload"><code class="name">var <span class="ident">dbg_library_unload</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
dbg_library_unload = 8</div></div>
</dd>
<dt id="ida_dbg.dbg_null"><code class="name">var <span class="ident">dbg_null</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
dbg_null = 0</div></div>
</dd>
<dt id="ida_dbg.dbg_process_attach"><code class="name">var <span class="ident">dbg_process_attach</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
dbg_process_attach = 3</div></div>
</dd>
<dt id="ida_dbg.dbg_process_detach"><code class="name">var <span class="ident">dbg_process_detach</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
dbg_process_detach = 4</div></div>
</dd>
<dt id="ida_dbg.dbg_process_exit"><code class="name">var <span class="ident">dbg_process_exit</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
dbg_process_exit = 2</div></div>
</dd>
<dt id="ida_dbg.dbg_process_start"><code class="name">var <span class="ident">dbg_process_start</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
dbg_process_start = 1</div></div>
</dd>
<dt id="ida_dbg.dbg_request_error"><code class="name">var <span class="ident">dbg_request_error</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
dbg_request_error = 14</div></div>
</dd>
<dt id="ida_dbg.dbg_run_to"><code class="name">var <span class="ident">dbg_run_to</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
dbg_run_to = 17</div></div>
</dd>
<dt id="ida_dbg.dbg_started_loading_bpts"><code class="name">var <span class="ident">dbg_started_loading_bpts</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
dbg_started_loading_bpts = 20</div></div>
</dd>
<dt id="ida_dbg.dbg_step_into"><code class="name">var <span class="ident">dbg_step_into</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
dbg_step_into = 15</div></div>
</dd>
<dt id="ida_dbg.dbg_step_over"><code class="name">var <span class="ident">dbg_step_over</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
dbg_step_over = 16</div></div>
</dd>
<dt id="ida_dbg.dbg_step_until_ret"><code class="name">var <span class="ident">dbg_step_until_ret</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
dbg_step_until_ret = 18</div></div>
</dd>
<dt id="ida_dbg.dbg_suspend_process"><code class="name">var <span class="ident">dbg_suspend_process</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
dbg_suspend_process = 11</div></div>
</dd>
<dt id="ida_dbg.dbg_thread_exit"><code class="name">var <span class="ident">dbg_thread_exit</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
dbg_thread_exit = 6</div></div>
</dd>
<dt id="ida_dbg.dbg_thread_start"><code class="name">var <span class="ident">dbg_thread_start</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
dbg_thread_start = 5</div></div>
</dd>
<dt id="ida_dbg.dbg_trace"><code class="name">var <span class="ident">dbg_trace</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
dbg_trace = 13</div></div>
</dd>
<dt id="ida_dbg.tev_bpt"><code class="name">var <span class="ident">tev_bpt</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
tev_bpt = 4</div></div>
</dd>
<dt id="ida_dbg.tev_call"><code class="name">var <span class="ident">tev_call</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
tev_call = 2</div></div>
</dd>
<dt id="ida_dbg.tev_event"><code class="name">var <span class="ident">tev_event</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
tev_event = 6</div></div>
</dd>
<dt id="ida_dbg.tev_insn"><code class="name">var <span class="ident">tev_insn</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
tev_insn = 1</div></div>
</dd>
<dt id="ida_dbg.tev_max"><code class="name">var <span class="ident">tev_max</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
tev_max = 7</div></div>
</dd>
<dt id="ida_dbg.tev_mem"><code class="name">var <span class="ident">tev_mem</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
tev_mem = 5</div></div>
</dd>
<dt id="ida_dbg.tev_none"><code class="name">var <span class="ident">tev_none</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
tev_none = 0</div></div>
</dd>
<dt id="ida_dbg.tev_ret"><code class="name">var <span class="ident">tev_ret</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
tev_ret = 3</div></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="ida_dbg.add_bpt"><code class="name flex">
<span>def <span class="ident">add_bpt</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Add a new breakpoint in the debugged process.
<table border="1">
<tr><td>Type</td><td>function - available as request</td></tr>
<tr><td>Notification</td><td>function)</td></tr>
</table>
Only one breakpoint can exist at a given address.</div>
<div class="epy_par">
<strong class="epy_sig">add_bpt(ea, size=0, type=BPT_DEFAULT) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong>: any address in the process memory space. Depending on the<div class="epy_nested">
architecture, hardware breakpoints always be setup at
random address. For example, on x86, hardware breakpoints
should be aligned depending on their size. Moreover, on the
x86 architecture, it is impossible to setup more than 4
hardware breakpoints. (C++: ea_t)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">size</strong>: size of the breakpoint (irrelevant for software<div class="epy_nested">
breakpoints): As for the address, hardware breakpoints
can't always be setup with random size. (C++: asize_t)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">type</strong>: type of the breakpoint ( BPT_SOFT
for software<div class="epy_nested">
breakpoint) special case
BPT_DEFAULT
( BPT_SOFT |
BPT_EXEC ): try to add instruction breakpoint of the
appropriate type as follows: software bpt if supported,
hwbpt otherwise (C++: bpttype_t)</div>
</div>
</div>
<div class="epy_par">
<strong class="epy_sig">add_bpt(bpt) -&gt; bool</strong><div class="epy_nested">
bpt: bpt_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_dbg.add_path_mapping"><code class="name flex">
<span>def <span class="ident">add_path_mapping</span></span>(<span>*args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">add_path_mapping(src, dst)</strong><div class="epy_nested">
<strong class="epy_parameter">src</strong> (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">dst</strong> (C++: const char *)</div>
</div></div>
</dd>
<dt id="ida_dbg.add_virt_module"><code class="name flex">
<span>def <span class="ident">add_virt_module</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">add_virt_module(mod) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">mod</strong> (C++: const
modinfo_t
*)</div>
</div></div>
</dd>
<dt id="ida_dbg.attach_process"><code class="name flex">
<span>def <span class="ident">attach_process</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Attach the debugger to a running process. </div></div>
</dd>
<dt id="ida_dbg.bring_debugger_to_front"><code class="name flex">
<span>def <span class="ident">bring_debugger_to_front</span></span>(<span>*args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">bring_debugger_to_front()</strong></div></div>
</dd>
<dt id="ida_dbg.check_bpt"><code class="name flex">
<span>def <span class="ident">check_bpt</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Check the breakpoint at the specified address.</div>
<div class="epy_par">
<strong class="epy_sig">check_bpt(ea) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: one of
Breakpoint status codes</div>
</div></div>
</dd>
<dt id="ida_dbg.choose_trace_file"><code class="name flex">
<span>def <span class="ident">choose_trace_file</span></span>(<span>*args) &#8209;&gt;&#160;qstring&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Show the choose trace dialog.</div></div>
</dd>
<dt id="ida_dbg.clear_requests_queue"><code class="name flex">
<span>def <span class="ident">clear_requests_queue</span></span>(<span>*args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Clear the queue of waiting requests.
<table border="1">
<tr><td>Type</td><td>Synchronous function</td></tr>
<tr><td>Notification</td><td>none (synchronous function)</td></tr>
</table>
If a request is currently
running, this one isn't stopped.</div></div>
</dd>
<dt id="ida_dbg.clear_trace"><code class="name flex">
<span>def <span class="ident">clear_trace</span></span>(<span>*args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Clear all events in the trace buffer.
<table border="1">
<tr><td>Type</td><td>available as request</td></tr>
<tr><td>Notification</td><td>none (synchronous function)</td></tr>
</table>
</div></div>
</dd>
<dt id="ida_dbg.collect_stack_trace"><code class="name flex">
<span>def <span class="ident">collect_stack_trace</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">collect_stack_trace(tid, trace) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">tid</strong> (C++: thid_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">trace</strong> (C++: call_stack_t
*)</div>
</div></div>
</dd>
<dt id="ida_dbg.continue_process"><code class="name flex">
<span>def <span class="ident">continue_process</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Continue the execution of the process in the debugger.
<table border="1">
<tr><td>Type</td><td>Synchronous function - available as Request</td></tr>
<tr><td>Notification</td><td>(synchronous function)</td></tr>
</table>
The 'continue_process()' function can be called
from a notification handler to force the continuation of the process.
In this case the request queue will not be examined, IDA will simply
resume execution. Usually it makes sense to call
'request_continue_process()' followed by 'run_requests()' , so that
IDA will first start a queued request (if any) and then resume the
application.</div></div>
</dd>
<dt id="ida_dbg.create_source_viewer"><code class="name flex">
<span>def <span class="ident">create_source_viewer</span></span>(<span>*args) &#8209;&gt;&#160;source_view_t&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Create a source code view.</div>
<div class="epy_par">
<strong class="epy_sig">create_source_viewer(out_ccv, parent, custview, sf, lines, lnnum, colnum, flags) -&gt; source_view_t *</strong><div class="epy_nested">
<strong class="epy_parameter">out_ccv</strong> (C++: TWidget **)</div>
<div class="epy_nested">
<strong class="epy_parameter">parent</strong> (C++: TWidget *)</div>
<div class="epy_nested">
<strong class="epy_parameter">custview</strong> (C++: TWidget *)</div>
<div class="epy_nested">
<strong class="epy_parameter">sf</strong> (C++: source_file_ptr)</div>
<div class="epy_nested">
<strong class="epy_parameter">lines</strong> (C++: strvec_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">lnnum</strong> (C++: int)</div>
<div class="epy_nested">
<strong class="epy_parameter">colnum</strong> (C++: int)</div>
<div class="epy_nested">
<strong class="epy_parameter">flags</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_dbg.dbg_add_bpt_tev"><code class="name flex">
<span>def <span class="ident">dbg_add_bpt_tev</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Add a new breakpoint trace element to the current trace.
<table border="1">
<tr><td>Type</td><td>Synchronous function</td></tr>
<tr><td>Notification</td><td>none (synchronous function)</td></tr>
</table>
</div>
<div class="epy_par">
<strong class="epy_sig">dbg_add_bpt_tev(tid, ea, bp) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">tid</strong> (C++: thid_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">bp</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: false if the operation failed, true otherwise</div>
</div></div>
</dd>
<dt id="ida_dbg.dbg_add_call_tev"><code class="name flex">
<span>def <span class="ident">dbg_add_call_tev</span></span>(<span>*args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Add a new call trace element to the current trace.
<table border="1">
<tr><td>Type</td><td>Synchronous function</td></tr>
<tr><td>Notification</td><td>none (synchronous function)</td></tr>
</table>
</div>
<div class="epy_par">
<strong class="epy_sig">dbg_add_call_tev(tid, caller, callee)</strong><div class="epy_nested">
<strong class="epy_parameter">tid</strong> (C++: thid_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">caller</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">callee</strong> (C++: ea_t)</div>
</div></div>
</dd>
<dt id="ida_dbg.dbg_add_debug_event"><code class="name flex">
<span>def <span class="ident">dbg_add_debug_event</span></span>(<span>*args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Add a new debug event to the current trace.
<table border="1">
<tr><td>Type</td><td>function</td></tr>
<tr><td>Notification</td><td>none (synchronous function)</td></tr>
</table>
</div>
<div class="epy_par">
<strong class="epy_sig">dbg_add_debug_event(event)</strong><div class="epy_nested">
<strong class="epy_parameter">event</strong> (C++: debug_event_t
*)</div>
</div></div>
</dd>
<dt id="ida_dbg.dbg_add_insn_tev"><code class="name flex">
<span>def <span class="ident">dbg_add_insn_tev</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Add a new instruction trace element to the current trace.
<table border="1">
<tr><td>Type</td><td>Synchronous function</td></tr>
<tr><td>Notification</td><td>none (synchronous function)</td></tr>
</table>
</div>
<div class="epy_par">
<strong class="epy_sig">dbg_add_insn_tev(tid, ea, save=SAVE_DIFF) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">tid</strong> (C++: thid_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">save</strong> (C++: save_reg_values_t)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: false if the operation failed, true otherwise</div>
</div></div>
</dd>
<dt id="ida_dbg.dbg_add_many_tevs"><code class="name flex">
<span>def <span class="ident">dbg_add_many_tevs</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Add many new trace elements to the current trace.
<table border="1">
<tr><td>Type</td><td>Synchronous function</td></tr>
<tr><td>Notification</td><td>none (synchronous function)</td></tr>
</table>
</div>
<div class="epy_par">
<strong class="epy_sig">dbg_add_many_tevs(new_tevs) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">new_tevs</strong> (C++: tevinforeg_vec_t
*)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: false if the operation failed for any
tev_info_t
object</div>
</div></div>
</dd>
<dt id="ida_dbg.dbg_add_ret_tev"><code class="name flex">
<span>def <span class="ident">dbg_add_ret_tev</span></span>(<span>*args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Add a new return trace element to the current trace.
<table border="1">
<tr><td>Type</td><td>Synchronous function</td></tr>
<tr><td>Notification</td><td>none (synchronous function)</td></tr>
</table>
</div>
<div class="epy_par">
<strong class="epy_sig">dbg_add_ret_tev(tid, ret_insn, return_to)</strong><div class="epy_nested">
<strong class="epy_parameter">tid</strong> (C++: thid_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">ret_insn</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">return_to</strong> (C++: ea_t)</div>
</div></div>
</dd>
<dt id="ida_dbg.dbg_add_tev"><code class="name flex">
<span>def <span class="ident">dbg_add_tev</span></span>(<span>*args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Add a new trace element to the current trace.
<table border="1">
<tr><td>Type</td><td>function</td></tr>
<tr><td>Notification</td><td>none (synchronous function)</td></tr>
</table>
</div>
<div class="epy_par">
<strong class="epy_sig">dbg_add_tev(type, tid, address)</strong><div class="epy_nested">
<strong class="epy_parameter">type</strong> (C++: tev_type_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">tid</strong> (C++: thid_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">address</strong> (C++: ea_t)</div>
</div></div>
</dd>
<dt id="ida_dbg.dbg_add_thread"><code class="name flex">
<span>def <span class="ident">dbg_add_thread</span></span>(<span>*args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Add a thread to the current trace.
<table border="1">
<tr><td>Type</td><td>Synchronous function</td></tr>
<tr><td>Notification</td><td>none (synchronous function)</td></tr>
</table>
</div>
<div class="epy_par">
<strong class="epy_sig">dbg_add_thread(tid)</strong><div class="epy_nested">
<strong class="epy_parameter">tid</strong> (C++: thid_t)</div>
</div></div>
</dd>
<dt id="ida_dbg.dbg_bin_search"><code class="name flex">
<span>def <span class="ident">dbg_bin_search</span></span>(<span>*args) &#8209;&gt;&#160;uint32&#160;*,&#160;qstring&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">dbg_bin_search(start_ea, end_ea, data, srch_flags) -&gt; str</strong><div class="epy_nested">
<strong class="epy_parameter">start_ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">end_ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">data</strong> (C++: const
compiled_binpat_vec_t
&amp;)</div>
<div class="epy_nested">
<strong class="epy_parameter">srch_flags</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_dbg.dbg_can_query"><code class="name flex">
<span>def <span class="ident">dbg_can_query</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">dbg_can_query() -&gt; bool</strong><div class="epy_nested">
This function can be used to check if the debugger can be queried:<ul class="epy_ul">
<li class="epy_li"><span class="epy_nested">
debugger is loaded</span>
</li>
<li class="epy_li"><span class="epy_nested">
process is suspended</span>
</li>
<li class="epy_li"><span class="epy_nested">
process is not suspended but can take requests. In this case some requests like<div class="epy_nested">
memory read/write, bpt management succeed and register querying will fail.
Check if idaapi.get_process_state() &lt; 0 to tell if the process is suspended</div>
</span>
</li>
</ul>
</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: Boolean</div>
</div></div>
</dd>
<dt id="ida_dbg.dbg_del_thread"><code class="name flex">
<span>def <span class="ident">dbg_del_thread</span></span>(<span>*args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Delete a thread from the current trace.
<table border="1">
<tr><td>Type</td><td>function</td></tr>
<tr><td>Notification</td><td>none (synchronous function)</td></tr>
</table>
</div>
<div class="epy_par">
<strong class="epy_sig">dbg_del_thread(tid)</strong><div class="epy_nested">
<strong class="epy_parameter">tid</strong> (C++: thid_t)</div>
</div></div>
</dd>
<dt id="ida_dbg.dbg_is_loaded"><code class="name flex">
<span>def <span class="ident">dbg_is_loaded</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">dbg_is_loaded() -&gt; bool</strong><div class="epy_nested">
Checks if a debugger is loaded</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: Boolean</div>
</div></div>
</dd>
<dt id="ida_dbg.define_exception"><code class="name flex">
<span>def <span class="ident">define_exception</span></span>(<span>*args) &#8209;&gt;&#160;char&#160;const&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Convenience function: define new exception code.</div>
<div class="epy_par">
<strong class="epy_sig">define_exception(code, name, desc, flags) -&gt; char const *</strong><div class="epy_nested">
<strong class="epy_parameter">code</strong>: exception code (cannot be 0) (C++: uint)</div>
<div class="epy_nested">
<strong class="epy_parameter">name</strong>: exception name (cannot be empty or NULL) (C++: const char<div class="epy_nested">
*)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">desc</strong>: exception description (maybe NULL) (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">flags</strong>: combination of
Exception info flags (C++: int)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: failure message or NULL. You must call
store_exceptions()<div class="epy_nested">
if this function succeeds</div>
</div>
</div></div>
</dd>
<dt id="ida_dbg.del_bpt"><code class="name flex">
<span>def <span class="ident">del_bpt</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Delete an existing breakpoint in the debugged process.
<table border="1">
<tr><td>Type</td><td>Synchronous function - available as request</td></tr>
<tr><td>Notification</td><td>(synchronous function)</td></tr>
</table>
</div>
<div class="epy_par">
<strong class="epy_sig">del_bpt(ea) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong>: any address in the breakpoint range (C++: ea_t)</div>
</div>
<div class="epy_par">
<strong class="epy_sig">del_bpt(bptloc) -&gt; bool</strong><div class="epy_nested">
bptloc: bpt_location_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_dbg.del_bptgrp"><code class="name flex">
<span>def <span class="ident">del_bptgrp</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">del_bptgrp(name) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">name</strong> (C++: const char *)</div>
</div></div>
</dd>
<dt id="ida_dbg.del_virt_module"><code class="name flex">
<span>def <span class="ident">del_virt_module</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">del_virt_module(base) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">base</strong> (C++: const ea_t)</div>
</div></div>
</dd>
<dt id="ida_dbg.detach_process"><code class="name flex">
<span>def <span class="ident">detach_process</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Detach the debugger from the debugged process.
<table border="1">
<tr><td>Type</td><td>function - available as Request</td></tr>
<tr><td>Notification</td><td>'dbg_process_detach'</td></tr>
</table>
</div></div>
</dd>
<dt id="ida_dbg.diff_trace_file"><code class="name flex">
<span>def <span class="ident">diff_trace_file</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Show difference between the current trace and the one from 'filename'.</div>
<div class="epy_par">
<strong class="epy_sig">diff_trace_file(filename) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">filename</strong> (C++: const char *)</div>
</div></div>
</dd>
<dt id="ida_dbg.disable_bblk_trace"><code class="name flex">
<span>def <span class="ident">disable_bblk_trace</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">disable_bblk_trace() -&gt; bool</strong></div></div>
</dd>
<dt id="ida_dbg.disable_bpt"><code class="name flex">
<span>def <span class="ident">disable_bpt</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">disable_bpt(ea) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
</div>
<div class="epy_par">
<strong class="epy_sig">disable_bpt(bptloc) -&gt; bool</strong><div class="epy_nested">
bptloc: bpt_location_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_dbg.disable_func_trace"><code class="name flex">
<span>def <span class="ident">disable_func_trace</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">disable_func_trace() -&gt; bool</strong></div></div>
</dd>
<dt id="ida_dbg.disable_insn_trace"><code class="name flex">
<span>def <span class="ident">disable_insn_trace</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">disable_insn_trace() -&gt; bool</strong></div></div>
</dd>
<dt id="ida_dbg.disable_step_trace"><code class="name flex">
<span>def <span class="ident">disable_step_trace</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">disable_step_trace() -&gt; bool</strong></div></div>
</dd>
<dt id="ida_dbg.edit_manual_regions"><code class="name flex">
<span>def <span class="ident">edit_manual_regions</span></span>(<span>*args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">edit_manual_regions()</strong></div></div>
</dd>
<dt id="ida_dbg.enable_bblk_trace"><code class="name flex">
<span>def <span class="ident">enable_bblk_trace</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">enable_bblk_trace(enable=True) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">enable</strong> (C++: bool)</div>
</div></div>
</dd>
<dt id="ida_dbg.enable_bpt"><code class="name flex">
<span>def <span class="ident">enable_bpt</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">enable_bpt(ea, enable=True) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">enable</strong> (C++: bool)</div>
</div>
<div class="epy_par">
<strong class="epy_sig">enable_bpt(bptloc, enable=True) -&gt; bool</strong><div class="epy_nested">
bptloc: bpt_location_t const &amp;</div>
<div class="epy_nested">
<strong class="epy_parameter">enable</strong> (C++: bool)</div>
</div></div>
</dd>
<dt id="ida_dbg.enable_func_trace"><code class="name flex">
<span>def <span class="ident">enable_func_trace</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">enable_func_trace(enable=True) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">enable</strong> (C++: bool)</div>
</div></div>
</dd>
<dt id="ida_dbg.enable_insn_trace"><code class="name flex">
<span>def <span class="ident">enable_insn_trace</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">enable_insn_trace(enable=True) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">enable</strong> (C++: bool)</div>
</div></div>
</dd>
<dt id="ida_dbg.enable_manual_regions"><code class="name flex">
<span>def <span class="ident">enable_manual_regions</span></span>(<span>*args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">enable_manual_regions(enable)</strong><div class="epy_nested">
<strong class="epy_parameter">enable</strong> (C++: bool)</div>
</div></div>
</dd>
<dt id="ida_dbg.enable_step_trace"><code class="name flex">
<span>def <span class="ident">enable_step_trace</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">enable_step_trace(enable=1) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">enable</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_dbg.exist_bpt"><code class="name flex">
<span>def <span class="ident">exist_bpt</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Does a breakpoint exist at the given location?</div>
<div class="epy_par">
<strong class="epy_sig">exist_bpt(ea) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
</div></div>
</dd>
<dt id="ida_dbg.exit_process"><code class="name flex">
<span>def <span class="ident">exit_process</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Terminate the debugging of the current process.
<table border="1">
<tr><td>Type</td><td>function - available as Request</td></tr>
<tr><td>Notification</td><td>'dbg_process_exit'</td></tr>
</table>
</div></div>
</dd>
<dt id="ida_dbg.find_bpt"><code class="name flex">
<span>def <span class="ident">find_bpt</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Find a breakpoint by location.
<table border="1">
<tr><td>Type</td><td>available as request</td></tr>
<tr><td>Notification</td><td>none (synchronous function)</td></tr>
</table>
</div>
<div class="epy_par">
<strong class="epy_sig">find_bpt(bptloc, bpt) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">bptloc</strong>: Breakpoint location (C++: const
bpt_location_t
&amp;)</div>
<div class="epy_nested">
<strong class="epy_parameter">bpt</strong>: bpt is filled if the breakpoint was found (C++: bpt_t
*)</div>
</div></div>
</dd>
<dt id="ida_dbg.get_bblk_trace_options"><code class="name flex">
<span>def <span class="ident">get_bblk_trace_options</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get current basic block tracing options. Also see 'BT_LOG_INSTS'</div>
<div class="epy_par">
<table border="1">
<tr><td>Type</td><td>Synchronous function</td></tr>
<tr><td>Notification</td><td>function)</td></tr>
</table>
</div></div>
</dd>
<dt id="ida_dbg.get_bpt"><code class="name flex">
<span>def <span class="ident">get_bpt</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get the characteristics of a breakpoint.
<table border="1">
<tr><td>Type</td><td>function</td></tr>
<tr><td>Notification</td><td>none (synchronous function)</td></tr>
</table>
</div>
<div class="epy_par">
<strong class="epy_sig">get_bpt(ea, bpt) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong>: any address in the breakpoint range (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">bpt</strong>: if not NULL, is filled with the characteristics. (C++:<div class="epy_nested">
bpt_t
*)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: false if no breakpoint exists</div>
</div></div>
</dd>
<dt id="ida_dbg.get_bpt_group"><code class="name flex">
<span>def <span class="ident">get_bpt_group</span></span>(<span>*args) &#8209;&gt;&#160;qstring&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">get_bpt_group(bptloc) -&gt; str</strong><div class="epy_nested">
<strong class="epy_parameter">bptloc</strong> (C++: const
bpt_location_t
&amp;)</div>
</div></div>
</dd>
<dt id="ida_dbg.get_bpt_qty"><code class="name flex">
<span>def <span class="ident">get_bpt_qty</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get number of breakpoints.
<table border="1">
<tr><td>Type</td><td>Synchronous function</td></tr>
<tr><td>Notification</td><td>none (synchronous function)</td></tr>
</table>
</div></div>
</dd>
<dt id="ida_dbg.get_bpt_tev_ea"><code class="name flex">
<span>def <span class="ident">get_bpt_tev_ea</span></span>(<span>*args) &#8209;&gt;&#160;ea_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get the address associated to a read, read/write or execution trace
event.
<table border="1">
<tr><td>Type</td><td>Synchronous function</td></tr>
<tr><td>Notification</td><td>function)</td></tr>
</table>
Usually, a breakpoint is associated with a read, read/write
or execution trace event. However, the returned address could be any
address in the range of this breakpoint. If the breakpoint was deleted
after the trace event, the address no longer corresponds to a valid
breakpoint.</div>
<div class="epy_par">
<strong class="epy_sig">get_bpt_tev_ea(n) -&gt; ea_t</strong><div class="epy_nested">
<strong class="epy_parameter">n</strong>: number of trace event, is in range 0.. get_tev_qty() -1. 0<div class="epy_nested">
represents the latest added trace event. (C++: int)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: BADADDR
if not a read, read/write or execution trace event.</div>
</div></div>
</dd>
<dt id="ida_dbg.get_bptloc_string"><code class="name flex">
<span>def <span class="ident">get_bptloc_string</span></span>(<span>*args) &#8209;&gt;&#160;char&#160;const&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Helper function for 'bpt_location_t' .</div>
<div class="epy_par">
<strong class="epy_sig">get_bptloc_string(i) -&gt; char const *</strong><div class="epy_nested">
<strong class="epy_parameter">i</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_dbg.get_call_tev_callee"><code class="name flex">
<span>def <span class="ident">get_call_tev_callee</span></span>(<span>*args) &#8209;&gt;&#160;ea_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get the called function from a function call trace event.
<table border="1">
<tr><td>Type</td><td>Synchronous function</td></tr>
<tr><td>Notification</td><td>none (synchronous function)</td></tr>
</table>
</div>
<div class="epy_par">
<strong class="epy_sig">get_call_tev_callee(n) -&gt; ea_t</strong><div class="epy_nested">
<strong class="epy_parameter">n</strong>: number of trace event, is in range 0.. get_tev_qty() -1. 0<div class="epy_nested">
represents the latest added trace event. (C++: int)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: BADADDR
if not a function call event.</div>
</div></div>
</dd>
<dt id="ida_dbg.get_current_source_file"><code class="name flex">
<span>def <span class="ident">get_current_source_file</span></span>(<span>*args) &#8209;&gt;&#160;qstring&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">get_current_source_file() -&gt; str</strong></div></div>
</dd>
<dt id="ida_dbg.get_current_source_line"><code class="name flex">
<span>def <span class="ident">get_current_source_line</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">get_current_source_line() -&gt; int</strong></div></div>
</dd>
<dt id="ida_dbg.get_current_thread"><code class="name flex">
<span>def <span class="ident">get_current_thread</span></span>(<span>*args) &#8209;&gt;&#160;thid_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get current thread ID.
<table border="1">
<tr><td>Type</td><td>Synchronous function</td></tr>
<tr><td>Notification</td><td>none (synchronous function)</td></tr>
</table>
</div></div>
</dd>
<dt id="ida_dbg.get_dbg_byte"><code class="name flex">
<span>def <span class="ident">get_dbg_byte</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get one byte of the debugged process memory.</div>
<div class="epy_par">
<strong class="epy_sig">get_dbg_byte(x, ea) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">x</strong>: pointer to byte value (C++: uint32
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">ea</strong>: linear address (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: true success</div>
</div></div>
</dd>
<dt id="ida_dbg.get_dbg_memory_info"><code class="name flex">
<span>def <span class="ident">get_dbg_memory_info</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">get_dbg_memory_info(ranges) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">ranges</strong> (C++: meminfo_vec_t
*)</div>
</div></div>
</dd>
<dt id="ida_dbg.get_dbg_reg_info"><code class="name flex">
<span>def <span class="ident">get_dbg_reg_info</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get register information
<table border="1">
<tr><td>Type</td><td>Synchronous function</td></tr>
<tr><td>Notification</td><td>none (synchronous function)</td></tr>
</table>
</div>
<div class="epy_par">
<strong class="epy_sig">get_dbg_reg_info(regname, ri) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">regname</strong> (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">ri</strong> (C++: register_info_t
*)</div>
</div></div>
</dd>
<dt id="ida_dbg.get_debug_event"><code class="name flex">
<span>def <span class="ident">get_debug_event</span></span>(<span>*args) &#8209;&gt;&#160;debug_event_t&#160;const&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get the current debugger event.</div></div>
</dd>
<dt id="ida_dbg.get_debugger_event_cond"><code class="name flex">
<span>def <span class="ident">get_debugger_event_cond</span></span>(<span>*args) &#8209;&gt;&#160;char&#160;const&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">get_debugger_event_cond() -&gt; char const *</strong></div></div>
</dd>
<dt id="ida_dbg.get_first_module"><code class="name flex">
<span>def <span class="ident">get_first_module</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">get_first_module(modinfo) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">modinfo</strong> (C++: modinfo_t
*)</div>
</div></div>
</dd>
<dt id="ida_dbg.get_func_trace_options"><code class="name flex">
<span>def <span class="ident">get_func_trace_options</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get current function tracing options. Also see 'FT_LOG_RET'
<table border="1">
<tr><td>Type</td><td>Synchronous function</td></tr>
<tr><td>Notification</td><td>none (synchronous function)</td></tr>
</table>
</div></div>
</dd>
<dt id="ida_dbg.get_global_var"><code class="name flex">
<span>def <span class="ident">get_global_var</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">get_global_var(prov, ea, name, out) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">prov</strong> (C++: srcinfo_provider_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">name</strong> (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">out</strong> (C++: source_item_ptr
*)</div>
</div></div>
</dd>
<dt id="ida_dbg.get_grp_bpts"><code class="name flex">
<span>def <span class="ident">get_grp_bpts</span></span>(<span>*args) &#8209;&gt;&#160;ssize_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">get_grp_bpts(bpts, grp_name) -&gt; ssize_t</strong><div class="epy_nested">
<strong class="epy_parameter">bpts</strong> (C++: bpt_vec_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">grp_name</strong> (C++: const char *)</div>
</div></div>
</dd>
<dt id="ida_dbg.get_insn_tev_reg_mem"><code class="name flex">
<span>def <span class="ident">get_insn_tev_reg_mem</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Read the memory pointed by register values from an instruction trace
event.
<table border="1">
<tr><td>Type</td><td>Synchronous function</td></tr>
<tr><td>Notification</td><td>function)</td></tr>
</table>
</div>
<div class="epy_par">
<strong class="epy_sig">get_insn_tev_reg_mem(n, memmap) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">n</strong>: number of trace event, is in range 0.. get_tev_qty() -1. 0<div class="epy_nested">
represents the latest added trace event. (C++: int)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">memmap</strong>: result (C++: memreg_infos_t
*)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: false if not an instruction event or no memory is available</div>
</div></div>
</dd>
<dt id="ida_dbg.get_insn_tev_reg_result"><code class="name flex">
<span>def <span class="ident">get_insn_tev_reg_result</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Read the resulting register value from an instruction trace event.</div>
<div class="epy_par">
<table border="1">
<tr><td>Type</td><td>Synchronous function</td></tr>
<tr><td>Notification</td><td>function)</td></tr>
</table>
</div>
<div class="epy_par">
<strong class="epy_sig">get_insn_tev_reg_result(n, regname, regval) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">n</strong>: number of trace event, is in range 0.. get_tev_qty() -1. 0<div class="epy_nested">
represents the latest added trace event. (C++: int)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">regname</strong>: name of desired register (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">regval</strong>: result (C++: regval_t
*)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: false if not an instruction trace event or register wasn't<div class="epy_nested">
modified.</div>
</div>
</div></div>
</dd>
<dt id="ida_dbg.get_insn_tev_reg_val"><code class="name flex">
<span>def <span class="ident">get_insn_tev_reg_val</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Read a register value from an instruction trace event.
<table border="1">
<tr><td>Type</td><td>Synchronous function</td></tr>
<tr><td>Notification</td><td>none (synchronous function)</td></tr>
</table>
This
is the value of the register before the execution of the instruction.</div>
<div class="epy_par">
<strong class="epy_sig">get_insn_tev_reg_val(n, regname, regval) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">n</strong>: number of trace event, is in range 0.. get_tev_qty() -1. 0<div class="epy_nested">
represents the latest added trace event. (C++: int)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">regname</strong>: name of desired register (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">regval</strong>: result (C++: regval_t
*)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: false if not an instruction event.</div>
</div></div>
</dd>
<dt id="ida_dbg.get_insn_trace_options"><code class="name flex">
<span>def <span class="ident">get_insn_trace_options</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get current instruction tracing options. Also see 'IT_LOG_SAME_IP'</div>
<div class="epy_par">
<table border="1">
<tr><td>Type</td><td>Synchronous function</td></tr>
<tr><td>Notification</td><td>function)</td></tr>
</table>
</div></div>
</dd>
<dt id="ida_dbg.get_ip_val"><code class="name flex">
<span>def <span class="ident">get_ip_val</span></span>(<span>*args) &#8209;&gt;&#160;uint32&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get value of the IP (program counter) register for the current thread.
Requires a suspended debugger.</div></div>
</dd>
<dt id="ida_dbg.get_local_var"><code class="name flex">
<span>def <span class="ident">get_local_var</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">get_local_var(prov, ea, name, out) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">prov</strong> (C++: srcinfo_provider_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">name</strong> (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">out</strong> (C++: source_item_ptr
*)</div>
</div></div>
</dd>
<dt id="ida_dbg.get_local_vars"><code class="name flex">
<span>def <span class="ident">get_local_vars</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">get_local_vars(prov, ea, out) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">prov</strong> (C++: srcinfo_provider_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">out</strong> (C++: source_items_t
*)</div>
</div></div>
</dd>
<dt id="ida_dbg.get_manual_regions"><code class="name flex">
<span>def <span class="ident">get_manual_regions</span></span>(<span>*args) &#8209;&gt;&#160;PyObject&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">get_manual_regions(ranges)</strong><div class="epy_nested">
Returns the manual memory regions</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: list(start_ea, end_ea, name, sclass, sbase, bitness, perm)</div>
</div></div>
</dd>
<dt id="ida_dbg.get_module_info"><code class="name flex">
<span>def <span class="ident">get_module_info</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">get_module_info(ea, modinfo) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">modinfo</strong> (C++: modinfo_t
*)</div>
</div></div>
</dd>
<dt id="ida_dbg.get_next_module"><code class="name flex">
<span>def <span class="ident">get_next_module</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">get_next_module(modinfo) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">modinfo</strong> (C++: modinfo_t
*)</div>
</div></div>
</dd>
<dt id="ida_dbg.get_process_options"><code class="name flex">
<span>def <span class="ident">get_process_options</span></span>(<span>*args) &#8209;&gt;&#160;qstring&#160;*,&#160;qstring&#160;*,&#160;qstring&#160;*,&#160;qstring&#160;*,&#160;qstring&#160;*,&#160;int&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get process options. Any of the arguments may be NULL</div></div>
</dd>
<dt id="ida_dbg.get_process_state"><code class="name flex">
<span>def <span class="ident">get_process_state</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Return the state of the currently debugged process.
<table border="1">
<tr><td>Type</td><td>Synchronous function</td></tr>
<tr><td>Notification</td><td>none (synchronous function)</td></tr>
</table>
</div></div>
</dd>
<dt id="ida_dbg.get_processes"><code class="name flex">
<span>def <span class="ident">get_processes</span></span>(<span>*args) &#8209;&gt;&#160;ssize_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Take a snapshot of running processes and return their description.</div>
<div class="epy_par">
<table border="1">
<tr><td>Type</td><td>Synchronous function</td></tr>
<tr><td>Notification</td><td>function)</td></tr>
</table>
</div>
<div class="epy_par">
<strong class="epy_sig">get_processes(proclist) -&gt; ssize_t</strong><div class="epy_nested">
<strong class="epy_parameter">proclist</strong> (C++: procinfo_vec_t
*)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: number of processes or -1 on error</div>
</div></div>
</dd>
<dt id="ida_dbg.get_reg_val"><code class="name flex">
<span>def <span class="ident">get_reg_val</span></span>(<span>*args) &#8209;&gt;&#160;PyObject&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Read a register value from the current thread.
<table border="1">
<tr><td>Type</td><td>function</td></tr>
<tr><td>Notification</td><td>none (synchronous function)</td></tr>
</table>
</div>
<div class="epy_par">
<strong class="epy_sig">get_reg_val(regname, regval) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">regname</strong> (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">regval</strong> (C++: regval_t
*)</div>
</div>
<div class="epy_par">
<strong class="epy_sig">get_reg_val(regname, ival) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">regname</strong> (C++: const char *)
ival: uint64 *</div>
</div>
<div class="epy_par">
<strong class="epy_sig">get_reg_val(regname) -&gt; PyObject *</strong><div class="epy_nested">
<strong class="epy_parameter">regname</strong> (C++: const char *)</div>
</div></div>
</dd>
<dt id="ida_dbg.get_reg_vals"><code class="name flex">
<span>def <span class="ident">get_reg_vals</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">get_reg_vals(tid, clsmask, values) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">tid</strong> (C++: thid_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">clsmask</strong> (C++: int)</div>
<div class="epy_nested">
<strong class="epy_parameter">values</strong> (C++: regval_t
*)</div>
</div></div>
</dd>
<dt id="ida_dbg.get_ret_tev_return"><code class="name flex">
<span>def <span class="ident">get_ret_tev_return</span></span>(<span>*args) &#8209;&gt;&#160;ea_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get the return address from a function return trace event.
<table border="1">
<tr><td>Type</td><td>Synchronous function</td></tr>
<tr><td>Notification</td><td>none (synchronous function)</td></tr>
</table>
</div>
<div class="epy_par">
<strong class="epy_sig">get_ret_tev_return(n) -&gt; ea_t</strong><div class="epy_nested">
<strong class="epy_parameter">n</strong>: number of trace event, is in range 0.. get_tev_qty() -1. 0<div class="epy_nested">
represents the latest added trace event. (C++: int)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: BADADDR
if not a function return event.</div>
</div></div>
</dd>
<dt id="ida_dbg.get_running_notification"><code class="name flex">
<span>def <span class="ident">get_running_notification</span></span>(<span>*args) &#8209;&gt;&#160;dbg_notification_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get the notification associated (if any) with the current running
request.
<table border="1">
<tr><td>Type</td><td>Synchronous function</td></tr>
<tr><td>Notification</td><td>(synchronous function)</td></tr>
</table>
</div></div>
</dd>
<dt id="ida_dbg.get_running_request"><code class="name flex">
<span>def <span class="ident">get_running_request</span></span>(<span>*args) &#8209;&gt;&#160;ui_notification_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get the current running request.
<table border="1">
<tr><td>Type</td><td>Synchronous function</td></tr>
<tr><td>Notification</td><td>none (synchronous function)</td></tr>
</table>
</div></div>
</dd>
<dt id="ida_dbg.get_sp_val"><code class="name flex">
<span>def <span class="ident">get_sp_val</span></span>(<span>*args) &#8209;&gt;&#160;uint32&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get value of the SP register for the current thread. Requires a
suspended debugger.</div></div>
</dd>
<dt id="ida_dbg.get_srcinfo_provider"><code class="name flex">
<span>def <span class="ident">get_srcinfo_provider</span></span>(<span>*args) &#8209;&gt;&#160;srcinfo_provider_t&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">get_srcinfo_provider(name) -&gt; srcinfo_provider_t *</strong><div class="epy_nested">
<strong class="epy_parameter">name</strong> (C++: const char *)</div>
</div></div>
</dd>
<dt id="ida_dbg.get_step_trace_options"><code class="name flex">
<span>def <span class="ident">get_step_trace_options</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get current step tracing options.
<table border="1">
<tr><td>Type</td><td>Synchronous function</td></tr>
<tr><td>Notification</td><td>none (synchronous function)</td></tr>
</table>
</div></div>
</dd>
<dt id="ida_dbg.get_tev_ea"><code class="name flex">
<span>def <span class="ident">get_tev_ea</span></span>(<span>*args) &#8209;&gt;&#160;ea_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">get_tev_ea(n) -&gt; ea_t</strong><div class="epy_nested">
<strong class="epy_parameter">n</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_dbg.get_tev_event"><code class="name flex">
<span>def <span class="ident">get_tev_event</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get the corresponding debug event, if any, for the specified tev
object.
<table border="1">
<tr><td>Type</td><td>Synchronous function</td></tr>
<tr><td>Notification</td><td>(synchronous function)</td></tr>
</table>
</div>
<div class="epy_par">
<strong class="epy_sig">get_tev_event(n, d) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">n</strong>: number of trace event, is in range 0.. get_tev_qty() -1. 0<div class="epy_nested">
represents the latest added trace event. (C++: int)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">d</strong>: result (C++: debug_event_t
*)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: false if the tev_t object doesn't have any associated debug<div class="epy_nested">
event, true otherwise, with the debug event in "d".</div>
</div>
</div></div>
</dd>
<dt id="ida_dbg.get_tev_info"><code class="name flex">
<span>def <span class="ident">get_tev_info</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get main information about a trace event.
<table border="1">
<tr><td>Type</td><td>function</td></tr>
<tr><td>Notification</td><td>none (synchronous function)</td></tr>
</table>
</div>
<div class="epy_par">
<strong class="epy_sig">get_tev_info(n, tev_info) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">n</strong>: number of trace event, is in range 0.. get_tev_qty() -1. 0<div class="epy_nested">
represents the latest added trace event. (C++: int)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">tev_info</strong>: result (C++: tev_info_t
*)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: success</div>
</div></div>
</dd>
<dt id="ida_dbg.get_tev_memory_info"><code class="name flex">
<span>def <span class="ident">get_tev_memory_info</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get the memory layout, if any, for the specified tev object.
<table border="1">
<tr><td>Type</td><td>Synchronous function</td></tr>
<tr><td>Notification</td><td>none (synchronous function)</td></tr>
</table>
</div>
<div class="epy_par">
<strong class="epy_sig">get_tev_memory_info(n, mi) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">n</strong>: number of trace event, is in range 0.. get_tev_qty() -1. 0<div class="epy_nested">
represents the latest added trace event. (C++: int)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">mi</strong>: result (C++: meminfo_vec_t
*)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: false if the tev_t object is not of type
tev_mem , true<div class="epy_nested">
otherwise, with the new memory layout in "mi".</div>
</div>
</div></div>
</dd>
<dt id="ida_dbg.get_tev_qty"><code class="name flex">
<span>def <span class="ident">get_tev_qty</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get number of trace events available in trace buffer.
<table border="1">
<tr><td>Type</td><td>Synchronous function</td></tr>
<tr><td>Notification</td><td>none (synchronous function)</td></tr>
</table>
</div></div>
</dd>
<dt id="ida_dbg.get_tev_reg_mem"><code class="name flex">
<span>def <span class="ident">get_tev_reg_mem</span></span>(<span>tev, idx)</span>
</code></dt>
<dd>
<div class="desc"/>
</dd>
<dt id="ida_dbg.get_tev_reg_mem_ea"><code class="name flex">
<span>def <span class="ident">get_tev_reg_mem_ea</span></span>(<span>tev, idx)</span>
</code></dt>
<dd>
<div class="desc"/>
</dd>
<dt id="ida_dbg.get_tev_reg_mem_qty"><code class="name flex">
<span>def <span class="ident">get_tev_reg_mem_qty</span></span>(<span>tev)</span>
</code></dt>
<dd>
<div class="desc"/>
</dd>
<dt id="ida_dbg.get_tev_reg_val"><code class="name flex">
<span>def <span class="ident">get_tev_reg_val</span></span>(<span>tev, reg)</span>
</code></dt>
<dd>
<div class="desc"/>
</dd>
<dt id="ida_dbg.get_tev_tid"><code class="name flex">
<span>def <span class="ident">get_tev_tid</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">get_tev_tid(n) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">n</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_dbg.get_tev_type"><code class="name flex">
<span>def <span class="ident">get_tev_type</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">get_tev_type(n) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">n</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_dbg.get_thread_qty"><code class="name flex">
<span>def <span class="ident">get_thread_qty</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get number of threads.
<table border="1">
<tr><td>Type</td><td>Synchronous function</td></tr>
<tr><td>Notification</td><td>none (synchronous function)</td></tr>
</table>
</div></div>
</dd>
<dt id="ida_dbg.get_trace_base_address"><code class="name flex">
<span>def <span class="ident">get_trace_base_address</span></span>(<span>*args) &#8209;&gt;&#160;ea_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get the base address of the current trace.
<table border="1">
<tr><td>Type</td><td>function</td></tr>
<tr><td>Notification</td><td>none (synchronous function)</td></tr>
</table>
</div></div>
</dd>
<dt id="ida_dbg.get_trace_dynamic_register_set"><code class="name flex">
<span>def <span class="ident">get_trace_dynamic_register_set</span></span>(<span>*args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get dynamic register set of current trace.</div>
<div class="epy_par">
<strong class="epy_sig">get_trace_dynamic_register_set(idaregs)</strong><div class="epy_nested">
<strong class="epy_parameter">idaregs</strong> (C++: dynamic_register_set_t
*)</div>
</div></div>
</dd>
<dt id="ida_dbg.get_trace_file_desc"><code class="name flex">
<span>def <span class="ident">get_trace_file_desc</span></span>(<span>*args) &#8209;&gt;&#160;qstring&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get the file header of the specified trace file.</div>
<div class="epy_par">
<strong class="epy_sig">get_trace_file_desc(filename) -&gt; str</strong><div class="epy_nested">
<strong class="epy_parameter">filename</strong> (C++: const char *)</div>
</div></div>
</dd>
<dt id="ida_dbg.get_trace_platform"><code class="name flex">
<span>def <span class="ident">get_trace_platform</span></span>(<span>*args) &#8209;&gt;&#160;char&#160;const&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get platform name of current trace.</div></div>
</dd>
<dt id="ida_dbg.getn_bpt"><code class="name flex">
<span>def <span class="ident">getn_bpt</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get the characteristics of a breakpoint.
<table border="1">
<tr><td>Type</td><td>function</td></tr>
<tr><td>Notification</td><td>none (synchronous function)</td></tr>
</table>
</div>
<div class="epy_par">
<strong class="epy_sig">getn_bpt(n, bpt) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">n</strong>: number of breakpoint, is in range 0.. get_bpt_qty() -1 (C++:<div class="epy_nested">
int)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">bpt</strong>: filled with the characteristics. (C++: bpt_t
*)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: false if no breakpoint exists</div>
</div></div>
</dd>
<dt id="ida_dbg.getn_thread"><code class="name flex">
<span>def <span class="ident">getn_thread</span></span>(<span>*args) &#8209;&gt;&#160;thid_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get the ID of a thread.
<table border="1">
<tr><td>Type</td><td>Synchronous function</td></tr>
<tr><td>Notification</td><td>none (synchronous function)</td></tr>
</table>
</div>
<div class="epy_par">
<strong class="epy_sig">getn_thread(n) -&gt; thid_t</strong><div class="epy_nested">
<strong class="epy_parameter">n</strong>: number of thread, is in range 0.. get_thread_qty() -1 (C++:<div class="epy_nested">
int)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: NO_THREAD
if the thread doesn't exist.</div>
</div></div>
</dd>
<dt id="ida_dbg.getn_thread_name"><code class="name flex">
<span>def <span class="ident">getn_thread_name</span></span>(<span>*args) &#8209;&gt;&#160;char&#160;const&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get the NAME of a thread
<table border="1">
<tr><td>Type</td><td>Synchronous function</td></tr>
<tr><td>Notification</td><td>none (synchronous function)</td></tr>
</table>
</div>
<div class="epy_par">
<strong class="epy_sig">getn_thread_name(n) -&gt; char const *</strong><div class="epy_nested">
<strong class="epy_parameter">n</strong>: number of thread, is in range 0.. get_thread_qty() -1 or -1<div class="epy_nested">
for the current thread (C++: int)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: thread name or NULL if the thread doesn't exist.</div>
</div></div>
</dd>
<dt id="ida_dbg.graph_trace"><code class="name flex">
<span>def <span class="ident">graph_trace</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Show the trace callgraph.</div></div>
</dd>
<dt id="ida_dbg.handle_debug_event"><code class="name flex">
<span>def <span class="ident">handle_debug_event</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">handle_debug_event(ev, rqflags) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">ev</strong> (C++: const
debug_event_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">rqflags</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_dbg.hide_all_bpts"><code class="name flex">
<span>def <span class="ident">hide_all_bpts</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">hide_all_bpts() -&gt; int</strong></div></div>
</dd>
<dt id="ida_dbg.internal_get_sreg_base"><code class="name flex">
<span>def <span class="ident">internal_get_sreg_base</span></span>(<span>*args) &#8209;&gt;&#160;ea_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">internal_get_sreg_base(tid, sreg_value) -&gt; ea_t</strong><div class="epy_nested">
Get the sreg base, for the given thread.</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: The sreg base, or BADADDR on failure.</div>
</div></div>
</dd>
<dt id="ida_dbg.internal_ioctl"><code class="name flex">
<span>def <span class="ident">internal_ioctl</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">internal_ioctl(fn, buf, poutbuf, poutsize) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">fn</strong> (C++: int)</div>
<div class="epy_nested">
<strong class="epy_parameter">buf</strong> (C++: const void *)</div>
<div class="epy_nested">
<strong class="epy_parameter">poutbuf</strong> (C++: void **)</div>
<div class="epy_nested">
<strong class="epy_parameter">poutsize</strong> (C++: ssize_t
*)</div>
</div></div>
</dd>
<dt id="ida_dbg.invalidate_dbg_state"><code class="name flex">
<span>def <span class="ident">invalidate_dbg_state</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Invalidate cached debugger information.
<table border="1">
<tr><td>Type</td><td>function</td></tr>
<tr><td>Notification</td><td>none (synchronous function)</td></tr>
</table>
</div>
<div class="epy_par">
<strong class="epy_sig">invalidate_dbg_state(dbginv) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">dbginv</strong>: Debugged process invalidation options (C++: int)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: current debugger state (one of
Debugged process states )</div>
</div></div>
</dd>
<dt id="ida_dbg.invalidate_dbgmem_config"><code class="name flex">
<span>def <span class="ident">invalidate_dbgmem_config</span></span>(<span>*args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Invalidate the debugged process memory configuration. Call this
function if the debugged process might have changed its memory layout
(allocated more memory, for example)</div></div>
</dd>
<dt id="ida_dbg.invalidate_dbgmem_contents"><code class="name flex">
<span>def <span class="ident">invalidate_dbgmem_contents</span></span>(<span>*args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Invalidate the debugged process memory contents. Call this function
each time the process has been stopped or the process memory is
modified. If ea == 'BADADDR' , then the whole memory contents will be
invalidated</div>
<div class="epy_par">
<strong class="epy_sig">invalidate_dbgmem_contents(ea, size)</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">size</strong> (C++: asize_t)</div>
</div></div>
</dd>
<dt id="ida_dbg.is_bblk_trace_enabled"><code class="name flex">
<span>def <span class="ident">is_bblk_trace_enabled</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">is_bblk_trace_enabled() -&gt; bool</strong></div></div>
</dd>
<dt id="ida_dbg.is_debugger_busy"><code class="name flex">
<span>def <span class="ident">is_debugger_busy</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is the debugger busy?. Some debuggers do not accept any commands while
the debugged application is running. For such a debugger, it is unsafe
to do anything with the database (even simple queries like get_byte
may lead to undesired consequences). Returns: true if the debugged
application is running under such a debugger</div></div>
</dd>
<dt id="ida_dbg.is_debugger_memory"><code class="name flex">
<span>def <span class="ident">is_debugger_memory</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is the address mapped to debugger memory?</div>
<div class="epy_par">
<strong class="epy_sig">is_debugger_memory(ea) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
</div></div>
</dd>
<dt id="ida_dbg.is_debugger_on"><code class="name flex">
<span>def <span class="ident">is_debugger_on</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is the debugger currently running?</div></div>
</dd>
<dt id="ida_dbg.is_func_trace_enabled"><code class="name flex">
<span>def <span class="ident">is_func_trace_enabled</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get current state of functions tracing.
<table border="1">
<tr><td>Type</td><td>function</td></tr>
<tr><td>Notification</td><td>none (synchronous function)</td></tr>
</table>
</div></div>
</dd>
<dt id="ida_dbg.is_insn_trace_enabled"><code class="name flex">
<span>def <span class="ident">is_insn_trace_enabled</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get current state of instruction tracing.
<table border="1">
<tr><td>Type</td><td>function</td></tr>
<tr><td>Notification</td><td>none (synchronous function)</td></tr>
</table>
</div></div>
</dd>
<dt id="ida_dbg.is_reg_custom"><code class="name flex">
<span>def <span class="ident">is_reg_custom</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Does a register contain a value of a custom data type?
<table border="1">
<tr><td>Type</td><td>Synchronous function</td></tr>
<tr><td>Notification</td><td>none (synchronous function)</td></tr>
</table>
</div>
<div class="epy_par">
<strong class="epy_sig">is_reg_custom(regname) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">regname</strong> (C++: const char *)</div>
</div></div>
</dd>
<dt id="ida_dbg.is_reg_float"><code class="name flex">
<span>def <span class="ident">is_reg_float</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Does a register contain a floating point value?
<table border="1">
<tr><td>Type</td><td>function</td></tr>
<tr><td>Notification</td><td>none (synchronous function)</td></tr>
</table>
</div>
<div class="epy_par">
<strong class="epy_sig">is_reg_float(regname) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">regname</strong> (C++: const char *)</div>
</div></div>
</dd>
<dt id="ida_dbg.is_reg_integer"><code class="name flex">
<span>def <span class="ident">is_reg_integer</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Does a register contain an integer value?
<table border="1">
<tr><td>Type</td><td>function</td></tr>
<tr><td>Notification</td><td>none (synchronous function)</td></tr>
</table>
</div>
<div class="epy_par">
<strong class="epy_sig">is_reg_integer(regname) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">regname</strong> (C++: const char *)</div>
</div></div>
</dd>
<dt id="ida_dbg.is_request_running"><code class="name flex">
<span>def <span class="ident">is_request_running</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is a request currently running?</div></div>
</dd>
<dt id="ida_dbg.is_step_trace_enabled"><code class="name flex">
<span>def <span class="ident">is_step_trace_enabled</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get current state of step tracing.
<table border="1">
<tr><td>Type</td><td>Synchronous function</td></tr>
<tr><td>Notification</td><td>none (synchronous function)</td></tr>
</table>
</div></div>
</dd>
<dt id="ida_dbg.is_valid_trace_file"><code class="name flex">
<span>def <span class="ident">is_valid_trace_file</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is the specified file a valid trace file for the current database?</div>
<div class="epy_par">
<strong class="epy_sig">is_valid_trace_file(filename) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">filename</strong> (C++: const char *)</div>
</div></div>
</dd>
<dt id="ida_dbg.list_bptgrps"><code class="name flex">
<span>def <span class="ident">list_bptgrps</span></span>(<span>*args) &#8209;&gt;&#160;PyObject&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">list_bptgrps(bptgrps) -&gt; size_t</strong><div class="epy_nested">
<strong class="epy_parameter">bptgrps</strong> (C++: qstrvec_t
*)</div>
</div></div>
</dd>
<dt id="ida_dbg.load_debugger"><code class="name flex">
<span>def <span class="ident">load_debugger</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">load_debugger(dbgname, use_remote) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">dbgname</strong> (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">use_remote</strong> (C++: bool)</div>
</div></div>
</dd>
<dt id="ida_dbg.load_trace_file"><code class="name flex">
<span>def <span class="ident">load_trace_file</span></span>(<span>*args) &#8209;&gt;&#160;qstring&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Load a recorded trace file in the 'Tracing' window. If the call
succeeds and 'buf' is not null, the description of the trace stored in
the binary trace file will be returned in 'buf'</div>
<div class="epy_par">
<strong class="epy_sig">load_trace_file(filename) -&gt; str</strong><div class="epy_nested">
<strong class="epy_parameter">filename</strong> (C++: const char *)</div>
</div></div>
</dd>
<dt id="ida_dbg.move_bpt_to_grp"><code class="name flex">
<span>def <span class="ident">move_bpt_to_grp</span></span>(<span>*args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">move_bpt_to_grp(bpt, grp_name)</strong><div class="epy_nested">
Sets new group for the breakpoint</div>
</div></div>
</dd>
<dt id="ida_dbg.put_dbg_byte"><code class="name flex">
<span>def <span class="ident">put_dbg_byte</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Change one byte of the debugged process memory.</div>
<div class="epy_par">
<strong class="epy_sig">put_dbg_byte(ea, x) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong>: linear address (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">x</strong>: byte value (C++: uint32)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: true if the process memory has been modified</div>
</div></div>
</dd>
<dt id="ida_dbg.read_dbg_memory"><code class="name flex">
<span>def <span class="ident">read_dbg_memory</span></span>(<span>*args) &#8209;&gt;&#160;ssize_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">read_dbg_memory(ea, buffer, size) -&gt; ssize_t</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">buffer</strong> (C++: void *)</div>
<div class="epy_nested">
<strong class="epy_parameter">size</strong> (C++: size_t)</div>
</div></div>
</dd>
<dt id="ida_dbg.refresh_debugger_memory"><code class="name flex">
<span>def <span class="ident">refresh_debugger_memory</span></span>(<span>*args) &#8209;&gt;&#160;PyObject&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">refresh_debugger_memory() -&gt; PyObject *</strong><div class="epy_nested">
Refreshes the debugger memory</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: Nothing</div>
</div></div>
</dd>
<dt id="ida_dbg.rename_bptgrp"><code class="name flex">
<span>def <span class="ident">rename_bptgrp</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">rename_bptgrp(old_name, new_name) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">old_name</strong> (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">new_name</strong> (C++: const char *)</div>
</div></div>
</dd>
<dt id="ida_dbg.request_add_bpt"><code class="name flex">
<span>def <span class="ident">request_add_bpt</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Post an 'add_bpt(ea_t, asize_t, bpttype_t)' request.</div>
<div class="epy_par">
<strong class="epy_sig">request_add_bpt(ea, size=0, type=BPT_DEFAULT) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">size</strong> (C++: asize_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">type</strong> (C++: bpttype_t)</div>
</div>
<div class="epy_par">
<strong class="epy_sig">request_add_bpt(bpt) -&gt; bool</strong><div class="epy_nested">
bpt: bpt_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_dbg.request_attach_process"><code class="name flex">
<span>def <span class="ident">request_attach_process</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Post an 'attach_process()' request.</div>
<div class="epy_par">
<strong class="epy_sig">request_attach_process(pid, event_id) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">pid</strong> (C++: pid_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">event_id</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_dbg.request_clear_trace"><code class="name flex">
<span>def <span class="ident">request_clear_trace</span></span>(<span>*args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Post a 'clear_trace()' request.</div></div>
</dd>
<dt id="ida_dbg.request_continue_process"><code class="name flex">
<span>def <span class="ident">request_continue_process</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Post a 'continue_process()' request.This requires an explicit call to
'run_requests()'</div></div>
</dd>
<dt id="ida_dbg.request_del_bpt"><code class="name flex">
<span>def <span class="ident">request_del_bpt</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Post a 'del_bpt(ea_t)' request.</div>
<div class="epy_par">
<strong class="epy_sig">request_del_bpt(ea) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
</div>
<div class="epy_par">
<strong class="epy_sig">request_del_bpt(bptloc) -&gt; bool</strong><div class="epy_nested">
bptloc: bpt_location_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_dbg.request_detach_process"><code class="name flex">
<span>def <span class="ident">request_detach_process</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Post a 'detach_process()' request.</div></div>
</dd>
<dt id="ida_dbg.request_disable_bblk_trace"><code class="name flex">
<span>def <span class="ident">request_disable_bblk_trace</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">request_disable_bblk_trace() -&gt; bool</strong></div></div>
</dd>
<dt id="ida_dbg.request_disable_bpt"><code class="name flex">
<span>def <span class="ident">request_disable_bpt</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">request_disable_bpt(ea) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
</div>
<div class="epy_par">
<strong class="epy_sig">request_disable_bpt(bptloc) -&gt; bool</strong><div class="epy_nested">
bptloc: bpt_location_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_dbg.request_disable_func_trace"><code class="name flex">
<span>def <span class="ident">request_disable_func_trace</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">request_disable_func_trace() -&gt; bool</strong></div></div>
</dd>
<dt id="ida_dbg.request_disable_insn_trace"><code class="name flex">
<span>def <span class="ident">request_disable_insn_trace</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">request_disable_insn_trace() -&gt; bool</strong></div></div>
</dd>
<dt id="ida_dbg.request_disable_step_trace"><code class="name flex">
<span>def <span class="ident">request_disable_step_trace</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">request_disable_step_trace() -&gt; bool</strong></div></div>
</dd>
<dt id="ida_dbg.request_enable_bblk_trace"><code class="name flex">
<span>def <span class="ident">request_enable_bblk_trace</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">request_enable_bblk_trace(enable=True) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">enable</strong> (C++: bool)</div>
</div></div>
</dd>
<dt id="ida_dbg.request_enable_bpt"><code class="name flex">
<span>def <span class="ident">request_enable_bpt</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">request_enable_bpt(ea, enable=True) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">enable</strong> (C++: bool)</div>
</div>
<div class="epy_par">
<strong class="epy_sig">request_enable_bpt(bptloc, enable=True) -&gt; bool</strong><div class="epy_nested">
bptloc: bpt_location_t const &amp;</div>
<div class="epy_nested">
<strong class="epy_parameter">enable</strong> (C++: bool)</div>
</div></div>
</dd>
<dt id="ida_dbg.request_enable_func_trace"><code class="name flex">
<span>def <span class="ident">request_enable_func_trace</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">request_enable_func_trace(enable=True) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">enable</strong> (C++: bool)</div>
</div></div>
</dd>
<dt id="ida_dbg.request_enable_insn_trace"><code class="name flex">
<span>def <span class="ident">request_enable_insn_trace</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">request_enable_insn_trace(enable=True) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">enable</strong> (C++: bool)</div>
</div></div>
</dd>
<dt id="ida_dbg.request_enable_step_trace"><code class="name flex">
<span>def <span class="ident">request_enable_step_trace</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">request_enable_step_trace(enable=1) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">enable</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_dbg.request_exit_process"><code class="name flex">
<span>def <span class="ident">request_exit_process</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Post an 'exit_process()' request.</div></div>
</dd>
<dt id="ida_dbg.request_resume_thread"><code class="name flex">
<span>def <span class="ident">request_resume_thread</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Post a 'resume_thread()' request.</div>
<div class="epy_par">
<strong class="epy_sig">request_resume_thread(tid) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">tid</strong> (C++: thid_t)</div>
</div></div>
</dd>
<dt id="ida_dbg.request_run_to"><code class="name flex">
<span>def <span class="ident">request_run_to</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Post a 'run_to()' request.</div>
<div class="epy_par">
request_run_to(ea, pid=pid_t(-1), tid=0) -&gt; bool<div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">pid</strong> (C++: pid_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">tid</strong> (C++: thid_t)</div>
</div></div>
</dd>
<dt id="ida_dbg.request_select_thread"><code class="name flex">
<span>def <span class="ident">request_select_thread</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Post a 'select_thread()' request.</div>
<div class="epy_par">
<strong class="epy_sig">request_select_thread(tid) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">tid</strong> (C++: thid_t)</div>
</div></div>
</dd>
<dt id="ida_dbg.request_set_bblk_trace_options"><code class="name flex">
<span>def <span class="ident">request_set_bblk_trace_options</span></span>(<span>*args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Post a 'set_bblk_trace_options()' request.</div>
<div class="epy_par">
<strong class="epy_sig">request_set_bblk_trace_options(options)</strong><div class="epy_nested">
<strong class="epy_parameter">options</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_dbg.request_set_func_trace_options"><code class="name flex">
<span>def <span class="ident">request_set_func_trace_options</span></span>(<span>*args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Post a 'set_func_trace_options()' request.</div>
<div class="epy_par">
<strong class="epy_sig">request_set_func_trace_options(options)</strong><div class="epy_nested">
<strong class="epy_parameter">options</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_dbg.request_set_insn_trace_options"><code class="name flex">
<span>def <span class="ident">request_set_insn_trace_options</span></span>(<span>*args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Post a 'set_insn_trace_options()' request.</div>
<div class="epy_par">
<strong class="epy_sig">request_set_insn_trace_options(options)</strong><div class="epy_nested">
<strong class="epy_parameter">options</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_dbg.request_set_reg_val"><code class="name flex">
<span>def <span class="ident">request_set_reg_val</span></span>(<span>*args) &#8209;&gt;&#160;PyObject&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Post a 'set_reg_val()' request.</div>
<div class="epy_par">
<strong class="epy_sig">request_set_reg_val(regname, o) -&gt; PyObject *</strong><div class="epy_nested">
<strong class="epy_parameter">regname</strong> (C++: const char *)
o: PyObject *</div>
</div></div>
</dd>
<dt id="ida_dbg.request_set_resume_mode"><code class="name flex">
<span>def <span class="ident">request_set_resume_mode</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Post a 'set_resume_mode()' request.</div>
<div class="epy_par">
<strong class="epy_sig">request_set_resume_mode(tid, mode) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">tid</strong> (C++: thid_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">mode</strong> (C++: resume_mode_t)</div>
</div></div>
</dd>
<dt id="ida_dbg.request_set_step_trace_options"><code class="name flex">
<span>def <span class="ident">request_set_step_trace_options</span></span>(<span>*args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Post a 'set_step_trace_options()' request.</div>
<div class="epy_par">
<strong class="epy_sig">request_set_step_trace_options(options)</strong><div class="epy_nested">
<strong class="epy_parameter">options</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_dbg.request_start_process"><code class="name flex">
<span>def <span class="ident">request_start_process</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Post a 'start_process()' request.</div>
<div class="epy_par">
<strong class="epy_sig">request_start_process(path=None, args=None, sdir=None) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">path</strong> (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">args</strong> (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">sdir</strong> (C++: const char *)</div>
</div></div>
</dd>
<dt id="ida_dbg.request_step_into"><code class="name flex">
<span>def <span class="ident">request_step_into</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Post a 'step_into()' request.</div></div>
</dd>
<dt id="ida_dbg.request_step_over"><code class="name flex">
<span>def <span class="ident">request_step_over</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Post a 'step_over()' request.</div></div>
</dd>
<dt id="ida_dbg.request_step_until_ret"><code class="name flex">
<span>def <span class="ident">request_step_until_ret</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Post a 'step_until_ret()' request.</div></div>
</dd>
<dt id="ida_dbg.request_suspend_process"><code class="name flex">
<span>def <span class="ident">request_suspend_process</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Post a 'suspend_process()' request.</div></div>
</dd>
<dt id="ida_dbg.request_suspend_thread"><code class="name flex">
<span>def <span class="ident">request_suspend_thread</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Post a 'suspend_thread()' request.</div>
<div class="epy_par">
<strong class="epy_sig">request_suspend_thread(tid) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">tid</strong> (C++: thid_t)</div>
</div></div>
</dd>
<dt id="ida_dbg.resume_thread"><code class="name flex">
<span>def <span class="ident">resume_thread</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Resume thread.
<table border="1">
<tr><td>Type</td><td>Synchronous function - available as request</td></tr>
<tr><td>Notification</td><td>none (synchronous function)</td></tr>
</table>
</div>
<div class="epy_par">
<strong class="epy_sig">resume_thread(tid) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">tid</strong>: thread id (C++: thid_t)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: -1 - network error</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - failed</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 - ok</div>
</div></div>
</dd>
<dt id="ida_dbg.retrieve_exceptions"><code class="name flex">
<span>def <span class="ident">retrieve_exceptions</span></span>(<span>*args) &#8209;&gt;&#160;excvec_t&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Retrieve the exception information. You may freely modify the returned
vector and add/edit/delete exceptions You must call
'store_exceptions()' after any modifications Note: exceptions with
code zero, multiple exception codes or names are prohibited</div></div>
</dd>
<dt id="ida_dbg.run_requests"><code class="name flex">
<span>def <span class="ident">run_requests</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Execute requests until all requests are processed or an asynchronous
function is called.
<table border="1">
<tr><td>Type</td><td>Synchronous function</td></tr>
<tr><td>Notification</td><td>(synchronous function)</td></tr>
</table>
If called from a notification handler, the
execution of requests will be postponed to the end of the execution of
all notification handlers.</div></div>
</dd>
<dt id="ida_dbg.run_to"><code class="name flex">
<span>def <span class="ident">run_to</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Execute the process until the given address is reached. If no process
is active, a new process is started. Technically, the debugger sets up
a temporary breakpoint at the given address, and continues (or starts)
the execution of the whole process. So, all threads continue their
execution!
<table border="1">
<tr><td>Type</td><td>Asynchronous function - available as Request</td></tr>
<tr><td>Notification</td><td>'dbg_run_to'</td></tr>
</table>
</div>
<div class="epy_par">
run_to(ea, pid=pid_t(-1), tid=0) -&gt; bool<div class="epy_nested">
<strong class="epy_parameter">ea</strong>: target address (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">pid</strong>: not used yet. please do not specify this parameter. (C++:<div class="epy_nested">
pid_t)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">tid</strong>: not used yet. please do not specify this parameter. (C++:<div class="epy_nested">
thid_t)</div>
</div>
</div></div>
</dd>
<dt id="ida_dbg.save_trace_file"><code class="name flex">
<span>def <span class="ident">save_trace_file</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Save the current trace in the specified file.</div>
<div class="epy_par">
<strong class="epy_sig">save_trace_file(filename, description) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">filename</strong> (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">description</strong> (C++: const char *)</div>
</div></div>
</dd>
<dt id="ida_dbg.select_thread"><code class="name flex">
<span>def <span class="ident">select_thread</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Select the given thread as the current debugged thread. All thread
related execution functions will work on this thread. The process must
be suspended to select a new thread.
<table border="1">
<tr><td>Type</td><td>available as request</td></tr>
<tr><td>Notification</td><td>none (synchronous function)</td></tr>
</table>
</div>
<div class="epy_par">
<strong class="epy_sig">select_thread(tid) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">tid</strong>: ID of the thread to select (C++: thid_t)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: false if the thread doesn't exist.</div>
</div></div>
</dd>
<dt id="ida_dbg.send_dbg_command"><code class="name flex">
<span>def <span class="ident">send_dbg_command</span></span>(<span>command)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Send a direct command to the debugger backend, and
retrieve the result as a string.</div>
<div class="epy_par">
Note: any double-quotes in 'command' must be backslash-escaped.
Note: this only works with some debugger backends: Bochs, WinDbg, GDB.</div>
<div class="epy_par">
Returns: (True, <result string="">) on success, or (False, <error message="" string="">) on failure</error></result></div></div>
</dd>
<dt id="ida_dbg.set_bblk_trace_options"><code class="name flex">
<span>def <span class="ident">set_bblk_trace_options</span></span>(<span>*args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Modify basic block tracing options (see 'BT_LOG_INSTS' )</div>
<div class="epy_par">
<strong class="epy_sig">set_bblk_trace_options(options)</strong><div class="epy_nested">
<strong class="epy_parameter">options</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_dbg.set_bpt_group"><code class="name flex">
<span>def <span class="ident">set_bpt_group</span></span>(<span>*args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">set_bpt_group(bpt, grp_name)</strong><div class="epy_nested">
<strong class="epy_parameter">bpt</strong> (C++: bpt_t
&amp;)</div>
<div class="epy_nested">
<strong class="epy_parameter">grp_name</strong> (C++: const char *)</div>
</div></div>
</dd>
<dt id="ida_dbg.set_bptloc_group"><code class="name flex">
<span>def <span class="ident">set_bptloc_group</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">set_bptloc_group(bptloc, grp_name) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">bptloc</strong> (C++: const
bpt_location_t
&amp;)</div>
<div class="epy_nested">
<strong class="epy_parameter">grp_name</strong> (C++: const char *)</div>
</div></div>
</dd>
<dt id="ida_dbg.set_bptloc_string"><code class="name flex">
<span>def <span class="ident">set_bptloc_string</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Helper function for 'bpt_location_t' .</div>
<div class="epy_par">
<strong class="epy_sig">set_bptloc_string(s) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">s</strong> (C++: const char *)</div>
</div></div>
</dd>
<dt id="ida_dbg.set_debugger_event_cond"><code class="name flex">
<span>def <span class="ident">set_debugger_event_cond</span></span>(<span>*args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">set_debugger_event_cond(evcond)</strong><div class="epy_nested">
<strong class="epy_parameter">evcond</strong> (C++: const char *)</div>
</div></div>
</dd>
<dt id="ida_dbg.set_debugger_options"><code class="name flex">
<span>def <span class="ident">set_debugger_options</span></span>(<span>*args) &#8209;&gt;&#160;uint</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Set debugger options. Replaces debugger options with the specification
combination 'Debugger options'</div>
<div class="epy_par">
<strong class="epy_sig">set_debugger_options(options) -&gt; uint</strong><div class="epy_nested">
<strong class="epy_parameter">options</strong> (C++: uint)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: the old debugger options</div>
</div></div>
</dd>
<dt id="ida_dbg.set_func_trace_options"><code class="name flex">
<span>def <span class="ident">set_func_trace_options</span></span>(<span>*args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Modify function tracing options.
<table border="1">
<tr><td>Type</td><td>available as request</td></tr>
<tr><td>Notification</td><td>none (synchronous function)</td></tr>
</table>
</div>
<div class="epy_par">
<strong class="epy_sig">set_func_trace_options(options)</strong><div class="epy_nested">
<strong class="epy_parameter">options</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_dbg.set_highlight_trace_options"><code class="name flex">
<span>def <span class="ident">set_highlight_trace_options</span></span>(<span>*args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Set highlight trace parameters.</div>
<div class="epy_par">
<strong class="epy_sig">set_highlight_trace_options(hilight, color, diff)</strong><div class="epy_nested">
<strong class="epy_parameter">hilight</strong> (C++: bool)</div>
<div class="epy_nested">
<strong class="epy_parameter">color</strong> (C++: bgcolor_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">diff</strong> (C++: bgcolor_t)</div>
</div></div>
</dd>
<dt id="ida_dbg.set_insn_trace_options"><code class="name flex">
<span>def <span class="ident">set_insn_trace_options</span></span>(<span>*args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Modify instruction tracing options.
<table border="1">
<tr><td>Type</td><td>available as request</td></tr>
<tr><td>Notification</td><td>none (synchronous function)</td></tr>
</table>
</div>
<div class="epy_par">
<strong class="epy_sig">set_insn_trace_options(options)</strong><div class="epy_nested">
<strong class="epy_parameter">options</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_dbg.set_manual_regions"><code class="name flex">
<span>def <span class="ident">set_manual_regions</span></span>(<span>*args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">set_manual_regions(ranges)</strong><div class="epy_nested">
<strong class="epy_parameter">ranges</strong> (C++: const
meminfo_vec_t
*)</div>
</div></div>
</dd>
<dt id="ida_dbg.set_process_options"><code class="name flex">
<span>def <span class="ident">set_process_options</span></span>(<span>*args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Set process options. Any of the arguments may be NULL, which means 'do
not modify'</div>
<div class="epy_par">
<strong class="epy_sig">set_process_options(path, args, sdir, host, _pass, port)</strong><div class="epy_nested">
<strong class="epy_parameter">path</strong> (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">args</strong> (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">sdir</strong> (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">host</strong> (C++: const char *)
pass: char const *</div>
<div class="epy_nested">
<strong class="epy_parameter">port</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_dbg.set_process_state"><code class="name flex">
<span>def <span class="ident">set_process_state</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Set new state for the debugged process. Notifies the IDA kernel about
the change of the debugged process state. For example, a debugger
module could call this function when it knows that the process is
suspended for a short period of time. Some IDA API calls can be made
only when the process is suspended. The process state is usually
restored before returning control to the caller. You must know that it
is ok to change the process state, doing it at arbitrary moments may
crash the application or IDA.
<table border="1">
<tr><td>Type</td><td>Synchronous function</td></tr>
<tr><td>Notification</td><td>none (synchronous function)</td></tr>
</table>
</div>
<div class="epy_par">
<strong class="epy_sig">set_process_state(newstate, p_thid, dbginv) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">newstate</strong>: new process state (one of
Debugged process states )<div class="epy_nested">
if
DSTATE_NOTASK
is passed then the state is not
changed (C++: int)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">p_thid</strong>: ptr to new thread id. may be NULL or pointer to<div class="epy_nested">
NO_THREAD . the pointed variable will contain the old
thread id upon return (C++: thid_t
*)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">dbginv</strong>: Debugged process invalidation options (C++: int)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: old debugger state (one of
Debugged process states )</div>
</div></div>
</dd>
<dt id="ida_dbg.set_reg_val"><code class="name flex">
<span>def <span class="ident">set_reg_val</span></span>(<span>*args) &#8209;&gt;&#160;PyObject&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Write a register value to the current thread.
<table border="1">
<tr><td>Type</td><td>function - available as Request</td></tr>
<tr><td>Notification</td><td>function)</td></tr>
</table>
</div>
<div class="epy_par">
<strong class="epy_sig">set_reg_val(regname, o) -&gt; PyObject</strong><div class="epy_nested">
<strong class="epy_parameter">regname</strong> (C++: const char *)
o: PyObject *</div>
</div>
<div class="epy_par">
<strong class="epy_sig">set_reg_val(tid, regidx, o) -&gt; PyObject *</strong><div class="epy_nested">
tid: thid_t
regidx: int
o: PyObject *</div>
</div></div>
</dd>
<dt id="ida_dbg.set_remote_debugger"><code class="name flex">
<span>def <span class="ident">set_remote_debugger</span></span>(<span>*args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Set remote debugging options. Should be used before starting the
debugger.</div>
<div class="epy_par">
<strong class="epy_sig">set_remote_debugger(host, _pass, port=-1)</strong><div class="epy_nested">
<strong class="epy_parameter">host</strong>: If empty, IDA will use local debugger. If NULL, the host<div class="epy_nested">
will not be set. (C++: const char *)</div>
</div>
<div class="epy_nested">
pass: char const *</div>
<div class="epy_nested">
<strong class="epy_parameter">port</strong>: If -1, the default port number will be used (C++: int)</div>
</div></div>
</dd>
<dt id="ida_dbg.set_resume_mode"><code class="name flex">
<span>def <span class="ident">set_resume_mode</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
How to resume the application. Set resume mode but do not resume
process.</div>
<div class="epy_par">
<strong class="epy_sig">set_resume_mode(tid, mode) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">tid</strong> (C++: thid_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">mode</strong> (C++: resume_mode_t)</div>
</div></div>
</dd>
<dt id="ida_dbg.set_step_trace_options"><code class="name flex">
<span>def <span class="ident">set_step_trace_options</span></span>(<span>*args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Modify step tracing options.
<table border="1">
<tr><td>Type</td><td>available as request</td></tr>
<tr><td>Notification</td><td>none (synchronous function)</td></tr>
</table>
</div>
<div class="epy_par">
<strong class="epy_sig">set_step_trace_options(options)</strong><div class="epy_nested">
<strong class="epy_parameter">options</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_dbg.set_trace_base_address"><code class="name flex">
<span>def <span class="ident">set_trace_base_address</span></span>(<span>*args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Set the base address of the current trace.
<table border="1">
<tr><td>Type</td><td>function</td></tr>
<tr><td>Notification</td><td>none (synchronous function)</td></tr>
</table>
</div>
<div class="epy_par">
<strong class="epy_sig">set_trace_base_address(ea)</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
</div></div>
</dd>
<dt id="ida_dbg.set_trace_dynamic_register_set"><code class="name flex">
<span>def <span class="ident">set_trace_dynamic_register_set</span></span>(<span>*args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Set dynamic register set of current trace.</div>
<div class="epy_par">
<strong class="epy_sig">set_trace_dynamic_register_set(idaregs)</strong><div class="epy_nested">
<strong class="epy_parameter">idaregs</strong> (C++: dynamic_register_set_t
&amp;)</div>
</div></div>
</dd>
<dt id="ida_dbg.set_trace_file_desc"><code class="name flex">
<span>def <span class="ident">set_trace_file_desc</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Change the description of the specified trace file.</div>
<div class="epy_par">
<strong class="epy_sig">set_trace_file_desc(filename, description) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">filename</strong> (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">description</strong> (C++: const char *)</div>
</div></div>
</dd>
<dt id="ida_dbg.set_trace_platform"><code class="name flex">
<span>def <span class="ident">set_trace_platform</span></span>(<span>*args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Set platform name of current trace.</div>
<div class="epy_par">
<strong class="epy_sig">set_trace_platform(platform)</strong><div class="epy_nested">
<strong class="epy_parameter">platform</strong> (C++: const char *)</div>
</div></div>
</dd>
<dt id="ida_dbg.set_trace_size"><code class="name flex">
<span>def <span class="ident">set_trace_size</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Specify the new size of the circular buffer.
<table border="1">
<tr><td>Type</td><td>function</td></tr>
<tr><td>Notification</td><td>none (synchronous function)</td></tr>
</table>
If you specify 0,
all available memory can be quickly used !!!</div>
<div class="epy_par">
<strong class="epy_sig">set_trace_size(size) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">size</strong>: if 0, buffer isn't circular and events are never removed.<div class="epy_nested">
If the new size is smaller than the existing number of
trace events, a corresponding number of trace events are
removed. (C++: int)</div>
</div>
</div></div>
</dd>
<dt id="ida_dbg.srcdbg_request_step_into"><code class="name flex">
<span>def <span class="ident">srcdbg_request_step_into</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">srcdbg_request_step_into() -&gt; bool</strong></div></div>
</dd>
<dt id="ida_dbg.srcdbg_request_step_over"><code class="name flex">
<span>def <span class="ident">srcdbg_request_step_over</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">srcdbg_request_step_over() -&gt; bool</strong></div></div>
</dd>
<dt id="ida_dbg.srcdbg_request_step_until_ret"><code class="name flex">
<span>def <span class="ident">srcdbg_request_step_until_ret</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">srcdbg_request_step_until_ret() -&gt; bool</strong></div></div>
</dd>
<dt id="ida_dbg.srcdbg_step_into"><code class="name flex">
<span>def <span class="ident">srcdbg_step_into</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">srcdbg_step_into() -&gt; bool</strong></div></div>
</dd>
<dt id="ida_dbg.srcdbg_step_over"><code class="name flex">
<span>def <span class="ident">srcdbg_step_over</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">srcdbg_step_over() -&gt; bool</strong></div></div>
</dd>
<dt id="ida_dbg.srcdbg_step_until_ret"><code class="name flex">
<span>def <span class="ident">srcdbg_step_until_ret</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">srcdbg_step_until_ret() -&gt; bool</strong></div></div>
</dd>
<dt id="ida_dbg.start_process"><code class="name flex">
<span>def <span class="ident">start_process</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Start a process in the debugger.
<table border="1">
<tr><td>Type</td><td>available as Request</td></tr>
<tr><td>Notification</td><td>'dbg_process_start'</td></tr>
</table>
You can also
use the 'run_to()' function to easily start the execution of a process
until a given address is reached.For all parameters, a NULL value
indicates the debugger will take the value from the defined Process
Options.</div>
<div class="epy_par">
<strong class="epy_sig">start_process(path=None, args=None, sdir=None) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">path</strong>: path to the executable to start (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">args</strong>: arguments to pass to process (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">sdir</strong>: starting directory for the process (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: -1 - impossible to create the process</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - the starting of the process was cancelled by the user</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 - the process was properly started</div>
</div></div>
</dd>
<dt id="ida_dbg.step_into"><code class="name flex">
<span>def <span class="ident">step_into</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Execute one instruction in the current thread. Other threads are kept
suspended.
<table border="1">
<tr><td>Type</td><td>Asynchronous function - available as Request</td></tr>
<tr><td>Notification</td><td>'dbg_step_into'</td></tr>
</table>
</div></div>
</dd>
<dt id="ida_dbg.step_over"><code class="name flex">
<span>def <span class="ident">step_over</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Execute one instruction in the current thread, but without entering
into functions. Others threads keep suspended.
<table border="1">
<tr><td>Type</td><td>function - available as Request</td></tr>
<tr><td>Notification</td><td>'dbg_step_over'</td></tr>
</table>
</div></div>
</dd>
<dt id="ida_dbg.step_until_ret"><code class="name flex">
<span>def <span class="ident">step_until_ret</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Execute instructions in the current thread until a function return
instruction is executed (aka "step out"). Other threads are kept
suspended.
<table border="1">
<tr><td>Type</td><td>Asynchronous function - available as Request</td></tr>
<tr><td>Notification</td><td>'dbg_step_until_ret'</td></tr>
</table>
</div></div>
</dd>
<dt id="ida_dbg.store_exceptions"><code class="name flex">
<span>def <span class="ident">store_exceptions</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Update the exception information stored in the debugger module by
invoking its dbg-&gt;set_exception_info callback</div></div>
</dd>
<dt id="ida_dbg.suspend_process"><code class="name flex">
<span>def <span class="ident">suspend_process</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Suspend the process in the debugger.
<table border="1">
<tr><td>Type</td><td>else)available as Request</td></tr>
<tr><td>Notification</td><td>handler) 'dbg_suspend_process' (everywhere else)</td></tr>
</table>
The
'suspend_process()' function can be called from a notification handler
to force the stopping of the process. In this case, no notification
will be generated. When you suspend a process, the running command is
always aborted.</div></div>
</dd>
<dt id="ida_dbg.suspend_thread"><code class="name flex">
<span>def <span class="ident">suspend_thread</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Suspend thread. Suspending a thread may deadlock the whole application
if the suspended was owning some synchronization objects.
<table border="1">
<tr><td>Type</td><td>Synchronous function - available as request</td></tr>
<tr><td>Notification</td><td>(synchronous function)</td></tr>
</table>
</div>
<div class="epy_par">
<strong class="epy_sig">suspend_thread(tid) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">tid</strong>: thread id (C++: thid_t)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: -1 - network error</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - failed</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 - ok</div>
</div></div>
</dd>
<dt id="ida_dbg.update_bpt"><code class="name flex">
<span>def <span class="ident">update_bpt</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Update modifiable characteristics of an existing breakpoint. To update
the breakpoint location, use 'change_bptlocs()'
<table border="1">
<tr><td>Type</td><td>function</td></tr>
<tr><td>Notification</td><td>none (synchronous function)</td></tr>
</table>
Only the following
fields can be modified: 'bpt_t::cndbody'
'bpt_t::pass_count'
'bpt_t::flags'
'bpt_t::size'
'bpt_t::type' Changing some properties
will require removing and then re-adding the breakpoint to the process
memory (or the debugger backend), which can lead to race conditions
(i.e., breakpoint(s) can be missed) in case the process is not
suspended. Here are a list of scenarios that will require the
breakpoint to be removed &amp; then re-added: 'bpt_t::size' is modified
'bpt_t::type' is modified 'bpt_t::flags' 's BPT_ENABLED is modified
'bpt_t::flags' 's BPT_LOWCND is changed 'bpt_t::flags' 's BPT_LOWCND
remains set, but cndbody changed</div>
<div class="epy_par">
<strong class="epy_sig">update_bpt(bpt) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">bpt</strong> (C++: const
bpt_t
*)</div>
</div></div>
</dd>
<dt id="ida_dbg.wait_for_next_event"><code class="name flex">
<span>def <span class="ident">wait_for_next_event</span></span>(<span>*args) &#8209;&gt;&#160;dbg_event_code_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Wait for the next event.This function (optionally) resumes the process
execution, and waits for a debugger event until a possible timeout
occurs.</div>
<div class="epy_par">
<strong class="epy_sig">wait_for_next_event(wfne, timeout) -&gt; dbg_event_code_t</strong><div class="epy_nested">
<strong class="epy_parameter">wfne</strong>: combination of
Wait for debugger event flags
constants<div class="epy_nested">
(C++: int)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">timeout</strong>: number of seconds to wait, -1-infinity (C++: int)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: either an event_id_t (if &gt; 0), or a dbg_event_code_t (if &lt;=<div class="epy_nested">
0)</div>
</div>
</div></div>
</dd>
<dt id="ida_dbg.write_dbg_memory"><code class="name flex">
<span>def <span class="ident">write_dbg_memory</span></span>(<span>*args) &#8209;&gt;&#160;ssize_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
write_dbg_memory(ea, py_buf, size=size_t(-1)) -&gt; ssize_t<div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)
py_buf: PyObject *</div>
<div class="epy_nested">
<strong class="epy_parameter">size</strong> (C++: size_t)</div>
</div></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ida_dbg.DBG_Hooks"><code class="flex name class">
<span>class <span class="ident">DBG_Hooks</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ DBG_Hooks class.</div>
<div class="epy_par">
<strong class="epy_sig">__init__(self, _flags=0) -&gt; DBG_Hooks</strong><div class="epy_nested">
_flags: uint32</div>
</div></div>
<h3>Methods</h3>
<dl>
<dt id="ida_dbg.DBG_Hooks.dbg_bpt"><code class="name flex">
<span>def <span class="ident">dbg_bpt</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
A user defined breakpoint was reached.</div>
<div class="epy_par">
<strong class="epy_sig">dbg_bpt(self, tid, bptea) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">tid</strong> (C++: thid_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">bptea</strong> (C++: ea_t)</div>
</div></div>
</dd>
<dt id="ida_dbg.DBG_Hooks.dbg_bpt_changed"><code class="name flex">
<span>def <span class="ident">dbg_bpt_changed</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Breakpoint has been changed.</div>
<div class="epy_par">
<strong class="epy_sig">dbg_bpt_changed(self, bptev_code, bpt)</strong><div class="epy_nested">
<strong class="epy_parameter">bptev_code</strong>: Breakpoint modification events
(C++: int)</div>
<div class="epy_nested">
<strong class="epy_parameter">bpt</strong> (C++: bpt_t *)</div>
</div></div>
</dd>
<dt id="ida_dbg.DBG_Hooks.dbg_exception"><code class="name flex">
<span>def <span class="ident">dbg_exception</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">dbg_exception(self, pid, tid, ea, exc_code, exc_can_cont, exc_ea, exc_info) -&gt; int</strong><div class="epy_nested">
pid: pid_t
tid: thid_t
ea: ea_t
exc_code: int
exc_can_cont: bool
exc_ea: ea_t
exc_info: char const *</div>
</div></div>
</dd>
<dt id="ida_dbg.DBG_Hooks.dbg_finished_loading_bpts"><code class="name flex">
<span>def <span class="ident">dbg_finished_loading_bpts</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Finished loading breakpoint info from idb.</div></div>
</dd>
<dt id="ida_dbg.DBG_Hooks.dbg_information"><code class="name flex">
<span>def <span class="ident">dbg_information</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">dbg_information(self, pid, tid, ea, info)</strong><div class="epy_nested">
pid: pid_t
tid: thid_t
ea: ea_t
info: char const *</div>
</div></div>
</dd>
<dt id="ida_dbg.DBG_Hooks.dbg_library_load"><code class="name flex">
<span>def <span class="ident">dbg_library_load</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">dbg_library_load(self, pid, tid, ea, modinfo_name, modinfo_base, modinfo_size)</strong><div class="epy_nested">
pid: pid_t
tid: thid_t
ea: ea_t
modinfo_name: char const *
modinfo_base: ea_t
modinfo_size: asize_t</div>
</div></div>
</dd>
<dt id="ida_dbg.DBG_Hooks.dbg_library_unload"><code class="name flex">
<span>def <span class="ident">dbg_library_unload</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">dbg_library_unload(self, pid, tid, ea, info)</strong><div class="epy_nested">
pid: pid_t
tid: thid_t
ea: ea_t
info: char const *</div>
</div></div>
</dd>
<dt id="ida_dbg.DBG_Hooks.dbg_process_attach"><code class="name flex">
<span>def <span class="ident">dbg_process_attach</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
This event notification is also an asynchronous function result
notification for 'start_process()' !</div>
<div class="epy_par">
<strong class="epy_sig">dbg_process_attach(self, pid, tid, ea, modinfo_name, modinfo_base, modinfo_size)</strong><div class="epy_nested">
pid: pid_t
tid: thid_t
ea: ea_t
modinfo_name: char const *
modinfo_base: ea_t
modinfo_size: asize_t</div>
</div></div>
</dd>
<dt id="ida_dbg.DBG_Hooks.dbg_process_detach"><code class="name flex">
<span>def <span class="ident">dbg_process_detach</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
This event notification is also an asynchronous function result
notification for 'start_process()' !</div>
<div class="epy_par">
<strong class="epy_sig">dbg_process_detach(self, pid, tid, ea)</strong><div class="epy_nested">
pid: pid_t
tid: thid_t
ea: ea_t</div>
</div></div>
</dd>
<dt id="ida_dbg.DBG_Hooks.dbg_process_exit"><code class="name flex">
<span>def <span class="ident">dbg_process_exit</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
This event notification is also an asynchronous function result
notification for 'start_process()' !</div>
<div class="epy_par">
<strong class="epy_sig">dbg_process_exit(self, pid, tid, ea, exit_code)</strong><div class="epy_nested">
pid: pid_t
tid: thid_t
ea: ea_t
exit_code: int</div>
</div></div>
</dd>
<dt id="ida_dbg.DBG_Hooks.dbg_process_start"><code class="name flex">
<span>def <span class="ident">dbg_process_start</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
This event notification is also an asynchronous function result
notification for 'start_process()' !</div>
<div class="epy_par">
<strong class="epy_sig">dbg_process_start(self, pid, tid, ea, modinfo_name, modinfo_base, modinfo_size)</strong><div class="epy_nested">
pid: pid_t
tid: thid_t
ea: ea_t
modinfo_name: char const *
modinfo_base: ea_t
modinfo_size: asize_t</div>
</div></div>
</dd>
<dt id="ida_dbg.DBG_Hooks.dbg_request_error"><code class="name flex">
<span>def <span class="ident">dbg_request_error</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
An error occurred during the processing of a request.</div>
<div class="epy_par">
<strong class="epy_sig">dbg_request_error(self, failed_command, failed_dbg_notification)</strong><div class="epy_nested">
<strong class="epy_parameter">failed_command</strong> (C++: ui_notification_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">failed_dbg_notification</strong> (C++: dbg_notification_t)</div>
</div></div>
</dd>
<dt id="ida_dbg.DBG_Hooks.dbg_run_to"><code class="name flex">
<span>def <span class="ident">dbg_run_to</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">dbg_run_to(self, pid, tid, ea)</strong><div class="epy_nested">
pid: pid_t
tid: thid_t
ea: ea_t</div>
</div></div>
</dd>
<dt id="ida_dbg.DBG_Hooks.dbg_started_loading_bpts"><code class="name flex">
<span>def <span class="ident">dbg_started_loading_bpts</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Started loading breakpoint info from idb.</div></div>
</dd>
<dt id="ida_dbg.DBG_Hooks.dbg_step_into"><code class="name flex">
<span>def <span class="ident">dbg_step_into</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">dbg_step_into(self)</strong></div></div>
</dd>
<dt id="ida_dbg.DBG_Hooks.dbg_step_over"><code class="name flex">
<span>def <span class="ident">dbg_step_over</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">dbg_step_over(self)</strong></div></div>
</dd>
<dt id="ida_dbg.DBG_Hooks.dbg_step_until_ret"><code class="name flex">
<span>def <span class="ident">dbg_step_until_ret</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">dbg_step_until_ret(self)</strong></div></div>
</dd>
<dt id="ida_dbg.DBG_Hooks.dbg_suspend_process"><code class="name flex">
<span>def <span class="ident">dbg_suspend_process</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
The process is now suspended.This event notification is also an
asynchronous function result notification for 'suspend_process()' !</div></div>
</dd>
<dt id="ida_dbg.DBG_Hooks.dbg_thread_exit"><code class="name flex">
<span>def <span class="ident">dbg_thread_exit</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">dbg_thread_exit(self, pid, tid, ea, exit_code)</strong><div class="epy_nested">
pid: pid_t
tid: thid_t
ea: ea_t
exit_code: int</div>
</div></div>
</dd>
<dt id="ida_dbg.DBG_Hooks.dbg_thread_start"><code class="name flex">
<span>def <span class="ident">dbg_thread_start</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">dbg_thread_start(self, pid, tid, ea)</strong><div class="epy_nested">
pid: pid_t
tid: thid_t
ea: ea_t</div>
</div></div>
</dd>
<dt id="ida_dbg.DBG_Hooks.dbg_trace"><code class="name flex">
<span>def <span class="ident">dbg_trace</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
A step occurred (one instruction was executed). This event
notification is only generated if step tracing is enabled.</div>
<div class="epy_par">
<strong class="epy_sig">dbg_trace(self, tid, ip) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">tid</strong>: thread ID
(C++: thid_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">ip</strong>: current instruction pointer. usually points after the<div class="epy_nested">
executed instruction
(C++: ea_t)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 - do not log this trace event</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - log it</div>
</div></div>
</dd>
<dt id="ida_dbg.DBG_Hooks.hook"><code class="name flex">
<span>def <span class="ident">hook</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">hook(self) -&gt; bool</strong></div></div>
</dd>
<dt id="ida_dbg.DBG_Hooks.unhook"><code class="name flex">
<span>def <span class="ident">unhook</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">unhook(self) -&gt; bool</strong></div></div>
</dd>
</dl>
</dd>
<dt id="ida_dbg.bpt_location_t"><code class="flex name class">
<span>class <span class="ident">bpt_location_t</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ bpt_location_t class.</div>
<div class="epy_par">
<strong class="epy_sig">__init__(self) -&gt; bpt_location_t</strong></div></div>
<h3>Instance variables</h3>
<dl>
<dt id="ida_dbg.bpt_location_t.index"><code class="name">var <span class="ident">index</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">bpt_location_t_index_get(self) -&gt; int</strong></div></div>
</dd>
<dt id="ida_dbg.bpt_location_t.info"><code class="name">var <span class="ident">info</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">bpt_location_t_info_get(self) -&gt; ea_t</strong></div></div>
</dd>
<dt id="ida_dbg.bpt_location_t.loctype"><code class="name">var <span class="ident">loctype</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">bpt_location_t_loctype_get(self) -&gt; bpt_loctype_t</strong></div></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ida_dbg.bpt_location_t.compare"><code class="name flex">
<span>def <span class="ident">compare</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Lexically compare two breakpoint locations. Bpt locations are first
compared based on type (i.e. 'BPLT_ABS' &lt; 'BPLT_REL' ). 'BPLT_ABS'
locations are compared based on their ea values. For all other
location types, locations are first compared based on their string
(path/filename/symbol), then their offset/lineno.</div>
<div class="epy_par">
<strong class="epy_sig">compare(self, r) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">r</strong> (C++: const
bpt_location_t
&amp;)</div>
</div></div>
</dd>
<dt id="ida_dbg.bpt_location_t.ea"><code class="name flex">
<span>def <span class="ident">ea</span></span>(<span>self, *args) &#8209;&gt;&#160;ea_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get address ( 'BPLT_ABS' )</div></div>
</dd>
<dt id="ida_dbg.bpt_location_t.is_empty_path"><code class="name flex">
<span>def <span class="ident">is_empty_path</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
No path/filename specified? ( 'BPLT_REL' , 'BPLT_SRC' )</div></div>
</dd>
<dt id="ida_dbg.bpt_location_t.lineno"><code class="name flex">
<span>def <span class="ident">lineno</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get line number ( 'BPLT_SRC' )</div></div>
</dd>
<dt id="ida_dbg.bpt_location_t.offset"><code class="name flex">
<span>def <span class="ident">offset</span></span>(<span>self, *args) &#8209;&gt;&#160;uval_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get offset ( 'BPLT_REL' , 'BPLT_SYM' )</div></div>
</dd>
<dt id="ida_dbg.bpt_location_t.path"><code class="name flex">
<span>def <span class="ident">path</span></span>(<span>self, *args) &#8209;&gt;&#160;char&#160;const&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get path/filename ( 'BPLT_REL' , 'BPLT_SRC' )</div></div>
</dd>
<dt id="ida_dbg.bpt_location_t.set_abs_bpt"><code class="name flex">
<span>def <span class="ident">set_abs_bpt</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Specify an absolute address location.</div>
<div class="epy_par">
<strong class="epy_sig">set_abs_bpt(self, a)</strong><div class="epy_nested">
<strong class="epy_parameter">a</strong> (C++: ea_t)</div>
</div></div>
</dd>
<dt id="ida_dbg.bpt_location_t.set_rel_bpt"><code class="name flex">
<span>def <span class="ident">set_rel_bpt</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Specify a relative address location.</div>
<div class="epy_par">
<strong class="epy_sig">set_rel_bpt(self, mod, _offset)</strong><div class="epy_nested">
<strong class="epy_parameter">mod</strong> (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">_offset</strong> (C++: uval_t)</div>
</div></div>
</dd>
<dt id="ida_dbg.bpt_location_t.set_src_bpt"><code class="name flex">
<span>def <span class="ident">set_src_bpt</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Specify a source level location.</div>
<div class="epy_par">
<strong class="epy_sig">set_src_bpt(self, fn, _lineno)</strong><div class="epy_nested">
<strong class="epy_parameter">fn</strong> (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">_lineno</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_dbg.bpt_location_t.set_sym_bpt"><code class="name flex">
<span>def <span class="ident">set_sym_bpt</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Specify a symbolic location.</div>
<div class="epy_par">
<strong class="epy_sig">set_sym_bpt(self, _symbol, _offset=0)</strong><div class="epy_nested">
<strong class="epy_parameter">_symbol</strong> (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">_offset</strong> (C++: uval_t)</div>
</div></div>
</dd>
<dt id="ida_dbg.bpt_location_t.symbol"><code class="name flex">
<span>def <span class="ident">symbol</span></span>(<span>self, *args) &#8209;&gt;&#160;char&#160;const&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get symbol name ( 'BPLT_SYM' )</div></div>
</dd>
<dt id="ida_dbg.bpt_location_t.type"><code class="name flex">
<span>def <span class="ident">type</span></span>(<span>self, *args) &#8209;&gt;&#160;bpt_loctype_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get bpt type.</div></div>
</dd>
</dl>
</dd>
<dt id="ida_dbg.bpt_t"><code class="flex name class">
<span>class <span class="ident">bpt_t</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ bpt_t class.</div>
<div class="epy_par">
<strong class="epy_sig">__init__(self) -&gt; bpt_t</strong></div></div>
<h3>Instance variables</h3>
<dl>
<dt id="ida_dbg.bpt_t.cb"><code class="name">var <span class="ident">cb</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">bpt_t_cb_get(self) -&gt; size_t</strong></div></div>
</dd>
<dt id="ida_dbg.bpt_t.cndidx"><code class="name">var <span class="ident">cndidx</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">bpt_t_cndidx_get(self) -&gt; int</strong></div></div>
</dd>
<dt id="ida_dbg.bpt_t.condition"><code class="name">var <span class="ident">condition</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">bpt_t_condition_get(self) -&gt; PyObject *</strong></div></div>
</dd>
<dt id="ida_dbg.bpt_t.ea"><code class="name">var <span class="ident">ea</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">bpt_t_ea_get(self) -&gt; ea_t</strong></div></div>
</dd>
<dt id="ida_dbg.bpt_t.elang"><code class="name">var <span class="ident">elang</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">bpt_t_elang_get(self) -&gt; PyObject *</strong></div></div>
</dd>
<dt id="ida_dbg.bpt_t.flags"><code class="name">var <span class="ident">flags</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">bpt_t_flags_get(self) -&gt; uint32</strong></div></div>
</dd>
<dt id="ida_dbg.bpt_t.loc"><code class="name">var <span class="ident">loc</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">bpt_t_loc_get(self) -&gt; bpt_location_t</strong></div></div>
</dd>
<dt id="ida_dbg.bpt_t.pass_count"><code class="name">var <span class="ident">pass_count</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">bpt_t_pass_count_get(self) -&gt; int</strong></div></div>
</dd>
<dt id="ida_dbg.bpt_t.pid"><code class="name">var <span class="ident">pid</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">bpt_t_pid_get(self) -&gt; pid_t</strong></div></div>
</dd>
<dt id="ida_dbg.bpt_t.props"><code class="name">var <span class="ident">props</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">bpt_t_props_get(self) -&gt; uint32</strong></div></div>
</dd>
<dt id="ida_dbg.bpt_t.size"><code class="name">var <span class="ident">size</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">bpt_t_size_get(self) -&gt; int</strong></div></div>
</dd>
<dt id="ida_dbg.bpt_t.tid"><code class="name">var <span class="ident">tid</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">bpt_t_tid_get(self) -&gt; thid_t</strong></div></div>
</dd>
<dt id="ida_dbg.bpt_t.type"><code class="name">var <span class="ident">type</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">bpt_t_type_get(self) -&gt; bpttype_t</strong></div></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ida_dbg.bpt_t.badbpt"><code class="name flex">
<span>def <span class="ident">badbpt</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Failed to write bpt to process memory?</div></div>
</dd>
<dt id="ida_dbg.bpt_t.enabled"><code class="name flex">
<span>def <span class="ident">enabled</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is breakpoint enabled?</div></div>
</dd>
<dt id="ida_dbg.bpt_t.get_cnd_elang_idx"><code class="name flex">
<span>def <span class="ident">get_cnd_elang_idx</span></span>(<span>self, *args) &#8209;&gt;&#160;size_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">get_cnd_elang_idx(self) -&gt; size_t</strong></div></div>
</dd>
<dt id="ida_dbg.bpt_t.get_size"><code class="name flex">
<span>def <span class="ident">get_size</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get bpt size.</div></div>
</dd>
<dt id="ida_dbg.bpt_t.is_absbpt"><code class="name flex">
<span>def <span class="ident">is_absbpt</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is absolute address breakpoint?</div></div>
</dd>
<dt id="ida_dbg.bpt_t.is_active"><code class="name flex">
<span>def <span class="ident">is_active</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Written completely to process?</div></div>
</dd>
<dt id="ida_dbg.bpt_t.is_compiled"><code class="name flex">
<span>def <span class="ident">is_compiled</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Condition has been compiled?</div></div>
</dd>
<dt id="ida_dbg.bpt_t.is_hwbpt"><code class="name flex">
<span>def <span class="ident">is_hwbpt</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is hardware breakpoint?</div></div>
</dd>
<dt id="ida_dbg.bpt_t.is_inactive"><code class="name flex">
<span>def <span class="ident">is_inactive</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Not written to process at all?</div></div>
</dd>
<dt id="ida_dbg.bpt_t.is_low_level"><code class="name flex">
<span>def <span class="ident">is_low_level</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is bpt condition calculated at low level?</div></div>
</dd>
<dt id="ida_dbg.bpt_t.is_page_bpt"><code class="name flex">
<span>def <span class="ident">is_page_bpt</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Page breakpoint?</div></div>
</dd>
<dt id="ida_dbg.bpt_t.is_partially_active"><code class="name flex">
<span>def <span class="ident">is_partially_active</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Written partially to process?</div></div>
</dd>
<dt id="ida_dbg.bpt_t.is_relbpt"><code class="name flex">
<span>def <span class="ident">is_relbpt</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is relative address breakpoint?</div></div>
</dd>
<dt id="ida_dbg.bpt_t.is_srcbpt"><code class="name flex">
<span>def <span class="ident">is_srcbpt</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is source level breakpoint?</div></div>
</dd>
<dt id="ida_dbg.bpt_t.is_symbpt"><code class="name flex">
<span>def <span class="ident">is_symbpt</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is symbolic breakpoint?</div></div>
</dd>
<dt id="ida_dbg.bpt_t.is_tracemodebpt"><code class="name flex">
<span>def <span class="ident">is_tracemodebpt</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Does breakpoint trace anything?</div></div>
</dd>
<dt id="ida_dbg.bpt_t.is_traceoffbpt"><code class="name flex">
<span>def <span class="ident">is_traceoffbpt</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is this a tracing breakpoint, and is tracing disabled?</div></div>
</dd>
<dt id="ida_dbg.bpt_t.is_traceonbpt"><code class="name flex">
<span>def <span class="ident">is_traceonbpt</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is this a tracing breakpoint, and is tracing enabled?</div></div>
</dd>
<dt id="ida_dbg.bpt_t.listbpt"><code class="name flex">
<span>def <span class="ident">listbpt</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Include in the bpt list?</div></div>
</dd>
<dt id="ida_dbg.bpt_t.set_abs_bpt"><code class="name flex">
<span>def <span class="ident">set_abs_bpt</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Set bpt location to an absolute address.</div>
<div class="epy_par">
<strong class="epy_sig">set_abs_bpt(self, a)</strong><div class="epy_nested">
<strong class="epy_parameter">a</strong> (C++: ea_t)</div>
</div></div>
</dd>
<dt id="ida_dbg.bpt_t.set_rel_bpt"><code class="name flex">
<span>def <span class="ident">set_rel_bpt</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Set bpt location to a relative address.</div>
<div class="epy_par">
<strong class="epy_sig">set_rel_bpt(self, mod, o)</strong><div class="epy_nested">
<strong class="epy_parameter">mod</strong> (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">o</strong> (C++: uval_t)</div>
</div></div>
</dd>
<dt id="ida_dbg.bpt_t.set_src_bpt"><code class="name flex">
<span>def <span class="ident">set_src_bpt</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Set bpt location to a source line.</div>
<div class="epy_par">
<strong class="epy_sig">set_src_bpt(self, fn, lineno)</strong><div class="epy_nested">
<strong class="epy_parameter">fn</strong> (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">lineno</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_dbg.bpt_t.set_sym_bpt"><code class="name flex">
<span>def <span class="ident">set_sym_bpt</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Set bpt location to a symbol.</div>
<div class="epy_par">
<strong class="epy_sig">set_sym_bpt(self, sym, o)</strong><div class="epy_nested">
<strong class="epy_parameter">sym</strong> (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">o</strong> (C++: uval_t)</div>
</div></div>
</dd>
<dt id="ida_dbg.bpt_t.set_trace_action"><code class="name flex">
<span>def <span class="ident">set_trace_action</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Configure tracing options.</div>
<div class="epy_par">
<strong class="epy_sig">set_trace_action(self, enable, trace_types) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">enable</strong> (C++: bool)</div>
<div class="epy_nested">
<strong class="epy_parameter">trace_types</strong> (C++: int)</div>
</div></div>
</dd>
</dl>
</dd>
<dt id="ida_dbg.bpt_vec_t"><code class="flex name class">
<span>class <span class="ident">bpt_vec_t</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ qvector&lt; bpt_t &gt; class.</div>
<div class="epy_par">
<strong class="epy_sig">__init__(self) -&gt; bpt_vec_t</strong><div class="epy_nested">
x: qvector&lt; bpt_t &gt; const &amp;</div>
</div></div>
<h3>Methods</h3>
<dl>
<dt id="ida_dbg.bpt_vec_t.at"><code class="name flex">
<span>def <span class="ident">at</span></span>(<span>self, *args) &#8209;&gt;&#160;<a title="ida_dbg.bpt_t" href="#ida_dbg.bpt_t">bpt_t</a>&#160;const&#160;&amp;</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">at(self, _idx) -&gt; bpt_t</strong><div class="epy_nested">
_idx: size_t</div>
</div></div>
</dd>
<dt id="ida_dbg.bpt_vec_t.back"><code class="name flex">
<span>def <span class="ident">back</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"/>
</dd>
<dt id="ida_dbg.bpt_vec_t.begin"><code class="name flex">
<span>def <span class="ident">begin</span></span>(<span>self, *args) &#8209;&gt;&#160;qvectorbpt_t&#160;&gt;::const_iterator</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">begin(self) -&gt; bpt_t</strong></div>
<div class="epy_par">
<strong class="epy_sig">begin(self) -&gt; bpt_t</strong></div></div>
</dd>
<dt id="ida_dbg.bpt_vec_t.capacity"><code class="name flex">
<span>def <span class="ident">capacity</span></span>(<span>self, *args) &#8209;&gt;&#160;size_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">capacity(self) -&gt; size_t</strong></div></div>
</dd>
<dt id="ida_dbg.bpt_vec_t.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">clear(self)</strong></div></div>
</dd>
<dt id="ida_dbg.bpt_vec_t.empty"><code class="name flex">
<span>def <span class="ident">empty</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">empty(self) -&gt; bool</strong></div></div>
</dd>
<dt id="ida_dbg.bpt_vec_t.end"><code class="name flex">
<span>def <span class="ident">end</span></span>(<span>self, *args) &#8209;&gt;&#160;qvectorbpt_t&#160;&gt;::const_iterator</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">end(self) -&gt; bpt_t</strong></div>
<div class="epy_par">
<strong class="epy_sig">end(self) -&gt; bpt_t</strong></div></div>
</dd>
<dt id="ida_dbg.bpt_vec_t.erase"><code class="name flex">
<span>def <span class="ident">erase</span></span>(<span>self, *args) &#8209;&gt;&#160;qvectorbpt_t&#160;&gt;::iterator</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">erase(self, it) -&gt; bpt_t</strong><div class="epy_nested">
it: qvector&lt; bpt_t &gt;::iterator</div>
</div>
<div class="epy_par">
<strong class="epy_sig">erase(self, first, last) -&gt; bpt_t</strong><div class="epy_nested">
first: qvector&lt; bpt_t &gt;::iterator
last: qvector&lt; bpt_t &gt;::iterator</div>
</div></div>
</dd>
<dt id="ida_dbg.bpt_vec_t.extract"><code class="name flex">
<span>def <span class="ident">extract</span></span>(<span>self, *args) &#8209;&gt;&#160;<a title="ida_dbg.bpt_t" href="#ida_dbg.bpt_t">bpt_t</a>&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">extract(self) -&gt; bpt_t</strong></div></div>
</dd>
<dt id="ida_dbg.bpt_vec_t.front"><code class="name flex">
<span>def <span class="ident">front</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"/>
</dd>
<dt id="ida_dbg.bpt_vec_t.grow"><code class="name flex">
<span>def <span class="ident">grow</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
grow(self, x=bpt_t())<div class="epy_nested">
x: bpt_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_dbg.bpt_vec_t.inject"><code class="name flex">
<span>def <span class="ident">inject</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">inject(self, s, len)</strong><div class="epy_nested">
s: bpt_t *
len: size_t</div>
</div></div>
</dd>
<dt id="ida_dbg.bpt_vec_t.insert"><code class="name flex">
<span>def <span class="ident">insert</span></span>(<span>self, *args) &#8209;&gt;&#160;qvectorbpt_t&#160;&gt;::iterator</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">insert(self, it, x) -&gt; bpt_t</strong><div class="epy_nested">
it: qvector&lt; bpt_t &gt;::iterator
x: bpt_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_dbg.bpt_vec_t.pop_back"><code class="name flex">
<span>def <span class="ident">pop_back</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">pop_back(self)</strong></div></div>
</dd>
<dt id="ida_dbg.bpt_vec_t.push_back"><code class="name flex">
<span>def <span class="ident">push_back</span></span>(<span>self, *args) &#8209;&gt;&#160;<a title="ida_dbg.bpt_t" href="#ida_dbg.bpt_t">bpt_t</a>&#160;&amp;</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">push_back(self, x)</strong><div class="epy_nested">
x: bpt_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_dbg.bpt_vec_t.qclear"><code class="name flex">
<span>def <span class="ident">qclear</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">qclear(self)</strong></div></div>
</dd>
<dt id="ida_dbg.bpt_vec_t.reserve"><code class="name flex">
<span>def <span class="ident">reserve</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">reserve(self, cnt)</strong><div class="epy_nested">
cnt: size_t</div>
</div></div>
</dd>
<dt id="ida_dbg.bpt_vec_t.resize"><code class="name flex">
<span>def <span class="ident">resize</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">resize(self, _newsize, x)</strong><div class="epy_nested">
_newsize: size_t
x: bpt_t const &amp;</div>
</div>
<div class="epy_par">
<strong class="epy_sig">resize(self, _newsize)</strong><div class="epy_nested">
_newsize: size_t</div>
</div></div>
</dd>
<dt id="ida_dbg.bpt_vec_t.size"><code class="name flex">
<span>def <span class="ident">size</span></span>(<span>self, *args) &#8209;&gt;&#160;size_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">size(self) -&gt; size_t</strong></div></div>
</dd>
<dt id="ida_dbg.bpt_vec_t.swap"><code class="name flex">
<span>def <span class="ident">swap</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">swap(self, r)</strong><div class="epy_nested">
r: qvector&lt; bpt_t &gt; &amp;</div>
</div></div>
</dd>
<dt id="ida_dbg.bpt_vec_t.truncate"><code class="name flex">
<span>def <span class="ident">truncate</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">truncate(self)</strong></div></div>
</dd>
</dl>
</dd>
<dt id="ida_dbg.eval_ctx_t"><code class="flex name class">
<span>class <span class="ident">eval_ctx_t</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ eval_ctx_t class.</div>
<div class="epy_par">
<strong class="epy_sig">__init__(self, _ea) -&gt; eval_ctx_t</strong><div class="epy_nested">
_ea: ea_t</div>
</div></div>
<h3>Instance variables</h3>
<dl>
<dt id="ida_dbg.eval_ctx_t.ea"><code class="name">var <span class="ident">ea</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">eval_ctx_t_ea_get(self) -&gt; ea_t</strong></div></div>
</dd>
</dl>
</dd>
<dt id="ida_dbg.memreg_info_t"><code class="flex name class">
<span>class <span class="ident">memreg_info_t</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ memreg_info_t class.</div>
<div class="epy_par">
<strong class="epy_sig">__init__(self) -&gt; memreg_info_t</strong></div></div>
<h3>Instance variables</h3>
<dl>
<dt id="ida_dbg.memreg_info_t.bytes"><code class="name">var <span class="ident">bytes</span> :&#160;PyObject&#160;*</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">get_bytes(self) -&gt; PyObject *</strong></div></div>
</dd>
<dt id="ida_dbg.memreg_info_t.ea"><code class="name">var <span class="ident">ea</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">memreg_info_t_ea_get(self) -&gt; ea_t</strong></div></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ida_dbg.memreg_info_t.get_bytes"><code class="name flex">
<span>def <span class="ident">get_bytes</span></span>(<span>self, *args) &#8209;&gt;&#160;PyObject&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">get_bytes(self) -&gt; PyObject *</strong></div></div>
</dd>
</dl>
</dd>
<dt id="ida_dbg.memreg_infos_t"><code class="flex name class">
<span>class <span class="ident">memreg_infos_t</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ qvector&lt; memreg_info_t &gt; class.</div>
<div class="epy_par">
<strong class="epy_sig">__init__(self) -&gt; memreg_infos_t</strong><div class="epy_nested">
x: qvector&lt; memreg_info_t &gt; const &amp;</div>
</div></div>
<h3>Methods</h3>
<dl>
<dt id="ida_dbg.memreg_infos_t.at"><code class="name flex">
<span>def <span class="ident">at</span></span>(<span>self, *args) &#8209;&gt;&#160;<a title="ida_dbg.memreg_info_t" href="#ida_dbg.memreg_info_t">memreg_info_t</a>&#160;const&#160;&amp;</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">at(self, _idx) -&gt; memreg_info_t</strong><div class="epy_nested">
_idx: size_t</div>
</div></div>
</dd>
<dt id="ida_dbg.memreg_infos_t.back"><code class="name flex">
<span>def <span class="ident">back</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"/>
</dd>
<dt id="ida_dbg.memreg_infos_t.begin"><code class="name flex">
<span>def <span class="ident">begin</span></span>(<span>self, *args) &#8209;&gt;&#160;qvectormemreg_info_t&#160;&gt;::const_iterator</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">begin(self) -&gt; memreg_info_t</strong></div>
<div class="epy_par">
<strong class="epy_sig">begin(self) -&gt; memreg_info_t</strong></div></div>
</dd>
<dt id="ida_dbg.memreg_infos_t.capacity"><code class="name flex">
<span>def <span class="ident">capacity</span></span>(<span>self, *args) &#8209;&gt;&#160;size_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">capacity(self) -&gt; size_t</strong></div></div>
</dd>
<dt id="ida_dbg.memreg_infos_t.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">clear(self)</strong></div></div>
</dd>
<dt id="ida_dbg.memreg_infos_t.empty"><code class="name flex">
<span>def <span class="ident">empty</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">empty(self) -&gt; bool</strong></div></div>
</dd>
<dt id="ida_dbg.memreg_infos_t.end"><code class="name flex">
<span>def <span class="ident">end</span></span>(<span>self, *args) &#8209;&gt;&#160;qvectormemreg_info_t&#160;&gt;::const_iterator</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">end(self) -&gt; memreg_info_t</strong></div>
<div class="epy_par">
<strong class="epy_sig">end(self) -&gt; memreg_info_t</strong></div></div>
</dd>
<dt id="ida_dbg.memreg_infos_t.erase"><code class="name flex">
<span>def <span class="ident">erase</span></span>(<span>self, *args) &#8209;&gt;&#160;qvectormemreg_info_t&#160;&gt;::iterator</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">erase(self, it) -&gt; memreg_info_t</strong><div class="epy_nested">
it: qvector&lt; memreg_info_t &gt;::iterator</div>
</div>
<div class="epy_par">
<strong class="epy_sig">erase(self, first, last) -&gt; memreg_info_t</strong><div class="epy_nested">
first: qvector&lt; memreg_info_t &gt;::iterator
last: qvector&lt; memreg_info_t &gt;::iterator</div>
</div></div>
</dd>
<dt id="ida_dbg.memreg_infos_t.extract"><code class="name flex">
<span>def <span class="ident">extract</span></span>(<span>self, *args) &#8209;&gt;&#160;<a title="ida_dbg.memreg_info_t" href="#ida_dbg.memreg_info_t">memreg_info_t</a>&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">extract(self) -&gt; memreg_info_t</strong></div></div>
</dd>
<dt id="ida_dbg.memreg_infos_t.front"><code class="name flex">
<span>def <span class="ident">front</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"/>
</dd>
<dt id="ida_dbg.memreg_infos_t.grow"><code class="name flex">
<span>def <span class="ident">grow</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
grow(self, x=memreg_info_t())<div class="epy_nested">
x: memreg_info_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_dbg.memreg_infos_t.inject"><code class="name flex">
<span>def <span class="ident">inject</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">inject(self, s, len)</strong><div class="epy_nested">
s: memreg_info_t *
len: size_t</div>
</div></div>
</dd>
<dt id="ida_dbg.memreg_infos_t.insert"><code class="name flex">
<span>def <span class="ident">insert</span></span>(<span>self, *args) &#8209;&gt;&#160;qvectormemreg_info_t&#160;&gt;::iterator</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">insert(self, it, x) -&gt; memreg_info_t</strong><div class="epy_nested">
it: qvector&lt; memreg_info_t &gt;::iterator
x: memreg_info_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_dbg.memreg_infos_t.pop_back"><code class="name flex">
<span>def <span class="ident">pop_back</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">pop_back(self)</strong></div></div>
</dd>
<dt id="ida_dbg.memreg_infos_t.push_back"><code class="name flex">
<span>def <span class="ident">push_back</span></span>(<span>self, *args) &#8209;&gt;&#160;<a title="ida_dbg.memreg_info_t" href="#ida_dbg.memreg_info_t">memreg_info_t</a>&#160;&amp;</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">push_back(self, x)</strong><div class="epy_nested">
x: memreg_info_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_dbg.memreg_infos_t.qclear"><code class="name flex">
<span>def <span class="ident">qclear</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">qclear(self)</strong></div></div>
</dd>
<dt id="ida_dbg.memreg_infos_t.reserve"><code class="name flex">
<span>def <span class="ident">reserve</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">reserve(self, cnt)</strong><div class="epy_nested">
cnt: size_t</div>
</div></div>
</dd>
<dt id="ida_dbg.memreg_infos_t.resize"><code class="name flex">
<span>def <span class="ident">resize</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">resize(self, _newsize, x)</strong><div class="epy_nested">
_newsize: size_t
x: memreg_info_t const &amp;</div>
</div>
<div class="epy_par">
<strong class="epy_sig">resize(self, _newsize)</strong><div class="epy_nested">
_newsize: size_t</div>
</div></div>
</dd>
<dt id="ida_dbg.memreg_infos_t.size"><code class="name flex">
<span>def <span class="ident">size</span></span>(<span>self, *args) &#8209;&gt;&#160;size_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">size(self) -&gt; size_t</strong></div></div>
</dd>
<dt id="ida_dbg.memreg_infos_t.swap"><code class="name flex">
<span>def <span class="ident">swap</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">swap(self, r)</strong><div class="epy_nested">
r: qvector&lt; memreg_info_t &gt; &amp;</div>
</div></div>
</dd>
<dt id="ida_dbg.memreg_infos_t.truncate"><code class="name flex">
<span>def <span class="ident">truncate</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">truncate(self)</strong></div></div>
</dd>
</dl>
</dd>
<dt id="ida_dbg.tev_info_reg_t"><code class="flex name class">
<span>class <span class="ident">tev_info_reg_t</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ tev_info_reg_t class.</div>
<div class="epy_par">
<strong class="epy_sig">__init__(self) -&gt; tev_info_reg_t</strong></div></div>
<h3>Instance variables</h3>
<dl>
<dt id="ida_dbg.tev_info_reg_t.info"><code class="name">var <span class="ident">info</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">tev_info_reg_t_info_get(self) -&gt; tev_info_t</strong></div></div>
</dd>
<dt id="ida_dbg.tev_info_reg_t.registers"><code class="name">var <span class="ident">registers</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">tev_info_reg_t_registers_get(self) -&gt; tev_reg_values_t</strong></div></div>
</dd>
</dl>
</dd>
<dt id="ida_dbg.tev_info_t"><code class="flex name class">
<span>class <span class="ident">tev_info_t</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ tev_info_t class.</div>
<div class="epy_par">
<strong class="epy_sig">__init__(self) -&gt; tev_info_t</strong></div></div>
<h3>Instance variables</h3>
<dl>
<dt id="ida_dbg.tev_info_t.ea"><code class="name">var <span class="ident">ea</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">tev_info_t_ea_get(self) -&gt; ea_t</strong></div></div>
</dd>
<dt id="ida_dbg.tev_info_t.tid"><code class="name">var <span class="ident">tid</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">tev_info_t_tid_get(self) -&gt; thid_t</strong></div></div>
</dd>
<dt id="ida_dbg.tev_info_t.type"><code class="name">var <span class="ident">type</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">tev_info_t_type_get(self) -&gt; tev_type_t</strong></div></div>
</dd>
</dl>
</dd>
<dt id="ida_dbg.tev_reg_value_t"><code class="flex name class">
<span>class <span class="ident">tev_reg_value_t</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ tev_reg_value_t class.</div>
<div class="epy_par">
__init__(self, _reg_idx=-1, _value=uint64(-1)) -&gt; tev_reg_value_t<div class="epy_nested">
_reg_idx: int
_value: uint64</div>
</div></div>
<h3>Instance variables</h3>
<dl>
<dt id="ida_dbg.tev_reg_value_t.reg_idx"><code class="name">var <span class="ident">reg_idx</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">tev_reg_value_t_reg_idx_get(self) -&gt; int</strong></div></div>
</dd>
<dt id="ida_dbg.tev_reg_value_t.value"><code class="name">var <span class="ident">value</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">tev_reg_value_t_value_get(self) -&gt; regval_t</strong></div></div>
</dd>
</dl>
</dd>
<dt id="ida_dbg.tev_reg_values_t"><code class="flex name class">
<span>class <span class="ident">tev_reg_values_t</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ qvector&lt; tev_reg_value_t &gt; class.</div>
<div class="epy_par">
<strong class="epy_sig">__init__(self) -&gt; tev_reg_values_t</strong><div class="epy_nested">
x: qvector&lt; tev_reg_value_t &gt; const &amp;</div>
</div></div>
<h3>Methods</h3>
<dl>
<dt id="ida_dbg.tev_reg_values_t.at"><code class="name flex">
<span>def <span class="ident">at</span></span>(<span>self, *args) &#8209;&gt;&#160;<a title="ida_dbg.tev_reg_value_t" href="#ida_dbg.tev_reg_value_t">tev_reg_value_t</a>&#160;const&#160;&amp;</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">at(self, _idx) -&gt; tev_reg_value_t</strong><div class="epy_nested">
_idx: size_t</div>
</div></div>
</dd>
<dt id="ida_dbg.tev_reg_values_t.back"><code class="name flex">
<span>def <span class="ident">back</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"/>
</dd>
<dt id="ida_dbg.tev_reg_values_t.begin"><code class="name flex">
<span>def <span class="ident">begin</span></span>(<span>self, *args) &#8209;&gt;&#160;qvectortev_reg_value_t&#160;&gt;::const_iterator</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">begin(self) -&gt; tev_reg_value_t</strong></div>
<div class="epy_par">
<strong class="epy_sig">begin(self) -&gt; tev_reg_value_t</strong></div></div>
</dd>
<dt id="ida_dbg.tev_reg_values_t.capacity"><code class="name flex">
<span>def <span class="ident">capacity</span></span>(<span>self, *args) &#8209;&gt;&#160;size_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">capacity(self) -&gt; size_t</strong></div></div>
</dd>
<dt id="ida_dbg.tev_reg_values_t.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">clear(self)</strong></div></div>
</dd>
<dt id="ida_dbg.tev_reg_values_t.empty"><code class="name flex">
<span>def <span class="ident">empty</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">empty(self) -&gt; bool</strong></div></div>
</dd>
<dt id="ida_dbg.tev_reg_values_t.end"><code class="name flex">
<span>def <span class="ident">end</span></span>(<span>self, *args) &#8209;&gt;&#160;qvectortev_reg_value_t&#160;&gt;::const_iterator</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">end(self) -&gt; tev_reg_value_t</strong></div>
<div class="epy_par">
<strong class="epy_sig">end(self) -&gt; tev_reg_value_t</strong></div></div>
</dd>
<dt id="ida_dbg.tev_reg_values_t.erase"><code class="name flex">
<span>def <span class="ident">erase</span></span>(<span>self, *args) &#8209;&gt;&#160;qvectortev_reg_value_t&#160;&gt;::iterator</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">erase(self, it) -&gt; tev_reg_value_t</strong><div class="epy_nested">
it: qvector&lt; tev_reg_value_t &gt;::iterator</div>
</div>
<div class="epy_par">
<strong class="epy_sig">erase(self, first, last) -&gt; tev_reg_value_t</strong><div class="epy_nested">
first: qvector&lt; tev_reg_value_t &gt;::iterator
last: qvector&lt; tev_reg_value_t &gt;::iterator</div>
</div></div>
</dd>
<dt id="ida_dbg.tev_reg_values_t.extract"><code class="name flex">
<span>def <span class="ident">extract</span></span>(<span>self, *args) &#8209;&gt;&#160;<a title="ida_dbg.tev_reg_value_t" href="#ida_dbg.tev_reg_value_t">tev_reg_value_t</a>&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">extract(self) -&gt; tev_reg_value_t</strong></div></div>
</dd>
<dt id="ida_dbg.tev_reg_values_t.front"><code class="name flex">
<span>def <span class="ident">front</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"/>
</dd>
<dt id="ida_dbg.tev_reg_values_t.grow"><code class="name flex">
<span>def <span class="ident">grow</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
grow(self, x=tev_reg_value_t())<div class="epy_nested">
x: tev_reg_value_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_dbg.tev_reg_values_t.inject"><code class="name flex">
<span>def <span class="ident">inject</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">inject(self, s, len)</strong><div class="epy_nested">
s: tev_reg_value_t *
len: size_t</div>
</div></div>
</dd>
<dt id="ida_dbg.tev_reg_values_t.insert"><code class="name flex">
<span>def <span class="ident">insert</span></span>(<span>self, *args) &#8209;&gt;&#160;qvectortev_reg_value_t&#160;&gt;::iterator</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">insert(self, it, x) -&gt; tev_reg_value_t</strong><div class="epy_nested">
it: qvector&lt; tev_reg_value_t &gt;::iterator
x: tev_reg_value_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_dbg.tev_reg_values_t.pop_back"><code class="name flex">
<span>def <span class="ident">pop_back</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">pop_back(self)</strong></div></div>
</dd>
<dt id="ida_dbg.tev_reg_values_t.push_back"><code class="name flex">
<span>def <span class="ident">push_back</span></span>(<span>self, *args) &#8209;&gt;&#160;<a title="ida_dbg.tev_reg_value_t" href="#ida_dbg.tev_reg_value_t">tev_reg_value_t</a>&#160;&amp;</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">push_back(self, x)</strong><div class="epy_nested">
x: tev_reg_value_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_dbg.tev_reg_values_t.qclear"><code class="name flex">
<span>def <span class="ident">qclear</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">qclear(self)</strong></div></div>
</dd>
<dt id="ida_dbg.tev_reg_values_t.reserve"><code class="name flex">
<span>def <span class="ident">reserve</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">reserve(self, cnt)</strong><div class="epy_nested">
cnt: size_t</div>
</div></div>
</dd>
<dt id="ida_dbg.tev_reg_values_t.resize"><code class="name flex">
<span>def <span class="ident">resize</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">resize(self, _newsize, x)</strong><div class="epy_nested">
_newsize: size_t
x: tev_reg_value_t const &amp;</div>
</div>
<div class="epy_par">
<strong class="epy_sig">resize(self, _newsize)</strong><div class="epy_nested">
_newsize: size_t</div>
</div></div>
</dd>
<dt id="ida_dbg.tev_reg_values_t.size"><code class="name flex">
<span>def <span class="ident">size</span></span>(<span>self, *args) &#8209;&gt;&#160;size_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">size(self) -&gt; size_t</strong></div></div>
</dd>
<dt id="ida_dbg.tev_reg_values_t.swap"><code class="name flex">
<span>def <span class="ident">swap</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">swap(self, r)</strong><div class="epy_nested">
r: qvector&lt; tev_reg_value_t &gt; &amp;</div>
</div></div>
</dd>
<dt id="ida_dbg.tev_reg_values_t.truncate"><code class="name flex">
<span>def <span class="ident">truncate</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">truncate(self)</strong></div></div>
</dd>
</dl>
</dd>
<dt id="ida_dbg.tevinforeg_vec_t"><code class="flex name class">
<span>class <span class="ident">tevinforeg_vec_t</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ qvector&lt; tev_info_reg_t &gt; class.</div>
<div class="epy_par">
<strong class="epy_sig">__init__(self) -&gt; tevinforeg_vec_t</strong><div class="epy_nested">
x: qvector&lt; tev_info_reg_t &gt; const &amp;</div>
</div></div>
<h3>Methods</h3>
<dl>
<dt id="ida_dbg.tevinforeg_vec_t.at"><code class="name flex">
<span>def <span class="ident">at</span></span>(<span>self, *args) &#8209;&gt;&#160;<a title="ida_dbg.tev_info_reg_t" href="#ida_dbg.tev_info_reg_t">tev_info_reg_t</a>&#160;const&#160;&amp;</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">at(self, _idx) -&gt; tev_info_reg_t</strong><div class="epy_nested">
_idx: size_t</div>
</div></div>
</dd>
<dt id="ida_dbg.tevinforeg_vec_t.back"><code class="name flex">
<span>def <span class="ident">back</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"/>
</dd>
<dt id="ida_dbg.tevinforeg_vec_t.begin"><code class="name flex">
<span>def <span class="ident">begin</span></span>(<span>self, *args) &#8209;&gt;&#160;qvectortev_info_reg_t&#160;&gt;::const_iterator</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">begin(self) -&gt; tev_info_reg_t</strong></div>
<div class="epy_par">
<strong class="epy_sig">begin(self) -&gt; tev_info_reg_t</strong></div></div>
</dd>
<dt id="ida_dbg.tevinforeg_vec_t.capacity"><code class="name flex">
<span>def <span class="ident">capacity</span></span>(<span>self, *args) &#8209;&gt;&#160;size_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">capacity(self) -&gt; size_t</strong></div></div>
</dd>
<dt id="ida_dbg.tevinforeg_vec_t.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">clear(self)</strong></div></div>
</dd>
<dt id="ida_dbg.tevinforeg_vec_t.empty"><code class="name flex">
<span>def <span class="ident">empty</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">empty(self) -&gt; bool</strong></div></div>
</dd>
<dt id="ida_dbg.tevinforeg_vec_t.end"><code class="name flex">
<span>def <span class="ident">end</span></span>(<span>self, *args) &#8209;&gt;&#160;qvectortev_info_reg_t&#160;&gt;::const_iterator</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">end(self) -&gt; tev_info_reg_t</strong></div>
<div class="epy_par">
<strong class="epy_sig">end(self) -&gt; tev_info_reg_t</strong></div></div>
</dd>
<dt id="ida_dbg.tevinforeg_vec_t.erase"><code class="name flex">
<span>def <span class="ident">erase</span></span>(<span>self, *args) &#8209;&gt;&#160;qvectortev_info_reg_t&#160;&gt;::iterator</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">erase(self, it) -&gt; tev_info_reg_t</strong><div class="epy_nested">
it: qvector&lt; tev_info_reg_t &gt;::iterator</div>
</div>
<div class="epy_par">
<strong class="epy_sig">erase(self, first, last) -&gt; tev_info_reg_t</strong><div class="epy_nested">
first: qvector&lt; tev_info_reg_t &gt;::iterator
last: qvector&lt; tev_info_reg_t &gt;::iterator</div>
</div></div>
</dd>
<dt id="ida_dbg.tevinforeg_vec_t.extract"><code class="name flex">
<span>def <span class="ident">extract</span></span>(<span>self, *args) &#8209;&gt;&#160;<a title="ida_dbg.tev_info_reg_t" href="#ida_dbg.tev_info_reg_t">tev_info_reg_t</a>&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">extract(self) -&gt; tev_info_reg_t</strong></div></div>
</dd>
<dt id="ida_dbg.tevinforeg_vec_t.front"><code class="name flex">
<span>def <span class="ident">front</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"/>
</dd>
<dt id="ida_dbg.tevinforeg_vec_t.grow"><code class="name flex">
<span>def <span class="ident">grow</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
grow(self, x=tev_info_reg_t())<div class="epy_nested">
x: tev_info_reg_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_dbg.tevinforeg_vec_t.inject"><code class="name flex">
<span>def <span class="ident">inject</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">inject(self, s, len)</strong><div class="epy_nested">
s: tev_info_reg_t *
len: size_t</div>
</div></div>
</dd>
<dt id="ida_dbg.tevinforeg_vec_t.insert"><code class="name flex">
<span>def <span class="ident">insert</span></span>(<span>self, *args) &#8209;&gt;&#160;qvectortev_info_reg_t&#160;&gt;::iterator</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">insert(self, it, x) -&gt; tev_info_reg_t</strong><div class="epy_nested">
it: qvector&lt; tev_info_reg_t &gt;::iterator
x: tev_info_reg_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_dbg.tevinforeg_vec_t.pop_back"><code class="name flex">
<span>def <span class="ident">pop_back</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">pop_back(self)</strong></div></div>
</dd>
<dt id="ida_dbg.tevinforeg_vec_t.push_back"><code class="name flex">
<span>def <span class="ident">push_back</span></span>(<span>self, *args) &#8209;&gt;&#160;<a title="ida_dbg.tev_info_reg_t" href="#ida_dbg.tev_info_reg_t">tev_info_reg_t</a>&#160;&amp;</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">push_back(self, x)</strong><div class="epy_nested">
x: tev_info_reg_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_dbg.tevinforeg_vec_t.qclear"><code class="name flex">
<span>def <span class="ident">qclear</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">qclear(self)</strong></div></div>
</dd>
<dt id="ida_dbg.tevinforeg_vec_t.reserve"><code class="name flex">
<span>def <span class="ident">reserve</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">reserve(self, cnt)</strong><div class="epy_nested">
cnt: size_t</div>
</div></div>
</dd>
<dt id="ida_dbg.tevinforeg_vec_t.resize"><code class="name flex">
<span>def <span class="ident">resize</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">resize(self, _newsize, x)</strong><div class="epy_nested">
_newsize: size_t
x: tev_info_reg_t const &amp;</div>
</div>
<div class="epy_par">
<strong class="epy_sig">resize(self, _newsize)</strong><div class="epy_nested">
_newsize: size_t</div>
</div></div>
</dd>
<dt id="ida_dbg.tevinforeg_vec_t.size"><code class="name flex">
<span>def <span class="ident">size</span></span>(<span>self, *args) &#8209;&gt;&#160;size_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">size(self) -&gt; size_t</strong></div></div>
</dd>
<dt id="ida_dbg.tevinforeg_vec_t.swap"><code class="name flex">
<span>def <span class="ident">swap</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">swap(self, r)</strong><div class="epy_nested">
r: qvector&lt; tev_info_reg_t &gt; &amp;</div>
</div></div>
</dd>
<dt id="ida_dbg.tevinforeg_vec_t.truncate"><code class="name flex">
<span>def <span class="ident">truncate</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">truncate(self)</strong></div></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
</main>
<footer id="footer">
<p>Copyright (c) 2021 Hex-Rays SA. <a href="/terms_of_use.shtml">Terms of use</a> and <a href="/privacy_policy.shtml">privacy policy</a>.</p>
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> ???</a>.</p>
</footer>
</body>
</html>