<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1"/>
<meta name="generator" content="pdoc ???"/>
<title>ida_offset API documentation</title>
<meta name="description" content="IDA Plugin SDK API wrapper: offset"/>
<link rel="preload stylesheet" as="style" href="assets/sanitize.min.css"/>
<link rel="preload stylesheet" as="style" href="assets/typography.min.css"/>
<link rel="stylesheet preload" as="style" href="assets/github.min.css"/>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar &amp;gt; *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl &amp;gt; dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:-webkit-fill-available}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name &amp;gt; span:first-child{white-space:nowrap}.name.class &amp;gt; span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary &amp;gt; *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content: ',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width: 700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content padding:3em 4em;border-left:1px solid #ddd;lid #ddd;}pre code{font-size:1em}.item .name{font-size:1em}main{/* display:flex; *//* flex-direction:row-reverse; *//* justify-content:flex-end; */}.toc ul ul,#index ul{padding-left:1.5em}.toc &gt; ul &gt; li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer="defer" src="assets/highlight.min.js"/>
<script>window.addEventListener('DOMContentLoaded', () =&gt; hljs.initHighlighting())</script>
<style>
#section-intro .epy_par
{
margin-top: 18px;
}
</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ida_offset</code></h1>
</header>
<section id="section-intro">
<div class="epy_par">
IDA Plugin SDK API wrapper: offset</div>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="ida_offset.add_refinfo_dref"><code class="name flex">
<span>def <span class="ident">add_refinfo_dref</span></span>(<span>*args) &#8209;&gt;&#160;ea_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Add xrefs for a reference from the given instruction (\insn_t{ea}
).
This function creates a cross references to the target and the base.
'insn_t::add_off_drefs()' calls this function to create xrefs for
'offset' operand.</div>
<div class="epy_par">
<strong class="epy_sig">add_refinfo_dref(insn, _from, ri, opval, type, opoff) -&gt; ea_t</strong><div class="epy_nested">
<strong class="epy_parameter">insn</strong>: the referencing instruction
- an ida_ua.insn_t, or an<div class="epy_nested">
address (C++: const insn_t &amp;)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">_from</strong>: the referencing instruction/data address (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">ri</strong>: reference info block from the database (C++: const<div class="epy_nested">
refinfo_t
&amp;)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">opval</strong>: operand value (usually
op_t::value
or
op_t::addr )<div class="epy_nested">
(C++: adiff_t)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">type</strong>: type of xref (C++: dref_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">opoff</strong>: offset of the operand from the start of instruction<div class="epy_nested">
(C++: int)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: the target address of the reference</div>
</div></div>
</dd>
<dt id="ida_offset.calc_basevalue"><code class="name flex">
<span>def <span class="ident">calc_basevalue</span></span>(<span>*args) &#8209;&gt;&#160;ea_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Calculate the value of the reference base.</div>
<div class="epy_par">
<strong class="epy_sig">calc_basevalue(target, base) -&gt; ea_t</strong><div class="epy_nested">
<strong class="epy_parameter">target</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">base</strong> (C++: ea_t)</div>
</div></div>
</dd>
<dt id="ida_offset.calc_offset_base"><code class="name flex">
<span>def <span class="ident">calc_offset_base</span></span>(<span>*args) &#8209;&gt;&#160;ea_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Try to calculate the offset base This function takes into account the
fixup information, current ds and cs values.</div>
<div class="epy_par">
<strong class="epy_sig">calc_offset_base(ea, n) -&gt; ea_t</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong>: the referencing instruction/data address (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">n</strong>: operand number
0: first operand
1: other operand (C++:<div class="epy_nested">
int)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: output base address or
BADADDR</div>
</div></div>
</dd>
<dt id="ida_offset.calc_probable_base_by_value"><code class="name flex">
<span>def <span class="ident">calc_probable_base_by_value</span></span>(<span>*args) &#8209;&gt;&#160;ea_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Try to calculate the offset base. 2 bases are checked: current ds and
cs. If fails, return 'BADADDR'</div>
<div class="epy_par">
<strong class="epy_sig">calc_probable_base_by_value(ea, off) -&gt; ea_t</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">off</strong> (C++: uval_t)</div>
</div></div>
</dd>
<dt id="ida_offset.calc_reference_data"><code class="name flex">
<span>def <span class="ident">calc_reference_data</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Calculate the target and base addresses of an offset expression. The
calculated target and base addresses are returned in the locations
pointed by 'base' and 'target'. In case 'ri.base' is 'BADADDR' , the
function calculates the offset base address from the referencing
instruction/data address. The target address is copied from ri.target.
If ri.target is 'BADADDR' then the target is calculated using the base
address and 'opval'. This function also checks if 'opval' matches the
full value of the reference and takes in account the memory-mapping.</div>
<div class="epy_par">
<strong class="epy_sig">calc_reference_data(target, base, _from, ri, opval) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">target</strong>: output target address (C++: ea_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">base</strong>: output base address (C++: ea_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">_from</strong>: the referencing instruction/data address (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">ri</strong>: reference info block from the database (C++: const<div class="epy_nested">
refinfo_t
&amp;)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">opval</strong>: operand value (usually
op_t::value
or
op_t::addr )<div class="epy_nested">
(C++: adiff_t)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: success</div>
</div></div>
</dd>
<dt id="ida_offset.calc_target"><code class="name flex">
<span>def <span class="ident">calc_target</span></span>(<span>*args) &#8209;&gt;&#160;ea_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Calculates the target, using the provided 'refinfo_t' .</div>
<div class="epy_par">
<strong class="epy_sig">calc_target(_from, opval, ri) -&gt; ea_t</strong><div class="epy_nested">
<strong class="epy_parameter">_from</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">opval</strong> (C++: adiff_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">ri</strong> (C++: const
refinfo_t
&amp;)</div>
</div>
<div class="epy_par">
<strong class="epy_sig">calc_target(_from, ea, n, opval) -&gt; ea_t</strong><div class="epy_nested">
<strong class="epy_parameter">_from</strong> (C++: ea_t)
ea: ea_t
n: int</div>
<div class="epy_nested">
<strong class="epy_parameter">opval</strong> (C++: adiff_t)</div>
</div></div>
</dd>
<dt id="ida_offset.can_be_off32"><code class="name flex">
<span>def <span class="ident">can_be_off32</span></span>(<span>*args) &#8209;&gt;&#160;ea_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Does the specified address contain a valid OFF32 value?. For symbols
in special segments the displacement is not taken into account. If
yes, then the target address of OFF32 will be returned. If not, then
'BADADDR' is returned.</div>
<div class="epy_par">
<strong class="epy_sig">can_be_off32(ea) -&gt; ea_t</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
</div></div>
</dd>
<dt id="ida_offset.get_default_reftype"><code class="name flex">
<span>def <span class="ident">get_default_reftype</span></span>(<span>*args) &#8209;&gt;&#160;reftype_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get default reference type depending on the segment.</div>
<div class="epy_par">
<strong class="epy_sig">get_default_reftype(ea) -&gt; reftype_t</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: one of
REF_OFF8 , REF_OFF16 , REF_OFF32</div>
</div></div>
</dd>
<dt id="ida_offset.get_offbase"><code class="name flex">
<span>def <span class="ident">get_offbase</span></span>(<span>*args) &#8209;&gt;&#160;ea_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get offset base value</div>
<div class="epy_par">
<strong class="epy_sig">get_offbase(ea, n) -&gt; ea_t</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong>: linear address (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">n</strong>: number of operand (C++: int)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: offset base or
BADADDR</div>
</div></div>
</dd>
<dt id="ida_offset.get_offset_expr"><code class="name flex">
<span>def <span class="ident">get_offset_expr</span></span>(<span>*args) &#8209;&gt;&#160;qstring&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
See 'get_offset_expression()'</div>
<div class="epy_par">
<strong class="epy_sig">get_offset_expr(ea, n, ri, _from, offset, getn_flags=0) -&gt; str</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">n</strong> (C++: int)</div>
<div class="epy_nested">
<strong class="epy_parameter">ri</strong> (C++: const
refinfo_t
&amp;)</div>
<div class="epy_nested">
<strong class="epy_parameter">_from</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">offset</strong> (C++: adiff_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">getn_flags</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_offset.get_offset_expression"><code class="name flex">
<span>def <span class="ident">get_offset_expression</span></span>(<span>*args) &#8209;&gt;&#160;qstring&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get offset expression (in the form "offset name+displ"). This function
uses offset translation function (\ph{translate}
) if your IDP module
has such a function. Translation function is used to map linear
addresses in the program (only for offsets).Example: suppose we have
instruction at linear address 0x00011000: \v{mov ax, [bx+7422h]}
and
at ds:7422h: \v{array dw ...}
We want to represent the second operand
with an offset expression, so then we call: \v{ get_offset_expresion(0x001100, 1, 0x001102, 0x7422,
instruction }
and the function will return a colored string: \v{offset
array}</div>
<div class="epy_par">
<strong class="epy_sig">get_offset_expression(ea, n, _from, offset, getn_flags=0) -&gt; str</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong>: start of instruction or data with the offset expression<div class="epy_nested">
(C++: ea_t)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">n</strong>: number of operand (may be ORed with
OPND_OUTER )
0: first<div class="epy_nested">
operand
1: second operand (C++: int)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">_from</strong>: linear address of instruction operand or data referring<div class="epy_nested">
to the name. This address will be used to get fixup
information, so it should point to exact position of
operand in the instruction. (C++: ea_t)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">offset</strong>: value of operand or its part. The function will return<div class="epy_nested">
text representation of this value as offset expression.
(C++: adiff_t)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">getn_flags</strong>: combination of:
GETN_APPZERO : meaningful only if<div class="epy_nested">
the name refers to a structure. appends the struct
field name if the field offset is zero
GETN_NODUMMY : do not generate dummy names for the
expression but pretend they already exist (useful
to verify that the offset expression can be
represented) (C++: int)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - can't convert to offset expression</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 - ok, a simple offset expression</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 2 - ok, a complex offset expression</div>
</div></div>
</dd>
<dt id="ida_offset.op_offset"><code class="name flex">
<span>def <span class="ident">op_offset</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
See 'op_offset_ex()'</div>
<div class="epy_par">
<strong class="epy_sig">op_offset(ea, n, type_and_flags, target=BADADDR, base=0, tdelta=0) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">n</strong> (C++: int)</div>
<div class="epy_nested">
<strong class="epy_parameter">type_and_flags</strong> (C++: uint32)</div>
<div class="epy_nested">
<strong class="epy_parameter">target</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">base</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">tdelta</strong> (C++: adiff_t)</div>
</div></div>
</dd>
<dt id="ida_offset.op_offset_ex"><code class="name flex">
<span>def <span class="ident">op_offset_ex</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Convert operand to a reference. To delete an offset, use
'clr_op_type()' function.</div>
<div class="epy_par">
<strong class="epy_sig">op_offset_ex(ea, n, ri) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong>: linear address. if 'ea' has unexplored bytes, try to<div class="epy_nested">
convert them to
no segment: fail
16bit segment: to
16bit word data
32bit segment: to dword (C++: ea_t)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">n</strong>: number of operand (may be ORed with
OPND_OUTER )
0: first<div class="epy_nested">
1: second
2: third
OPND_MASK : all operands (C++: int)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">ri</strong>: reference information (C++: const
refinfo_t
*)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: success</div>
</div></div>
</dd>
<dt id="ida_offset.op_plain_offset"><code class="name flex">
<span>def <span class="ident">op_plain_offset</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Convert operand to a reference with the default reference type.</div>
<div class="epy_par">
<strong class="epy_sig">op_plain_offset(ea, n, base) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">n</strong> (C++: int)</div>
<div class="epy_nested">
<strong class="epy_parameter">base</strong> (C++: ea_t)</div>
</div></div>
</dd>
</dl>
</section>
<section>
</section>
</article>
</main>
<footer id="footer">
<p>Copyright (c) 2021 Hex-Rays SA. <a href="/terms_of_use.shtml">Terms of use</a> and <a href="/privacy_policy.shtml">privacy policy</a>.</p>
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> ???</a>.</p>
</footer>
</body>
</html>