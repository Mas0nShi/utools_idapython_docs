<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1"/>
<meta name="generator" content="pdoc ???"/>
<title>ida_bytes API documentation</title>
<meta name="description" content="IDA Plugin SDK API wrapper: bytes"/>
<link rel="preload stylesheet" as="style" href="assets/sanitize.min.css"/>
<link rel="preload stylesheet" as="style" href="assets/typography.min.css"/>
<link rel="stylesheet preload" as="style" href="assets/github.min.css"/>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar &amp;gt; *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl &amp;gt; dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:-webkit-fill-available}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name &amp;gt; span:first-child{white-space:nowrap}.name.class &amp;gt; span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary &amp;gt; *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content: ',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width: 700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content padding:3em 4em;border-left:1px solid #ddd;lid #ddd;}pre code{font-size:1em}.item .name{font-size:1em}main{/* display:flex; *//* flex-direction:row-reverse; *//* justify-content:flex-end; */}.toc ul ul,#index ul{padding-left:1.5em}.toc &gt; ul &gt; li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer="defer" src="assets/highlight.min.js"/>
<script>window.addEventListener('DOMContentLoaded', () =&gt; hljs.initHighlighting())</script>
<style>
#section-intro .epy_par
{
margin-top: 18px;
}
</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ida_bytes</code></h1>
</header>
<section id="section-intro">
<div class="epy_par">
IDA Plugin SDK API wrapper: bytes</div>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="ida_bytes.ALOPT_IGNCLT"><code class="name">var <span class="ident">ALOPT_IGNCLT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
if set, don't stop at codepoints that are not part of the current
'culture'; accept all those that are graphical (this is typically used
used by user-initiated actions creating string literals.)</div></div>
</dd>
<dt id="ida_bytes.ALOPT_IGNHEADS"><code class="name">var <span class="ident">ALOPT_IGNHEADS</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
don't stop if another data item is encountered. only the byte values
will be used to determine the string length. if not set, a defined
data item or instruction will truncate the string</div></div>
</dd>
<dt id="ida_bytes.ALOPT_IGNPRINT"><code class="name">var <span class="ident">ALOPT_IGNPRINT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
if set, don't stop at non-printable codepoints, but only at the
terminating character (or not unicode-mapped character (e.g., 0x8f in
CP1252))</div></div>
</dd>
<dt id="ida_bytes.ALOPT_MAX4K"><code class="name">var <span class="ident">ALOPT_MAX4K</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
if string length is more than 4K, return the accumulated length</div></div>
</dd>
<dt id="ida_bytes.BIN_SEARCH_BACKWARD"><code class="name">var <span class="ident">BIN_SEARCH_BACKWARD</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
search backward for bytes</div></div>
</dd>
<dt id="ida_bytes.BIN_SEARCH_CASE"><code class="name">var <span class="ident">BIN_SEARCH_CASE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
case sensitive</div></div>
</dd>
<dt id="ida_bytes.BIN_SEARCH_FORWARD"><code class="name">var <span class="ident">BIN_SEARCH_FORWARD</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
search forward for bytes</div></div>
</dd>
<dt id="ida_bytes.BIN_SEARCH_INITED"><code class="name">var <span class="ident">BIN_SEARCH_INITED</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
find_byte, find_byter: any initilized value</div></div>
</dd>
<dt id="ida_bytes.BIN_SEARCH_NOBREAK"><code class="name">var <span class="ident">BIN_SEARCH_NOBREAK</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
don't check for Ctrl-Break</div></div>
</dd>
<dt id="ida_bytes.BIN_SEARCH_NOCASE"><code class="name">var <span class="ident">BIN_SEARCH_NOCASE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
case insensitive</div></div>
</dd>
<dt id="ida_bytes.BIN_SEARCH_NOSHOW"><code class="name">var <span class="ident">BIN_SEARCH_NOSHOW</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
don't show search progress or update screen</div></div>
</dd>
<dt id="ida_bytes.DELIT_DELNAMES"><code class="name">var <span class="ident">DELIT_DELNAMES</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
delete any names at the specified address range (except for the
starting address). this bit is valid if nbytes &gt; 1</div></div>
</dd>
<dt id="ida_bytes.DELIT_EXPAND"><code class="name">var <span class="ident">DELIT_EXPAND</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
propagate undefined items; for example if removing an instruction
removes all references to the next instruction, then plan to convert
to unexplored the next instruction too.</div></div>
</dd>
<dt id="ida_bytes.DELIT_KEEPFUNC"><code class="name">var <span class="ident">DELIT_KEEPFUNC</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
do not undefine the function start. Just delete xrefs, ops e.t.c.</div></div>
</dd>
<dt id="ida_bytes.DELIT_NOCMT"><code class="name">var <span class="ident">DELIT_NOCMT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
reject to delete if a comment is in address range (except for the
starting address). this bit is valid if nbytes &gt; 1</div></div>
</dd>
<dt id="ida_bytes.DELIT_NOTRUNC"><code class="name">var <span class="ident">DELIT_NOTRUNC</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
don't truncate the current function even if 'AF_TRFUNC' is set</div></div>
</dd>
<dt id="ida_bytes.DELIT_NOUNAME"><code class="name">var <span class="ident">DELIT_NOUNAME</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
reject to delete if a user name is in address range (except for the
starting address). this bit is valid if nbytes &gt; 1</div></div>
</dd>
<dt id="ida_bytes.DELIT_SIMPLE"><code class="name">var <span class="ident">DELIT_SIMPLE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
simply undefine the specified item(s)</div></div>
</dd>
<dt id="ida_bytes.DTP_NODUP"><code class="name">var <span class="ident">DTP_NODUP</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
do not use dup construct</div></div>
</dd>
<dt id="ida_bytes.DT_TYPE"><code class="name">var <span class="ident">DT_TYPE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Mask for DATA typing.</div></div>
</dd>
<dt id="ida_bytes.FF_0CHAR"><code class="name">var <span class="ident">FF_0CHAR</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Char ('x')?</div></div>
</dd>
<dt id="ida_bytes.FF_0CUST"><code class="name">var <span class="ident">FF_0CUST</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Custom representation?</div></div>
</dd>
<dt id="ida_bytes.FF_0ENUM"><code class="name">var <span class="ident">FF_0ENUM</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Enumeration?</div></div>
</dd>
<dt id="ida_bytes.FF_0FLT"><code class="name">var <span class="ident">FF_0FLT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Floating point number?</div></div>
</dd>
<dt id="ida_bytes.FF_0FOP"><code class="name">var <span class="ident">FF_0FOP</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Forced operand?</div></div>
</dd>
<dt id="ida_bytes.FF_0NUMB"><code class="name">var <span class="ident">FF_0NUMB</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Binary number?</div></div>
</dd>
<dt id="ida_bytes.FF_0NUMD"><code class="name">var <span class="ident">FF_0NUMD</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Decimal number?</div></div>
</dd>
<dt id="ida_bytes.FF_0NUMH"><code class="name">var <span class="ident">FF_0NUMH</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Hexadecimal number?</div></div>
</dd>
<dt id="ida_bytes.FF_0NUMO"><code class="name">var <span class="ident">FF_0NUMO</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Octal number?</div></div>
</dd>
<dt id="ida_bytes.FF_0OFF"><code class="name">var <span class="ident">FF_0OFF</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Offset?</div></div>
</dd>
<dt id="ida_bytes.FF_0SEG"><code class="name">var <span class="ident">FF_0SEG</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Segment?</div></div>
</dd>
<dt id="ida_bytes.FF_0STK"><code class="name">var <span class="ident">FF_0STK</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Stack variable?</div></div>
</dd>
<dt id="ida_bytes.FF_0STRO"><code class="name">var <span class="ident">FF_0STRO</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Struct offset?</div></div>
</dd>
<dt id="ida_bytes.FF_0VOID"><code class="name">var <span class="ident">FF_0VOID</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Void (unknown)?</div></div>
</dd>
<dt id="ida_bytes.FF_1CHAR"><code class="name">var <span class="ident">FF_1CHAR</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Char ('x')?</div></div>
</dd>
<dt id="ida_bytes.FF_1CUST"><code class="name">var <span class="ident">FF_1CUST</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Custom representation?</div></div>
</dd>
<dt id="ida_bytes.FF_1ENUM"><code class="name">var <span class="ident">FF_1ENUM</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Enumeration?</div></div>
</dd>
<dt id="ida_bytes.FF_1FLT"><code class="name">var <span class="ident">FF_1FLT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Floating point number?</div></div>
</dd>
<dt id="ida_bytes.FF_1FOP"><code class="name">var <span class="ident">FF_1FOP</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Forced operand?</div></div>
</dd>
<dt id="ida_bytes.FF_1NUMB"><code class="name">var <span class="ident">FF_1NUMB</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Binary number?</div></div>
</dd>
<dt id="ida_bytes.FF_1NUMD"><code class="name">var <span class="ident">FF_1NUMD</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Decimal number?</div></div>
</dd>
<dt id="ida_bytes.FF_1NUMH"><code class="name">var <span class="ident">FF_1NUMH</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Hexadecimal number?</div></div>
</dd>
<dt id="ida_bytes.FF_1NUMO"><code class="name">var <span class="ident">FF_1NUMO</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Octal number?</div></div>
</dd>
<dt id="ida_bytes.FF_1OFF"><code class="name">var <span class="ident">FF_1OFF</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Offset?</div></div>
</dd>
<dt id="ida_bytes.FF_1SEG"><code class="name">var <span class="ident">FF_1SEG</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Segment?</div></div>
</dd>
<dt id="ida_bytes.FF_1STK"><code class="name">var <span class="ident">FF_1STK</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Stack variable?</div></div>
</dd>
<dt id="ida_bytes.FF_1STRO"><code class="name">var <span class="ident">FF_1STRO</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Struct offset?</div></div>
</dd>
<dt id="ida_bytes.FF_1VOID"><code class="name">var <span class="ident">FF_1VOID</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Void (unknown)?</div></div>
</dd>
<dt id="ida_bytes.FF_ALIGN"><code class="name">var <span class="ident">FF_ALIGN</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
alignment directive</div></div>
</dd>
<dt id="ida_bytes.FF_ANYNAME"><code class="name">var <span class="ident">FF_ANYNAME</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
FF_ANYNAME = 49152</div></div>
</dd>
<dt id="ida_bytes.FF_BNOT"><code class="name">var <span class="ident">FF_BNOT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Bitwise negation of operands.</div></div>
</dd>
<dt id="ida_bytes.FF_BYTE"><code class="name">var <span class="ident">FF_BYTE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
byte</div></div>
</dd>
<dt id="ida_bytes.FF_CODE"><code class="name">var <span class="ident">FF_CODE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Code ?</div></div>
</dd>
<dt id="ida_bytes.FF_COMM"><code class="name">var <span class="ident">FF_COMM</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Has comment ?</div></div>
</dd>
<dt id="ida_bytes.FF_CUSTOM"><code class="name">var <span class="ident">FF_CUSTOM</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
custom data type</div></div>
</dd>
<dt id="ida_bytes.FF_DATA"><code class="name">var <span class="ident">FF_DATA</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Data ?</div></div>
</dd>
<dt id="ida_bytes.FF_DOUBLE"><code class="name">var <span class="ident">FF_DOUBLE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
double</div></div>
</dd>
<dt id="ida_bytes.FF_DWORD"><code class="name">var <span class="ident">FF_DWORD</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
double word</div></div>
</dd>
<dt id="ida_bytes.FF_FLOAT"><code class="name">var <span class="ident">FF_FLOAT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
float</div></div>
</dd>
<dt id="ida_bytes.FF_FLOW"><code class="name">var <span class="ident">FF_FLOW</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Exec flow from prev instruction.</div></div>
</dd>
<dt id="ida_bytes.FF_FUNC"><code class="name">var <span class="ident">FF_FUNC</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
function start?</div></div>
</dd>
<dt id="ida_bytes.FF_IMMD"><code class="name">var <span class="ident">FF_IMMD</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Has Immediate value ?</div></div>
</dd>
<dt id="ida_bytes.FF_IVL"><code class="name">var <span class="ident">FF_IVL</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Byte has value ?</div></div>
</dd>
<dt id="ida_bytes.FF_JUMP"><code class="name">var <span class="ident">FF_JUMP</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Has jump table or switch_info?</div></div>
</dd>
<dt id="ida_bytes.FF_LABL"><code class="name">var <span class="ident">FF_LABL</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Has dummy name?</div></div>
</dd>
<dt id="ida_bytes.FF_LINE"><code class="name">var <span class="ident">FF_LINE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Has next or prev lines ?</div></div>
</dd>
<dt id="ida_bytes.FF_NAME"><code class="name">var <span class="ident">FF_NAME</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Has name ?</div></div>
</dd>
<dt id="ida_bytes.FF_OWORD"><code class="name">var <span class="ident">FF_OWORD</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
octaword/xmm word (16 bytes/128 bits)</div></div>
</dd>
<dt id="ida_bytes.FF_PACKREAL"><code class="name">var <span class="ident">FF_PACKREAL</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
packed decimal real</div></div>
</dd>
<dt id="ida_bytes.FF_QWORD"><code class="name">var <span class="ident">FF_QWORD</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
quadro word</div></div>
</dd>
<dt id="ida_bytes.FF_REF"><code class="name">var <span class="ident">FF_REF</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
has references</div></div>
</dd>
<dt id="ida_bytes.FF_SIGN"><code class="name">var <span class="ident">FF_SIGN</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Inverted sign of operands.</div></div>
</dd>
<dt id="ida_bytes.FF_STRLIT"><code class="name">var <span class="ident">FF_STRLIT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
string literal</div></div>
</dd>
<dt id="ida_bytes.FF_STRUCT"><code class="name">var <span class="ident">FF_STRUCT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
struct variable</div></div>
</dd>
<dt id="ida_bytes.FF_TAIL"><code class="name">var <span class="ident">FF_TAIL</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Tail ?</div></div>
</dd>
<dt id="ida_bytes.FF_TBYTE"><code class="name">var <span class="ident">FF_TBYTE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
tbyte</div></div>
</dd>
<dt id="ida_bytes.FF_UNK"><code class="name">var <span class="ident">FF_UNK</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Unknown ?</div></div>
</dd>
<dt id="ida_bytes.FF_UNUSED"><code class="name">var <span class="ident">FF_UNUSED</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
unused bit (was used for variable bytes)</div></div>
</dd>
<dt id="ida_bytes.FF_WORD"><code class="name">var <span class="ident">FF_WORD</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
word</div></div>
</dd>
<dt id="ida_bytes.FF_YWORD"><code class="name">var <span class="ident">FF_YWORD</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
ymm word (32 bytes/256 bits)</div></div>
</dd>
<dt id="ida_bytes.FF_ZWORD"><code class="name">var <span class="ident">FF_ZWORD</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
zmm word (64 bytes/512 bits)</div></div>
</dd>
<dt id="ida_bytes.GFE_VALUE"><code class="name">var <span class="ident">GFE_VALUE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
get flags with 'FF_IVL' &amp; 'MS_VAL' . It is much slower under remote
debugging because the kernel needs to read the process memory.</div></div>
</dd>
<dt id="ida_bytes.GMB_READALL"><code class="name">var <span class="ident">GMB_READALL</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
try to read all bytes if this bit is not set, fail at first uninited
byte</div></div>
</dd>
<dt id="ida_bytes.GMB_WAITBOX"><code class="name">var <span class="ident">GMB_WAITBOX</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
show wait box (may return -1 in this case)</div></div>
</dd>
<dt id="ida_bytes.ITEM_END_FIXUP"><code class="name">var <span class="ident">ITEM_END_FIXUP</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
stop at the first fixup</div></div>
</dd>
<dt id="ida_bytes.ITEM_END_INITED"><code class="name">var <span class="ident">ITEM_END_INITED</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
stop when initialization changes i.e.if is_loaded(ea): stop if
uninitialized byte is encounteredif !is_loaded(ea): stop if
initialized byte is encountered</div></div>
</dd>
<dt id="ida_bytes.ITEM_END_NAME"><code class="name">var <span class="ident">ITEM_END_NAME</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
stop at the first named location</div></div>
</dd>
<dt id="ida_bytes.ITEM_END_XREF"><code class="name">var <span class="ident">ITEM_END_XREF</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
stop at the first referenced location</div></div>
</dd>
<dt id="ida_bytes.MS_0TYPE"><code class="name">var <span class="ident">MS_0TYPE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Mask for 1st arg typing.</div></div>
</dd>
<dt id="ida_bytes.MS_1TYPE"><code class="name">var <span class="ident">MS_1TYPE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Mask for the type of other operands.</div></div>
</dd>
<dt id="ida_bytes.MS_CLS"><code class="name">var <span class="ident">MS_CLS</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Mask for typing.</div></div>
</dd>
<dt id="ida_bytes.MS_CODE"><code class="name">var <span class="ident">MS_CODE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Mask for code bits.</div></div>
</dd>
<dt id="ida_bytes.MS_COMM"><code class="name">var <span class="ident">MS_COMM</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Mask of common bits.</div></div>
</dd>
<dt id="ida_bytes.MS_VAL"><code class="name">var <span class="ident">MS_VAL</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Mask for byte value.</div></div>
</dd>
<dt id="ida_bytes.OPND_ALL"><code class="name">var <span class="ident">OPND_ALL</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
all operands</div></div>
</dd>
<dt id="ida_bytes.OPND_MASK"><code class="name">var <span class="ident">OPND_MASK</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
mask for operand number</div></div>
</dd>
<dt id="ida_bytes.OPND_OUTER"><code class="name">var <span class="ident">OPND_OUTER</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
outer offset base (combined with operand number). used only in set,
get, del_offset() functions</div></div>
</dd>
<dt id="ida_bytes.PBSENC_ALL"><code class="name">var <span class="ident">PBSENC_ALL</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
PBSENC_ALL = -1</div></div>
</dd>
<dt id="ida_bytes.PBSENC_DEF1BPU"><code class="name">var <span class="ident">PBSENC_DEF1BPU</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
PBSENC_DEF1BPU = 0</div></div>
</dd>
<dt id="ida_bytes.PSTF_ENC"><code class="name">var <span class="ident">PSTF_ENC</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
if encoding is specified, append it</div></div>
</dd>
<dt id="ida_bytes.PSTF_HOTKEY"><code class="name">var <span class="ident">PSTF_HOTKEY</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
have hotkey markers part of the name</div></div>
</dd>
<dt id="ida_bytes.PSTF_TBRIEF"><code class="name">var <span class="ident">PSTF_TBRIEF</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
use brief name (e.g., in the 'Strings' window)</div></div>
</dd>
<dt id="ida_bytes.PSTF_TINLIN"><code class="name">var <span class="ident">PSTF_TINLIN</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
use 'inline' name (e.g., in the structures comments)</div></div>
</dd>
<dt id="ida_bytes.PSTF_TMASK"><code class="name">var <span class="ident">PSTF_TMASK</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
type mask</div></div>
</dd>
<dt id="ida_bytes.PSTF_TNORM"><code class="name">var <span class="ident">PSTF_TNORM</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
use normal name</div></div>
</dd>
<dt id="ida_bytes.STRCONV_ESCAPE"><code class="name">var <span class="ident">STRCONV_ESCAPE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
convert non-printable characters to C escapes (, \xNN, \uNNNN)</div></div>
</dd>
<dt id="ida_bytes.STRCONV_INCLLEN"><code class="name">var <span class="ident">STRCONV_INCLLEN</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
for Pascal-style strings, include the prefixing length byte(s) as
C-escaped sequence</div></div>
</dd>
<dt id="ida_bytes.STRCONV_REPLCHAR"><code class="name">var <span class="ident">STRCONV_REPLCHAR</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
convert non-printable characters to the Unicode replacement character
(U+FFFD)</div></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="ida_bytes.add_byte"><code class="name flex">
<span>def <span class="ident">add_byte</span></span>(<span>*args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Add a value to one byte of the program. This function works for wide
byte processors too.</div>
<div class="epy_par">
<strong class="epy_sig">add_byte(ea, value)</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong>: linear address (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">value</strong>: byte value (C++: uint32)</div>
</div></div>
</dd>
<dt id="ida_bytes.add_dword"><code class="name flex">
<span>def <span class="ident">add_dword</span></span>(<span>*args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Add a value to one dword of the program. This function works for wide
byte processors too. This function takes into account order of bytes
specified in \inf{is_be()}
this function works incorrectly if</div>
<div class="epy_par">
\ph{nbits}<div class="epy_nested">
&gt; 16</div>
</div>
<div class="epy_par">
<strong class="epy_sig">add_dword(ea, value)</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong>: linear address (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">value</strong>: byte value (C++: uint64)</div>
</div></div>
</dd>
<dt id="ida_bytes.add_hidden_range"><code class="name flex">
<span>def <span class="ident">add_hidden_range</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Mark a range of addresses as hidden. The range will be created in the
invisible state with the default color</div>
<div class="epy_par">
<strong class="epy_sig">add_hidden_range(ea1, ea2, description, header, footer, color) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea1</strong>: linear address of start of the address range (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">ea2</strong>: linear address of end of the address range (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">description</strong>: range parameters (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">header</strong>: range parameters (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">footer</strong>: range parameters (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">color</strong> (C++: bgcolor_t)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: success</div>
</div></div>
</dd>
<dt id="ida_bytes.add_mapping"><code class="name flex">
<span>def <span class="ident">add_mapping</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
IDA supports memory mapping. References to the addresses from the
mapped range use data and meta-data from the mapping range.You should
set flag PR2_MAPPING in ph.flag2 to use memory mapping Add memory
mapping range.</div>
<div class="epy_par">
<strong class="epy_sig">add_mapping(_from, to, size) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">_from</strong>: start of the mapped range (nonexistent address) (C++:<div class="epy_nested">
ea_t)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">to</strong>: start of the mapping range (existent address) (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">size</strong>: size of the range (C++: asize_t)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: success</div>
</div></div>
</dd>
<dt id="ida_bytes.add_qword"><code class="name flex">
<span>def <span class="ident">add_qword</span></span>(<span>*args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Add a value to one qword of the program. This function does not work
for wide byte processors. This function takes into account order of
bytes specified in \inf{is_be()}</div>
<div class="epy_par">
<strong class="epy_sig">add_qword(ea, value)</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong>: linear address (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">value</strong>: byte value (C++: uint64)</div>
</div></div>
</dd>
<dt id="ida_bytes.add_word"><code class="name flex">
<span>def <span class="ident">add_word</span></span>(<span>*args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Add a value to one word of the program. This function works for wide
byte processors too. This function takes into account order of bytes
specified in \inf{is_be()}</div>
<div class="epy_par">
<strong class="epy_sig">add_word(ea, value)</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong>: linear address (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">value</strong>: byte value (C++: uint64)</div>
</div></div>
</dd>
<dt id="ida_bytes.align_flag"><code class="name flex">
<span>def <span class="ident">align_flag</span></span>(<span>*args) &#8209;&gt;&#160;flags_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get a flags_t representing an alignment directive.</div></div>
</dd>
<dt id="ida_bytes.append_cmt"><code class="name flex">
<span>def <span class="ident">append_cmt</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Append to an indented comment. Creates a new comment if none exists.
Appends a newline character and the specified string otherwise.</div>
<div class="epy_par">
<strong class="epy_sig">append_cmt(ea, str, rptble) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong>: linear address (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">str</strong>: comment string to append (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">rptble</strong>: append to repeatable comment? (C++: bool)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: success</div>
</div></div>
</dd>
<dt id="ida_bytes.attach_custom_data_format"><code class="name flex">
<span>def <span class="ident">attach_custom_data_format</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Attach the data format to the data type.</div>
<div class="epy_par">
<strong class="epy_sig">attach_custom_data_format(dtid, dfid) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">dtid</strong>: data type id that can use the data format. 0 means all<div class="epy_nested">
standard data types. Such data formats can be applied to
any data item or instruction operands. For instruction
operands, the
data_format_t::value_size
check is not
performed by the kernel. (C++: int)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">dfid</strong>: data format id (C++: int)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: true - ok</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: false - no such
dtid , or no such
dfid , or the data format<div class="epy_nested">
has already been attached to the data type</div>
</div>
</div></div>
</dd>
<dt id="ida_bytes.bin_flag"><code class="name flex">
<span>def <span class="ident">bin_flag</span></span>(<span>*args) &#8209;&gt;&#160;flags_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get number flag of the base, regardless of current processor - better
to use 'num_flag()'</div></div>
</dd>
<dt id="ida_bytes.bin_search"><code class="name flex">
<span>def <span class="ident">bin_search</span></span>(<span>*args) &#8209;&gt;&#160;ea_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">bin_search(start_ea, end_ea, data, flags) -&gt; ea_t</strong><div class="epy_nested">
Search for a set of bytes in the program</div>
<div class="epy_nested">
<strong class="epy_parameter">start_ea</strong>: linear address, start of range to search</div>
<div class="epy_nested">
<strong class="epy_parameter">end_ea</strong>: linear address, end of range to search (exclusive)</div>
<div class="epy_nested">
<strong class="epy_parameter">data</strong>: the prepared data to search for (see parse_binpat_str())</div>
<div class="epy_nested">
<strong class="epy_parameter">flags</strong>: combination of BIN_SEARCH_* flags</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: the address of a match, or ida_idaapi.BADADDR if not found</div>
</div></div>
</dd>
<dt id="ida_bytes.byte_flag"><code class="name flex">
<span>def <span class="ident">byte_flag</span></span>(<span>*args) &#8209;&gt;&#160;flags_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get a flags_t representing a byte.</div></div>
</dd>
<dt id="ida_bytes.bytesize"><code class="name flex">
<span>def <span class="ident">bytesize</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get number of bytes required to store a byte at the given address.</div>
<div class="epy_par">
<strong class="epy_sig">bytesize(ea) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.calc_def_align"><code class="name flex">
<span>def <span class="ident">calc_def_align</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Calculate the default alignment exponent.</div>
<div class="epy_par">
<strong class="epy_sig">calc_def_align(ea, mina, maxa) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong>: linear address (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">mina</strong>: minimal possible alignment exponent. (C++: int)</div>
<div class="epy_nested">
<strong class="epy_parameter">maxa</strong>: minimal possible alignment exponent. (C++: int)</div>
</div></div>
</dd>
<dt id="ida_bytes.calc_dflags"><code class="name flex">
<span>def <span class="ident">calc_dflags</span></span>(<span>*args) &#8209;&gt;&#160;flags_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">calc_dflags(f, force) -&gt; flags_t</strong><div class="epy_nested">
<strong class="epy_parameter">f</strong> (C++: flags_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">force</strong> (C++: bool)</div>
</div></div>
</dd>
<dt id="ida_bytes.calc_max_align"><code class="name flex">
<span>def <span class="ident">calc_max_align</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Calculate the maximal possible alignment exponent.</div>
<div class="epy_par">
<strong class="epy_sig">calc_max_align(endea) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">endea</strong>: end address of the alignment item. (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: a value in the 0..32 range</div>
</div></div>
</dd>
<dt id="ida_bytes.calc_max_item_end"><code class="name flex">
<span>def <span class="ident">calc_max_item_end</span></span>(<span>*args) &#8209;&gt;&#160;ea_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Calculate maximal reasonable end address of a new item. This function
will limit the item with the current segment bounds.</div>
<div class="epy_par">
<strong class="epy_sig">calc_max_item_end(ea, how=15) -&gt; ea_t</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong>: linear address (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">how</strong>: when to stop the search. A combination of
Item end search<div class="epy_nested">
flags (C++: int)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: end of new item. If it is not possible to create an item, it<div class="epy_nested">
will return 'ea'.</div>
</div>
</div></div>
</dd>
<dt id="ida_bytes.calc_min_align"><code class="name flex">
<span>def <span class="ident">calc_min_align</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Calculate the minimal possible alignment exponent.</div>
<div class="epy_par">
<strong class="epy_sig">calc_min_align(length) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">length</strong>: size of the item in bytes. (C++: asize_t)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: a value in the 1..32 range</div>
</div></div>
</dd>
<dt id="ida_bytes.can_define_item"><code class="name flex">
<span>def <span class="ident">can_define_item</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Can define item (instruction/data) of the specified 'length', starting
at 'ea'?if there is an item starting at 'ea', this function ignores
itthis function converts to unexplored all encountered data items with
fixup information. Should be fixed in the future.a new item would
cross segment boundariesa new item would overlap with existing items
(except items specified by 'flags')</div>
<div class="epy_par">
<strong class="epy_sig">can_define_item(ea, length, flags) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">length</strong> (C++: asize_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">flags</strong>: if not 0, then the kernel will ignore the data types<div class="epy_nested">
specified by the flags and destroy them. For example:
1000 dw 5
1002 db 5 ; undef
1003 db 5 ; undef
1004 dw 5
1006 dd 5
can_define_item(1000, 6, 0)</div>
<ul class="epy_ul">
<li class="epy_li"><span class="epy_nested">
false because of dw at 1004
can_define_item(1000,
6, word_flag()) - true, word at 1004 is destroyed (C++:
flags_t)</span>
</li>
</ul>
</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: 1-yes, 0-no</div>
</div></div>
</dd>
<dt id="ida_bytes.change_storage_type"><code class="name flex">
<span>def <span class="ident">change_storage_type</span></span>(<span>*args) &#8209;&gt;&#160;error_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Change flag storage type for address range.</div>
<div class="epy_par">
<strong class="epy_sig">change_storage_type(start_ea, end_ea, stt) -&gt; error_t</strong><div class="epy_nested">
<strong class="epy_parameter">start_ea</strong>: should be lower than end_ea. (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">end_ea</strong>: does not belong to the range. (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">stt</strong>: storage_type_t (C++: storage_type_t)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: error code</div>
</div></div>
</dd>
<dt id="ida_bytes.char_flag"><code class="name flex">
<span>def <span class="ident">char_flag</span></span>(<span>*args) &#8209;&gt;&#160;flags_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
see 'Bits: instruction operand types'</div></div>
</dd>
<dt id="ida_bytes.chunk_size"><code class="name flex">
<span>def <span class="ident">chunk_size</span></span>(<span>*args) &#8209;&gt;&#160;asize_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get size of the contiguous address block containing 'ea'.</div>
<div class="epy_par">
<strong class="epy_sig">chunk_size(ea) -&gt; asize_t</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: 0 if 'ea' doesn't belong to the program.</div>
</div></div>
</dd>
<dt id="ida_bytes.chunk_start"><code class="name flex">
<span>def <span class="ident">chunk_start</span></span>(<span>*args) &#8209;&gt;&#160;ea_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get start of the contiguous address block containing 'ea'.</div>
<div class="epy_par">
<strong class="epy_sig">chunk_start(ea) -&gt; ea_t</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: BADADDR
if 'ea' doesn't belong to the program.</div>
</div></div>
</dd>
<dt id="ida_bytes.clr_lzero"><code class="name flex">
<span>def <span class="ident">clr_lzero</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Clear lzero bit.</div>
<div class="epy_par">
<strong class="epy_sig">clr_lzero(ea, n) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">n</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_bytes.clr_op_type"><code class="name flex">
<span>def <span class="ident">clr_op_type</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Remove operand representation information. (set operand representation
to be 'undefined')</div>
<div class="epy_par">
<strong class="epy_sig">clr_op_type(ea, n) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong>: linear address (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">n</strong>: number of operand (0, 1, -1) (C++: int)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: success</div>
</div></div>
</dd>
<dt id="ida_bytes.code_flag"><code class="name flex">
<span>def <span class="ident">code_flag</span></span>(<span>*args) &#8209;&gt;&#160;flags_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
'FF_CODE'</div></div>
</dd>
<dt id="ida_bytes.create_16bit_data"><code class="name flex">
<span>def <span class="ident">create_16bit_data</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Convert to 16-bit quantity (take the byte size into account)</div>
<div class="epy_par">
<strong class="epy_sig">create_16bit_data(ea, length) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">length</strong> (C++: asize_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.create_32bit_data"><code class="name flex">
<span>def <span class="ident">create_32bit_data</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Convert to 32-bit quantity (take the byte size into account)</div>
<div class="epy_par">
<strong class="epy_sig">create_32bit_data(ea, length) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">length</strong> (C++: asize_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.create_align"><code class="name flex">
<span>def <span class="ident">create_align</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Create an alignment item.</div>
<div class="epy_par">
<strong class="epy_sig">create_align(ea, length, alignment) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong>: linear address (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">length</strong>: size of the item in bytes. 0 means to infer from<div class="epy_nested">
ALIGNMENT (C++: asize_t)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">alignment</strong>: alignment exponent. Example: 3 means align to 8<div class="epy_nested">
bytes. 0 means to infer from LENGTH It is forbidden
to specify both LENGTH and ALIGNMENT as 0. (C++:
int)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: success</div>
</div></div>
</dd>
<dt id="ida_bytes.create_byte"><code class="name flex">
<span>def <span class="ident">create_byte</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Convert to byte.</div>
<div class="epy_par">
<strong class="epy_sig">create_byte(ea, length, force=False) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">length</strong> (C++: asize_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">force</strong> (C++: bool)</div>
</div></div>
</dd>
<dt id="ida_bytes.create_custdata"><code class="name flex">
<span>def <span class="ident">create_custdata</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Convert to custom data type.</div>
<div class="epy_par">
<strong class="epy_sig">create_custdata(ea, length, dtid, fid, force=False) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">length</strong> (C++: asize_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">dtid</strong> (C++: int)</div>
<div class="epy_nested">
<strong class="epy_parameter">fid</strong> (C++: int)</div>
<div class="epy_nested">
<strong class="epy_parameter">force</strong> (C++: bool)</div>
</div></div>
</dd>
<dt id="ida_bytes.create_data"><code class="name flex">
<span>def <span class="ident">create_data</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Convert to data (byte, word, dword, etc). This function may be used to
create arrays.</div>
<div class="epy_par">
<strong class="epy_sig">create_data(ea, dataflag, size, tid) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong>: linear address (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">dataflag</strong>: type of data. Value of function
byte_flag() ,<div class="epy_nested">
word_flag() , etc. (C++: flags_t)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">size</strong>: size of array in bytes. should be divisible by the size<div class="epy_nested">
of one item of the specified type. for variable sized
items it can be specified as 0, and the kernel will try
to calculate the size. (C++: asize_t)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">tid</strong>: type id. If the specified type is a structure, then tid is<div class="epy_nested">
structure id. Otherwise should be
BADNODE . (C++: tid_t)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: success</div>
</div></div>
</dd>
<dt id="ida_bytes.create_double"><code class="name flex">
<span>def <span class="ident">create_double</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Convert to double.</div>
<div class="epy_par">
<strong class="epy_sig">create_double(ea, length, force=False) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">length</strong> (C++: asize_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">force</strong> (C++: bool)</div>
</div></div>
</dd>
<dt id="ida_bytes.create_dword"><code class="name flex">
<span>def <span class="ident">create_dword</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Convert to dword.</div>
<div class="epy_par">
<strong class="epy_sig">create_dword(ea, length, force=False) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">length</strong> (C++: asize_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">force</strong> (C++: bool)</div>
</div></div>
</dd>
<dt id="ida_bytes.create_float"><code class="name flex">
<span>def <span class="ident">create_float</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Convert to float.</div>
<div class="epy_par">
<strong class="epy_sig">create_float(ea, length, force=False) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">length</strong> (C++: asize_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">force</strong> (C++: bool)</div>
</div></div>
</dd>
<dt id="ida_bytes.create_oword"><code class="name flex">
<span>def <span class="ident">create_oword</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Convert to octaword/xmm word.</div>
<div class="epy_par">
<strong class="epy_sig">create_oword(ea, length, force=False) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">length</strong> (C++: asize_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">force</strong> (C++: bool)</div>
</div></div>
</dd>
<dt id="ida_bytes.create_packed_real"><code class="name flex">
<span>def <span class="ident">create_packed_real</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Convert to packed decimal real.</div>
<div class="epy_par">
<strong class="epy_sig">create_packed_real(ea, length, force=False) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">length</strong> (C++: asize_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">force</strong> (C++: bool)</div>
</div></div>
</dd>
<dt id="ida_bytes.create_qword"><code class="name flex">
<span>def <span class="ident">create_qword</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Convert to quadword.</div>
<div class="epy_par">
<strong class="epy_sig">create_qword(ea, length, force=False) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">length</strong> (C++: asize_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">force</strong> (C++: bool)</div>
</div></div>
</dd>
<dt id="ida_bytes.create_strlit"><code class="name flex">
<span>def <span class="ident">create_strlit</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Convert to string literal and give a meaningful name. 'start' may be
higher than 'end', the kernel will swap them in this case</div>
<div class="epy_par">
<strong class="epy_sig">create_strlit(start, len, strtype) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">start</strong>: starting address (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">len</strong>: length of the string in bytes. if 0, then<div class="epy_nested">
get_max_strlit_length()
will be used to determine the
length (C++: size_t)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">strtype</strong>: string type. one of
String type codes (C++: int32)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: success</div>
</div></div>
</dd>
<dt id="ida_bytes.create_struct"><code class="name flex">
<span>def <span class="ident">create_struct</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Convert to struct.</div>
<div class="epy_par">
<strong class="epy_sig">create_struct(ea, length, tid, force=False) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">length</strong> (C++: asize_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">tid</strong> (C++: tid_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">force</strong> (C++: bool)</div>
</div></div>
</dd>
<dt id="ida_bytes.create_tbyte"><code class="name flex">
<span>def <span class="ident">create_tbyte</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Convert to tbyte.</div>
<div class="epy_par">
<strong class="epy_sig">create_tbyte(ea, length, force=False) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">length</strong> (C++: asize_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">force</strong> (C++: bool)</div>
</div></div>
</dd>
<dt id="ida_bytes.create_word"><code class="name flex">
<span>def <span class="ident">create_word</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Convert to word.</div>
<div class="epy_par">
<strong class="epy_sig">create_word(ea, length, force=False) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">length</strong> (C++: asize_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">force</strong> (C++: bool)</div>
</div></div>
</dd>
<dt id="ida_bytes.create_yword"><code class="name flex">
<span>def <span class="ident">create_yword</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Convert to ymm word.</div>
<div class="epy_par">
<strong class="epy_sig">create_yword(ea, length, force=False) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">length</strong> (C++: asize_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">force</strong> (C++: bool)</div>
</div></div>
</dd>
<dt id="ida_bytes.create_zword"><code class="name flex">
<span>def <span class="ident">create_zword</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Convert to zmm word.</div>
<div class="epy_par">
<strong class="epy_sig">create_zword(ea, length, force=False) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">length</strong> (C++: asize_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">force</strong> (C++: bool)</div>
</div></div>
</dd>
<dt id="ida_bytes.cust_flag"><code class="name flex">
<span>def <span class="ident">cust_flag</span></span>(<span>*args) &#8209;&gt;&#160;flags_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get a flags_t representing custom type data.</div></div>
</dd>
<dt id="ida_bytes.custfmt_flag"><code class="name flex">
<span>def <span class="ident">custfmt_flag</span></span>(<span>*args) &#8209;&gt;&#160;flags_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
see 'Bits: instruction operand types'</div></div>
</dd>
<dt id="ida_bytes.dec_flag"><code class="name flex">
<span>def <span class="ident">dec_flag</span></span>(<span>*args) &#8209;&gt;&#160;flags_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get number flag of the base, regardless of current processor - better
to use 'num_flag()'</div></div>
</dd>
<dt id="ida_bytes.del_hidden_range"><code class="name flex">
<span>def <span class="ident">del_hidden_range</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Delete hidden range.</div>
<div class="epy_par">
<strong class="epy_sig">del_hidden_range(ea) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong>: any address in the hidden range (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: success</div>
</div></div>
</dd>
<dt id="ida_bytes.del_items"><code class="name flex">
<span>def <span class="ident">del_items</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Convert item (instruction/data) to unexplored bytes. The whole item
(including the head and tail bytes) will be destroyed. It is allowed
to pass any address in the item to this function</div>
<div class="epy_par">
<strong class="epy_sig">del_items(ea, flags=0, nbytes=1, may_destroy=None) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong>: any address within the first item to delete (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">flags</strong>: combination of
Unexplored byte conversion flags (C++:<div class="epy_nested">
int)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">nbytes</strong>: number of bytes in the range to be undefined (C++:<div class="epy_nested">
asize_t)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">may_destroy</strong>: optional routine invoked before deleting a head<div class="epy_nested">
item. If callback returns false then item has not
to be deleted and operation fails (C++:
may_destroy_cb_t
*)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: true on sucessful operation, otherwise false</div>
</div></div>
</dd>
<dt id="ida_bytes.del_mapping"><code class="name flex">
<span>def <span class="ident">del_mapping</span></span>(<span>*args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Delete memory mapping range.</div>
<div class="epy_par">
<strong class="epy_sig">del_mapping(ea)</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong>: any address in the mapped range (C++: ea_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.del_value"><code class="name flex">
<span>def <span class="ident">del_value</span></span>(<span>*args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Delete byte value from flags. The corresponding byte becomes
uninitialized.</div>
<div class="epy_par">
<strong class="epy_sig">del_value(ea)</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.detach_custom_data_format"><code class="name flex">
<span>def <span class="ident">detach_custom_data_format</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Detach the data format from the data type. Unregistering a custom data
type detaches all attached data formats, no need to detach them
explicitly. You still need unregister them. Unregistering a custom
data format detaches it from all attached data types.</div>
<div class="epy_par">
<strong class="epy_sig">detach_custom_data_format(dtid, dfid) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">dtid</strong>: data type id to detach data format from (C++: int)</div>
<div class="epy_nested">
<strong class="epy_parameter">dfid</strong>: data format id to detach (C++: int)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: true - ok</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: false - no such
dtid , or no such
dfid , or the data format<div class="epy_nested">
was not attached to the data type</div>
</div>
</div></div>
</dd>
<dt id="ida_bytes.disable_flags"><code class="name flex">
<span>def <span class="ident">disable_flags</span></span>(<span>*args) &#8209;&gt;&#160;error_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Deallocate flags for address range. Exit with an error message if not
enough disk space (this may occur too).</div>
<div class="epy_par">
<strong class="epy_sig">disable_flags(start_ea, end_ea) -&gt; error_t</strong><div class="epy_nested">
<strong class="epy_parameter">start_ea</strong>: should be lower than end_ea. (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">end_ea</strong>: does not belong to the range. (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: 0 if ok, otherwise return error code</div>
</div></div>
</dd>
<dt id="ida_bytes.double_flag"><code class="name flex">
<span>def <span class="ident">double_flag</span></span>(<span>*args) &#8209;&gt;&#160;flags_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get a flags_t representing a double.</div></div>
</dd>
<dt id="ida_bytes.dword_flag"><code class="name flex">
<span>def <span class="ident">dword_flag</span></span>(<span>*args) &#8209;&gt;&#160;flags_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get a flags_t representing a double word.</div></div>
</dd>
<dt id="ida_bytes.enable_flags"><code class="name flex">
<span>def <span class="ident">enable_flags</span></span>(<span>*args) &#8209;&gt;&#160;error_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Allocate flags for address range. This function does not change the
storage type of existing ranges. Exit with an error message if not
enough disk space.</div>
<div class="epy_par">
<strong class="epy_sig">enable_flags(start_ea, end_ea, stt) -&gt; error_t</strong><div class="epy_nested">
<strong class="epy_parameter">start_ea</strong>: should be lower than end_ea. (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">end_ea</strong>: does not belong to the range. (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">stt</strong>: storage_type_t (C++: storage_type_t)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: 0 if ok, otherwise an error code</div>
</div></div>
</dd>
<dt id="ida_bytes.enum_flag"><code class="name flex">
<span>def <span class="ident">enum_flag</span></span>(<span>*args) &#8209;&gt;&#160;flags_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
see 'Bits: instruction operand types'</div></div>
</dd>
<dt id="ida_bytes.equal_bytes"><code class="name flex">
<span>def <span class="ident">equal_bytes</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Compare 'len' bytes of the program starting from 'ea' with 'image'.</div>
<div class="epy_par">
<strong class="epy_sig">equal_bytes(ea, image, mask, len, sense_case) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong>: linear address (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">image</strong>: bytes to compare with (C++: const
uchar
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">mask</strong>: array of 1/0 bytes, it's length is 'len'. 1 means to<div class="epy_nested">
perform the comparison of the corresponding byte. 0 means
not to perform. if mask == nullptr, then all bytes of
'image' will be compared. if mask ==
SKIP_FF_MASK
then
0xFF bytes will be skipped (C++: const
uchar
*)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">len</strong>: length of block to compare in bytes. (C++: size_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">sense_case</strong>: case-sensitive comparison? (C++: bool)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 - equal</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - not equal</div>
</div></div>
</dd>
<dt id="ida_bytes.f_has_cmt"><code class="name flex">
<span>def <span class="ident">f_has_cmt</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">f_has_cmt(f, arg2) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">f</strong> (C++: flags_t)
arg2: void *</div>
</div></div>
</dd>
<dt id="ida_bytes.f_has_dummy_name"><code class="name flex">
<span>def <span class="ident">f_has_dummy_name</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Does the current byte have dummy (auto-generated, with special prefix)
name?</div>
<div class="epy_par">
<strong class="epy_sig">f_has_dummy_name(f, arg2) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">f</strong> (C++: flags_t)
arg2: void *</div>
</div></div>
</dd>
<dt id="ida_bytes.f_has_extra_cmts"><code class="name flex">
<span>def <span class="ident">f_has_extra_cmts</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">f_has_extra_cmts(f, arg2) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">f</strong> (C++: flags_t)
arg2: void *</div>
</div></div>
</dd>
<dt id="ida_bytes.f_has_name"><code class="name flex">
<span>def <span class="ident">f_has_name</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Does the current byte have non-trivial (non-dummy) name?</div>
<div class="epy_par">
<strong class="epy_sig">f_has_name(f, arg2) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">f</strong> (C++: flags_t)
arg2: void *</div>
</div></div>
</dd>
<dt id="ida_bytes.f_has_user_name"><code class="name flex">
<span>def <span class="ident">f_has_user_name</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Does the current byte have user-specified name?</div>
<div class="epy_par">
<strong class="epy_sig">f_has_user_name(F, arg2) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)
arg2: void *</div>
</div></div>
</dd>
<dt id="ida_bytes.f_has_xref"><code class="name flex">
<span>def <span class="ident">f_has_xref</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Does the current byte have cross-references to it?</div>
<div class="epy_par">
<strong class="epy_sig">f_has_xref(f, arg2) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">f</strong> (C++: flags_t)
arg2: void *</div>
</div></div>
</dd>
<dt id="ida_bytes.f_is_align"><code class="name flex">
<span>def <span class="ident">f_is_align</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
See 'is_align()'</div>
<div class="epy_par">
<strong class="epy_sig">f_is_align(F, arg2) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)
arg2: void *</div>
</div></div>
</dd>
<dt id="ida_bytes.f_is_byte"><code class="name flex">
<span>def <span class="ident">f_is_byte</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
See 'is_byte()'</div>
<div class="epy_par">
<strong class="epy_sig">f_is_byte(F, arg2) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)
arg2: void *</div>
</div></div>
</dd>
<dt id="ida_bytes.f_is_code"><code class="name flex">
<span>def <span class="ident">f_is_code</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Does flag denote start of an instruction?</div>
<div class="epy_par">
<strong class="epy_sig">f_is_code(F, arg2) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)
arg2: void *</div>
</div></div>
</dd>
<dt id="ida_bytes.f_is_custom"><code class="name flex">
<span>def <span class="ident">f_is_custom</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
See 'is_custom()'</div>
<div class="epy_par">
<strong class="epy_sig">f_is_custom(F, arg2) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)
arg2: void *</div>
</div></div>
</dd>
<dt id="ida_bytes.f_is_data"><code class="name flex">
<span>def <span class="ident">f_is_data</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Does flag denote start of data?</div>
<div class="epy_par">
<strong class="epy_sig">f_is_data(F, arg2) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)
arg2: void *</div>
</div></div>
</dd>
<dt id="ida_bytes.f_is_double"><code class="name flex">
<span>def <span class="ident">f_is_double</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
See 'is_double()'</div>
<div class="epy_par">
<strong class="epy_sig">f_is_double(F, arg2) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)
arg2: void *</div>
</div></div>
</dd>
<dt id="ida_bytes.f_is_dword"><code class="name flex">
<span>def <span class="ident">f_is_dword</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
See 'is_dword()'</div>
<div class="epy_par">
<strong class="epy_sig">f_is_dword(F, arg2) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)
arg2: void *</div>
</div></div>
</dd>
<dt id="ida_bytes.f_is_float"><code class="name flex">
<span>def <span class="ident">f_is_float</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
See 'is_float()'</div>
<div class="epy_par">
<strong class="epy_sig">f_is_float(F, arg2) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)
arg2: void *</div>
</div></div>
</dd>
<dt id="ida_bytes.f_is_head"><code class="name flex">
<span>def <span class="ident">f_is_head</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Does flag denote start of instruction OR data?</div>
<div class="epy_par">
<strong class="epy_sig">f_is_head(F, arg2) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)
arg2: void *</div>
</div></div>
</dd>
<dt id="ida_bytes.f_is_not_tail"><code class="name flex">
<span>def <span class="ident">f_is_not_tail</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Does flag denote tail byte?</div>
<div class="epy_par">
<strong class="epy_sig">f_is_not_tail(F, arg2) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)
arg2: void *</div>
</div></div>
</dd>
<dt id="ida_bytes.f_is_oword"><code class="name flex">
<span>def <span class="ident">f_is_oword</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
See 'is_oword()'</div>
<div class="epy_par">
<strong class="epy_sig">f_is_oword(F, arg2) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)
arg2: void *</div>
</div></div>
</dd>
<dt id="ida_bytes.f_is_pack_real"><code class="name flex">
<span>def <span class="ident">f_is_pack_real</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
See 'is_pack_real()'</div>
<div class="epy_par">
<strong class="epy_sig">f_is_pack_real(F, arg2) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)
arg2: void *</div>
</div></div>
</dd>
<dt id="ida_bytes.f_is_qword"><code class="name flex">
<span>def <span class="ident">f_is_qword</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
See 'is_qword()'</div>
<div class="epy_par">
<strong class="epy_sig">f_is_qword(F, arg2) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)
arg2: void *</div>
</div></div>
</dd>
<dt id="ida_bytes.f_is_strlit"><code class="name flex">
<span>def <span class="ident">f_is_strlit</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
See 'is_strlit()'</div>
<div class="epy_par">
<strong class="epy_sig">f_is_strlit(F, arg2) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)
arg2: void *</div>
</div></div>
</dd>
<dt id="ida_bytes.f_is_struct"><code class="name flex">
<span>def <span class="ident">f_is_struct</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
See 'is_struct()'</div>
<div class="epy_par">
<strong class="epy_sig">f_is_struct(F, arg2) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)
arg2: void *</div>
</div></div>
</dd>
<dt id="ida_bytes.f_is_tail"><code class="name flex">
<span>def <span class="ident">f_is_tail</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Does flag denote tail byte?</div>
<div class="epy_par">
<strong class="epy_sig">f_is_tail(F, arg2) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)
arg2: void *</div>
</div></div>
</dd>
<dt id="ida_bytes.f_is_tbyte"><code class="name flex">
<span>def <span class="ident">f_is_tbyte</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
See 'is_tbyte()'</div>
<div class="epy_par">
<strong class="epy_sig">f_is_tbyte(F, arg2) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)
arg2: void *</div>
</div></div>
</dd>
<dt id="ida_bytes.f_is_word"><code class="name flex">
<span>def <span class="ident">f_is_word</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
See 'is_word()'</div>
<div class="epy_par">
<strong class="epy_sig">f_is_word(F, arg2) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)
arg2: void *</div>
</div></div>
</dd>
<dt id="ida_bytes.f_is_yword"><code class="name flex">
<span>def <span class="ident">f_is_yword</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
See 'is_yword()'</div>
<div class="epy_par">
<strong class="epy_sig">f_is_yword(F, arg2) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)
arg2: void *</div>
</div></div>
</dd>
<dt id="ida_bytes.find_byte"><code class="name flex">
<span>def <span class="ident">find_byte</span></span>(<span>*args) &#8209;&gt;&#160;ea_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Find forward a byte with the specified value (only 8-bit value from
the database). example: ea=4 size=3 will inspect addresses 4, 5, and 6</div>
<div class="epy_par">
<strong class="epy_sig">find_byte(sEA, size, value, bin_search_flags) -&gt; ea_t</strong><div class="epy_nested">
<strong class="epy_parameter">sEA</strong>: linear address (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">size</strong>: number of bytes to inspect (C++: asize_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">value</strong>: value to find (C++: uchar)</div>
<div class="epy_nested">
<strong class="epy_parameter">bin_search_flags</strong>: combination of
Search flags (C++: int)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: address of byte or
BADADDR</div>
</div></div>
</dd>
<dt id="ida_bytes.find_byter"><code class="name flex">
<span>def <span class="ident">find_byter</span></span>(<span>*args) &#8209;&gt;&#160;ea_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Find reverse a byte with the specified value (only 8-bit value from
the database). example: ea=4 size=3 will inspect addresses 6, 5, and 4</div>
<div class="epy_par">
<strong class="epy_sig">find_byter(sEA, size, value, bin_search_flags) -&gt; ea_t</strong><div class="epy_nested">
<strong class="epy_parameter">sEA</strong>: the lower address of the search range (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">size</strong>: number of bytes to inspect (C++: asize_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">value</strong>: value to find (C++: uchar)</div>
<div class="epy_nested">
<strong class="epy_parameter">bin_search_flags</strong>: combination of
Search flags (C++: int)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: address of byte or
BADADDR</div>
</div></div>
</dd>
<dt id="ida_bytes.find_custom_data_format"><code class="name flex">
<span>def <span class="ident">find_custom_data_format</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get id of a custom data format.</div>
<div class="epy_par">
<strong class="epy_sig">find_custom_data_format(name) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">name</strong>: name of the custom data format (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: id or -1</div>
</div></div>
</dd>
<dt id="ida_bytes.find_custom_data_type"><code class="name flex">
<span>def <span class="ident">find_custom_data_type</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get id of a custom data type.</div>
<div class="epy_par">
<strong class="epy_sig">find_custom_data_type(name) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">name</strong>: name of the custom data type (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: id or -1</div>
</div></div>
</dd>
<dt id="ida_bytes.float_flag"><code class="name flex">
<span>def <span class="ident">float_flag</span></span>(<span>*args) &#8209;&gt;&#160;flags_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get a flags_t representing a float.</div></div>
</dd>
<dt id="ida_bytes.flt_flag"><code class="name flex">
<span>def <span class="ident">flt_flag</span></span>(<span>*args) &#8209;&gt;&#160;flags_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
see 'Bits: instruction operand types'</div></div>
</dd>
<dt id="ida_bytes.free_chunk"><code class="name flex">
<span>def <span class="ident">free_chunk</span></span>(<span>*args) &#8209;&gt;&#160;ea_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Search for a hole in the addressing space of the program.</div>
<div class="epy_par">
<strong class="epy_sig">free_chunk(bottom, size, step) -&gt; ea_t</strong><div class="epy_nested">
<strong class="epy_parameter">bottom</strong>: address to start searching (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">size</strong>: size of desired block (C++: asize_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">step</strong>: bit mask for the start of hole (0xF would align hole to a<div class="epy_nested">
paragraph). if 'step' is negative, the bottom address
with be aligned. otherwise the kernel will try to use it
as is and align it only when the hole is too small. (C++:
int32)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: start of the hole or
BADADDR</div>
</div></div>
</dd>
<dt id="ida_bytes.get_16bit"><code class="name flex">
<span>def <span class="ident">get_16bit</span></span>(<span>*args) &#8209;&gt;&#160;uint32</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get 16bits of the program at 'ea'.</div>
<div class="epy_par">
<strong class="epy_sig">get_16bit(ea) -&gt; uint32</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: 1 byte (getFullByte()) if the current processor has 16-bit<div class="epy_nested">
byte, otherwise return
get_word()</div>
</div>
</div></div>
</dd>
<dt id="ida_bytes.get_32bit"><code class="name flex">
<span>def <span class="ident">get_32bit</span></span>(<span>*args) &#8209;&gt;&#160;uint32</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get not more than 32bits of the program at 'ea'.</div>
<div class="epy_par">
<strong class="epy_sig">get_32bit(ea) -&gt; uint32</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: 32 bit value, depending on \ph{nbits}
:
if ( nbits &lt;= 8 )<div class="epy_nested">
return get_dword(ea);
if ( nbits &lt;= 16) return
get_wide_word(ea);
return get_wide_byte(ea);</div>
</div>
</div></div>
</dd>
<dt id="ida_bytes.get_64bit"><code class="name flex">
<span>def <span class="ident">get_64bit</span></span>(<span>*args) &#8209;&gt;&#160;uint64</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get not more than 64bits of the program at 'ea'.</div>
<div class="epy_par">
<strong class="epy_sig">get_64bit(ea) -&gt; uint64</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: 64 bit value, depending on \ph{nbits}
:
if ( nbits &lt;= 8 )<div class="epy_nested">
return get_qword(ea);
if ( nbits &lt;= 16) return
get_wide_dword(ea);
return get_wide_byte(ea);</div>
</div>
</div></div>
</dd>
<dt id="ida_bytes.get_8bit"><code class="name flex">
<span>def <span class="ident">get_8bit</span></span>(<span>*args) &#8209;&gt;&#160;PyObject&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">get_8bit(ea, v, nbit) -&gt; PyObject *</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">v</strong> (C++: uint32
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">nbit</strong> (C++: int *)</div>
</div></div>
</dd>
<dt id="ida_bytes.get_byte"><code class="name flex">
<span>def <span class="ident">get_byte</span></span>(<span>*args) &#8209;&gt;&#160;uchar</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get one byte (8-bit) of the program at 'ea'. This function works only
for 8bit byte processors.</div>
<div class="epy_par">
<strong class="epy_sig">get_byte(ea) -&gt; uchar</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.get_bytes"><code class="name flex">
<span>def <span class="ident">get_bytes</span></span>(<span>*args) &#8209;&gt;&#160;PyObject&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">get_bytes(ea, size, gmb_flags=0x01) -&gt; PyObject *</strong><div class="epy_nested">
Get the specified number of bytes of the program.</div>
<div class="epy_nested">
<strong class="epy_parameter">ea</strong>: program address</div>
<div class="epy_nested">
<strong class="epy_parameter">size</strong>: number of bytes to return</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: the bytes (as a str), or None in case of failure</div>
</div></div>
</dd>
<dt id="ida_bytes.get_bytes_and_mask"><code class="name flex">
<span>def <span class="ident">get_bytes_and_mask</span></span>(<span>*args) &#8209;&gt;&#160;PyObject&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">get_bytes_and_mask(ea, size, gmb_flags=0x01) -&gt; PyObject *</strong><div class="epy_nested">
Get the specified number of bytes of the program, and a bitmask
specifying what bytes are defined and what bytes are not.</div>
<div class="epy_nested">
<strong class="epy_parameter">ea</strong>: program address</div>
<div class="epy_nested">
<strong class="epy_parameter">size</strong>: number of bytes to return</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: a tuple (bytes, mask), or None in case of failure.<div class="epy_nested">
Both 'bytes' and 'mask' are 'str' instances.</div>
</div>
</div></div>
</dd>
<dt id="ida_bytes.get_cmt"><code class="name flex">
<span>def <span class="ident">get_cmt</span></span>(<span>*args) &#8209;&gt;&#160;qstring&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get an indented comment.</div>
<div class="epy_par">
<strong class="epy_sig">get_cmt(ea, rptble) -&gt; str</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong>: linear address. may point to tail byte, the function will<div class="epy_nested">
find start of the item (C++: ea_t)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">rptble</strong>: get repeatable comment? (C++: bool)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: size of comment or -1</div>
</div></div>
</dd>
<dt id="ida_bytes.get_custom_data_format"><code class="name flex">
<span>def <span class="ident">get_custom_data_format</span></span>(<span>*args) &#8209;&gt;&#160;<a title="ida_bytes.data_format_t" href="#ida_bytes.data_format_t">data_format_t</a>&#160;const&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get definition of a registered custom data format.</div>
<div class="epy_par">
<strong class="epy_sig">get_custom_data_format(dfid) -&gt; data_format_t</strong><div class="epy_nested">
<strong class="epy_parameter">dfid</strong>: data format id (C++: int)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: data format definition or nullptr</div>
</div></div>
</dd>
<dt id="ida_bytes.get_custom_data_formats"><code class="name flex">
<span>def <span class="ident">get_custom_data_formats</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get list of attached custom data formats for the specified data type.</div>
<div class="epy_par">
<strong class="epy_sig">get_custom_data_formats(out, dtid) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">out</strong>: buffer for the output. may be nullptr (C++: intvec_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">dtid</strong>: data type id (C++: int)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: number of returned custom data formats. if error, returns -1</div>
</div></div>
</dd>
<dt id="ida_bytes.get_custom_data_type"><code class="name flex">
<span>def <span class="ident">get_custom_data_type</span></span>(<span>*args) &#8209;&gt;&#160;<a title="ida_bytes.data_type_t" href="#ida_bytes.data_type_t">data_type_t</a>&#160;const&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get definition of a registered custom data type.</div>
<div class="epy_par">
<strong class="epy_sig">get_custom_data_type(dtid) -&gt; data_type_t</strong><div class="epy_nested">
<strong class="epy_parameter">dtid</strong>: data type id (C++: int)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: data type definition or nullptr</div>
</div></div>
</dd>
<dt id="ida_bytes.get_custom_data_types"><code class="name flex">
<span>def <span class="ident">get_custom_data_types</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get list of registered custom data type ids.</div>
<div class="epy_par">
<strong class="epy_sig">get_custom_data_types(out, min_size=0, max_size=BADADDR) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">out</strong>: buffer for the output. may be nullptr (C++: intvec_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">min_size</strong>: minimum value size (C++: asize_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">max_size</strong>: maximum value size (C++: asize_t)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: number of custom data types with the specified size limits</div>
</div></div>
</dd>
<dt id="ida_bytes.get_data_elsize"><code class="name flex">
<span>def <span class="ident">get_data_elsize</span></span>(<span>*args) &#8209;&gt;&#160;asize_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get size of data type specified in flags 'F'.</div>
<div class="epy_par">
<strong class="epy_sig">get_data_elsize(ea, F, ti=None) -&gt; asize_t</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong>: linear address of the item (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">F</strong>: flags (C++: flags_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">ti</strong>: additional information about the data type. For example, if<div class="epy_nested">
the current item is a structure instance, then ti-&gt;tid is
structure id. Otherwise is ignored (may be nullptr). If
specified as nullptr, will be automatically retrieved from
the database (C++: const
opinfo_t
*)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: byte : 1
word : 2
etc...</div>
</div></div>
</dd>
<dt id="ida_bytes.get_data_value"><code class="name flex">
<span>def <span class="ident">get_data_value</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get the value at of the item at 'ea'. This function works with
entities up to sizeof(ea_t) (bytes, word, etc)</div>
<div class="epy_par">
<strong class="epy_sig">get_data_value(v, ea, size) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">v</strong>: pointer to the result. may be nullptr (C++: uval_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">ea</strong>: linear address (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">size</strong>: size of data to read. If 0, then the item type at 'ea'<div class="epy_nested">
will be used (C++: asize_t)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: success</div>
</div></div>
</dd>
<dt id="ida_bytes.get_db_byte"><code class="name flex">
<span>def <span class="ident">get_db_byte</span></span>(<span>*args) &#8209;&gt;&#160;uchar</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get one byte (8-bit) of the program at 'ea' from the database. Works
even if the debugger is active. See also 'get_dbg_byte()' to read the
process memory directly. This function works only for 8bit byte
processors.</div>
<div class="epy_par">
<strong class="epy_sig">get_db_byte(ea) -&gt; uchar</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.get_default_radix"><code class="name flex">
<span>def <span class="ident">get_default_radix</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get default base of number for the current processor.</div></div>
</dd>
<dt id="ida_bytes.get_dword"><code class="name flex">
<span>def <span class="ident">get_dword</span></span>(<span>*args) &#8209;&gt;&#160;uint32</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get one dword (32-bit) of the program at 'ea'. This function takes
into account order of bytes specified in \inf{is_be()}
This function
works only for 8bit byte processors.</div>
<div class="epy_par">
<strong class="epy_sig">get_dword(ea) -&gt; uint32</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.get_enum_id"><code class="name flex">
<span>def <span class="ident">get_enum_id</span></span>(<span>*args) &#8209;&gt;&#160;uchar&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get enum id of 'enum' operand.</div>
<div class="epy_par">
<strong class="epy_sig">get_enum_id(ea, n) -&gt; enum_t</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong>: linear address (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">n</strong>: number of operand (0, 1, -1) (C++: int)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: id of enum or
BADNODE</div>
</div></div>
</dd>
<dt id="ida_bytes.get_first_hidden_range"><code class="name flex">
<span>def <span class="ident">get_first_hidden_range</span></span>(<span>*args) &#8209;&gt;&#160;<a title="ida_bytes.hidden_range_t" href="#ida_bytes.hidden_range_t">hidden_range_t</a>&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get pointer to the first hidden range.</div></div>
</dd>
<dt id="ida_bytes.get_flags"><code class="name flex">
<span>def <span class="ident">get_flags</span></span>(<span>*args) &#8209;&gt;&#160;flags_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
get flags with 'FF_IVL' &amp; 'MS_VAL' . It is much slower under remote
debugging because the kernel needs to read the process memory.</div>
<div class="epy_par">
<strong class="epy_sig">get_flags(ea) -&gt; flags_t</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.get_flags_by_size"><code class="name flex">
<span>def <span class="ident">get_flags_by_size</span></span>(<span>*args) &#8209;&gt;&#160;flags_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get flags from size (in bytes). Supported sizes: 1, 2, 4, 8, 16, 32.
For other sizes returns 0</div>
<div class="epy_par">
<strong class="epy_sig">get_flags_by_size(size) -&gt; flags_t</strong><div class="epy_nested">
<strong class="epy_parameter">size</strong> (C++: size_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.get_flags_ex"><code class="name flex">
<span>def <span class="ident">get_flags_ex</span></span>(<span>*args) &#8209;&gt;&#160;flags_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get flags for the specified address, extended form.</div>
<div class="epy_par">
<strong class="epy_sig">get_flags_ex(ea, how) -&gt; flags_t</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">how</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_bytes.get_forced_operand"><code class="name flex">
<span>def <span class="ident">get_forced_operand</span></span>(<span>*args) &#8209;&gt;&#160;qstring&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get forced operand.</div>
<div class="epy_par">
<strong class="epy_sig">get_forced_operand(ea, n) -&gt; str</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong>: linear address (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">n</strong>: number of operand (0, 1, 2) (C++: int)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: size of forced operand or -1</div>
</div></div>
</dd>
<dt id="ida_bytes.get_full_data_elsize"><code class="name flex">
<span>def <span class="ident">get_full_data_elsize</span></span>(<span>*args) &#8209;&gt;&#160;asize_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get full size of data type specified in flags 'F'. takes into account
processors with wide bytes e.g. returns 2 for a byte element with
16-bit bytes</div>
<div class="epy_par">
<strong class="epy_sig">get_full_data_elsize(ea, F, ti=None) -&gt; asize_t</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">ti</strong> (C++: const
opinfo_t
*)</div>
</div></div>
</dd>
<dt id="ida_bytes.get_full_flags"><code class="name flex">
<span>def <span class="ident">get_full_flags</span></span>(<span>*args) &#8209;&gt;&#160;flags_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get flags value for address 'ea'.</div>
<div class="epy_par">
<strong class="epy_sig">get_full_flags(ea) -&gt; flags_t</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: 0 if address is not present in the program</div>
</div></div>
</dd>
<dt id="ida_bytes.get_hidden_range"><code class="name flex">
<span>def <span class="ident">get_hidden_range</span></span>(<span>*args) &#8209;&gt;&#160;<a title="ida_bytes.hidden_range_t" href="#ida_bytes.hidden_range_t">hidden_range_t</a>&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get pointer to hidden range structure, in: linear address.</div>
<div class="epy_par">
<strong class="epy_sig">get_hidden_range(ea) -&gt; hidden_range_t</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong>: any address in the hidden range (C++: ea_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.get_hidden_range_num"><code class="name flex">
<span>def <span class="ident">get_hidden_range_num</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get number of a hidden range.</div>
<div class="epy_par">
<strong class="epy_sig">get_hidden_range_num(ea) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong>: any address in the hidden range (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: number of hidden range (0.. get_hidden_range_qty() -1)</div>
</div></div>
</dd>
<dt id="ida_bytes.get_hidden_range_qty"><code class="name flex">
<span>def <span class="ident">get_hidden_range_qty</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get number of hidden ranges.</div></div>
</dd>
<dt id="ida_bytes.get_item_end"><code class="name flex">
<span>def <span class="ident">get_item_end</span></span>(<span>*args) &#8209;&gt;&#160;ea_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get the end address of the item at 'ea'. The returned address doesn't
belong to the current item. Unexplored bytes are counted as 1 byte
entities.</div>
<div class="epy_par">
<strong class="epy_sig">get_item_end(ea) -&gt; ea_t</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.get_item_flag"><code class="name flex">
<span>def <span class="ident">get_item_flag</span></span>(<span>*args) &#8209;&gt;&#160;flags_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get flag of the item at 'ea' even if it is a tail byte of some array
or structure. This function is used to get flags of structure members
or array elements.</div>
<div class="epy_par">
<strong class="epy_sig">get_item_flag(_from, n, ea, appzero) -&gt; flags_t</strong><div class="epy_nested">
<strong class="epy_parameter">_from</strong>: linear address of the instruction which refers to 'ea'<div class="epy_nested">
(C++: ea_t)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">n</strong>: number of operand which refers to 'ea' (C++: int)</div>
<div class="epy_nested">
<strong class="epy_parameter">ea</strong>: the referenced address (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">appzero</strong>: append a struct field name if the field offset is<div class="epy_nested">
zero? meaningful only if the name refers to a
structure. (C++: bool)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: flags or 0 (if failed)</div>
</div></div>
</dd>
<dt id="ida_bytes.get_item_head"><code class="name flex">
<span>def <span class="ident">get_item_head</span></span>(<span>*args) &#8209;&gt;&#160;ea_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get the start address of the item at 'ea'. If there is no current
item, then 'ea' will be returned (see definition at the end of
'bytes.hpp' source)</div>
<div class="epy_par">
<strong class="epy_sig">get_item_head(ea) -&gt; ea_t</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.get_item_size"><code class="name flex">
<span>def <span class="ident">get_item_size</span></span>(<span>*args) &#8209;&gt;&#160;asize_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get size of item (instruction/data) in bytes. Unexplored bytes have
length of 1 byte. This function never returns 0.</div>
<div class="epy_par">
<strong class="epy_sig">get_item_size(ea) -&gt; asize_t</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.get_last_hidden_range"><code class="name flex">
<span>def <span class="ident">get_last_hidden_range</span></span>(<span>*args) &#8209;&gt;&#160;<a title="ida_bytes.hidden_range_t" href="#ida_bytes.hidden_range_t">hidden_range_t</a>&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get pointer to the last hidden range.</div></div>
</dd>
<dt id="ida_bytes.get_manual_insn"><code class="name flex">
<span>def <span class="ident">get_manual_insn</span></span>(<span>*args) &#8209;&gt;&#160;qstring&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Retrieve the user-specified string for the manual instruction.</div>
<div class="epy_par">
<strong class="epy_sig">get_manual_insn(ea) -&gt; str</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong>: linear address of the instruction or data item (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: size of manual instruction or -1</div>
</div></div>
</dd>
<dt id="ida_bytes.get_mapping"><code class="name flex">
<span>def <span class="ident">get_mapping</span></span>(<span>*args) &#8209;&gt;&#160;ea_t&#160;*,&#160;ea_t&#160;*,&#160;asize_t&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get memory mapping range by its number.</div>
<div class="epy_par">
<strong class="epy_sig">get_mapping(n) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">n</strong>: number of mapping range (0.. get_mappings_qty() -1) (C++:<div class="epy_nested">
size_t)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: false if the specified range doesn't exist, otherwise returns<div class="epy_nested">
from ,
to ,
size</div>
</div>
</div></div>
</dd>
<dt id="ida_bytes.get_mappings_qty"><code class="name flex">
<span>def <span class="ident">get_mappings_qty</span></span>(<span>*args) &#8209;&gt;&#160;size_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get number of mappings.</div></div>
</dd>
<dt id="ida_bytes.get_max_strlit_length"><code class="name flex">
<span>def <span class="ident">get_max_strlit_length</span></span>(<span>*args) &#8209;&gt;&#160;size_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Determine maximum length of string literal.If the string literal has a
length prefix (e.g., STRTYPE_LEN2 has a two-byte length prefix), the
length of that prefix (i.e., 2) will be part of the returned value.</div>
<div class="epy_par">
<strong class="epy_sig">get_max_strlit_length(ea, strtype, options=0) -&gt; size_t</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong>: starting address (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">strtype</strong>: string type. one of
String type codes (C++: int32)</div>
<div class="epy_nested">
<strong class="epy_parameter">options</strong>: combination of
string literal length options (C++:<div class="epy_nested">
int)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: length of the string in octets (octet==8bit)</div>
</div></div>
</dd>
<dt id="ida_bytes.get_next_hidden_range"><code class="name flex">
<span>def <span class="ident">get_next_hidden_range</span></span>(<span>*args) &#8209;&gt;&#160;<a title="ida_bytes.hidden_range_t" href="#ida_bytes.hidden_range_t">hidden_range_t</a>&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get pointer to next hidden range.</div>
<div class="epy_par">
<strong class="epy_sig">get_next_hidden_range(ea) -&gt; hidden_range_t</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong>: any address in the program (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: ptr to hidden range or nullptr if next hidden range doesn't<div class="epy_nested">
exist</div>
</div>
</div></div>
</dd>
<dt id="ida_bytes.get_octet"><code class="name flex">
<span>def <span class="ident">get_octet</span></span>(<span>*args) &#8209;&gt;&#160;PyObject&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get 8 bits of the program at 'ea'. The main usage of this function is
to iterate range of bytes. Here is an example:</div>
<div class="epy_par">
uint64 v;
int nbit = 0;
for ( ... ) {<div class="epy_nested">
uchar byte = get_octet(&amp;ea, &amp;v, &amp;nbit);
...</div>
</div>
<div class="epy_par">
}</div>
<div class="epy_par">
'ea' is incremented each time when a new byte is read. In the above
example, it will be incremented in the first loop iteration.</div>
<div class="epy_par">
<strong class="epy_sig">get_octet(ea, v, nbit) -&gt; PyObject *</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">v</strong> (C++: uint64
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">nbit</strong> (C++: int *)</div>
</div></div>
</dd>
<dt id="ida_bytes.get_opinfo"><code class="name flex">
<span>def <span class="ident">get_opinfo</span></span>(<span>*args) &#8209;&gt;&#160;opinfo_t&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get additional information about an operand representation.</div>
<div class="epy_par">
<strong class="epy_sig">get_opinfo(buf, ea, n, flags) -&gt; opinfo_t</strong><div class="epy_nested">
<strong class="epy_parameter">buf</strong>: buffer to receive the result. may not be nullptr (C++:<div class="epy_nested">
opinfo_t
*)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">ea</strong>: linear address of item (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">n</strong>: number of operand, 0 or 1 (C++: int)</div>
<div class="epy_nested">
<strong class="epy_parameter">flags</strong>: flags of the item (C++: flags_t)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: nullptr if no additional representation information</div>
</div></div>
</dd>
<dt id="ida_bytes.get_optype_flags0"><code class="name flex">
<span>def <span class="ident">get_optype_flags0</span></span>(<span>*args) &#8209;&gt;&#160;flags_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get flags for first operand.</div>
<div class="epy_par">
<strong class="epy_sig">get_optype_flags0(F) -&gt; flags_t</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.get_optype_flags1"><code class="name flex">
<span>def <span class="ident">get_optype_flags1</span></span>(<span>*args) &#8209;&gt;&#160;flags_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get flags for second operand.</div>
<div class="epy_par">
<strong class="epy_sig">get_optype_flags1(F) -&gt; flags_t</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.get_original_byte"><code class="name flex">
<span>def <span class="ident">get_original_byte</span></span>(<span>*args) &#8209;&gt;&#160;uint64</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get original byte value (that was before patching). This function
works for wide byte processors too.</div>
<div class="epy_par">
<strong class="epy_sig">get_original_byte(ea) -&gt; uint64</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.get_original_dword"><code class="name flex">
<span>def <span class="ident">get_original_dword</span></span>(<span>*args) &#8209;&gt;&#160;uint64</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get original dword (that was before patching) This function works for
wide byte processors too. This function takes into account order of
bytes specified in \inf{is_be()}</div>
<div class="epy_par">
<strong class="epy_sig">get_original_dword(ea) -&gt; uint64</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.get_original_qword"><code class="name flex">
<span>def <span class="ident">get_original_qword</span></span>(<span>*args) &#8209;&gt;&#160;uint64</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get original qword value (that was before patching) This function
DOESN'T work for wide byte processors too. This function takes into
account order of bytes specified in \inf{is_be()}</div>
<div class="epy_par">
<strong class="epy_sig">get_original_qword(ea) -&gt; uint64</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.get_original_word"><code class="name flex">
<span>def <span class="ident">get_original_word</span></span>(<span>*args) &#8209;&gt;&#160;uint64</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get original word value (that was before patching). This function
works for wide byte processors too. This function takes into account
order of bytes specified in \inf{is_be()}</div>
<div class="epy_par">
<strong class="epy_sig">get_original_word(ea) -&gt; uint64</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.get_predef_insn_cmt"><code class="name flex">
<span>def <span class="ident">get_predef_insn_cmt</span></span>(<span>*args) &#8209;&gt;&#160;qstring&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get predefined comment.</div>
<div class="epy_par">
<strong class="epy_sig">get_predef_insn_cmt(ins) -&gt; str</strong><div class="epy_nested">
<strong class="epy_parameter">ins</strong>: current instruction information
- an ida_ua.insn_t, or an<div class="epy_nested">
address (C++: const insn_t &amp;)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: size of comment or -1</div>
</div></div>
</dd>
<dt id="ida_bytes.get_prev_hidden_range"><code class="name flex">
<span>def <span class="ident">get_prev_hidden_range</span></span>(<span>*args) &#8209;&gt;&#160;<a title="ida_bytes.hidden_range_t" href="#ida_bytes.hidden_range_t">hidden_range_t</a>&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get pointer to previous hidden range.</div>
<div class="epy_par">
<strong class="epy_sig">get_prev_hidden_range(ea) -&gt; hidden_range_t</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong>: any address in the program (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: ptr to hidden range or nullptr if previous hidden range<div class="epy_nested">
doesn't exist</div>
</div>
</div></div>
</dd>
<dt id="ida_bytes.get_qword"><code class="name flex">
<span>def <span class="ident">get_qword</span></span>(<span>*args) &#8209;&gt;&#160;uint64</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get one qword (64-bit) of the program at 'ea'. This function takes
into account order of bytes specified in \inf{is_be()}
This function
works only for 8bit byte processors.</div>
<div class="epy_par">
<strong class="epy_sig">get_qword(ea) -&gt; uint64</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.get_radix"><code class="name flex">
<span>def <span class="ident">get_radix</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get radix of the operand, in: flags. If the operand is not a number,
returns 'get_default_radix()'</div>
<div class="epy_par">
<strong class="epy_sig">get_radix(F, n) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong>: flags (C++: flags_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">n</strong>: number of operand (0, 1, -1) (C++: int)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: 2, 8, 10, 16</div>
</div></div>
</dd>
<dt id="ida_bytes.get_strlit_contents"><code class="name flex">
<span>def <span class="ident">get_strlit_contents</span></span>(<span>*args) &#8209;&gt;&#160;PyObject&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">get_strlit_contents(ea, py_len, type, flags=0) -&gt; PyObject *</strong><div class="epy_nested">
Get bytes contents at location, possibly converted.
It works even if the string has not been created in the database yet.</div>
<div class="epy_nested">
Note that this will <b>always</b> return a simple string of bytes
(i.e., a 'str' instance), and not a string of unicode characters.</div>
<div class="epy_nested">
If you want auto-conversion to unicode strings (that is: real strings),
you should probably be using the idautils.Strings class.</div>
<div class="epy_nested">
<strong class="epy_parameter">ea</strong>: linear address of the string</div>
<div class="epy_nested">
<strong class="epy_parameter">len</strong>: length of the string in bytes (including terminating 0)</div>
<div class="epy_nested">
<strong class="epy_parameter">type</strong>: type of the string. Represents both the character encoding,<div class="epy_nested">
<u>and</u> the 'type' of string at the given location.</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">flags</strong>: combination of STRCONV_..., to perform output conversion.</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: a bytes-filled str object.</div>
</div></div>
</dd>
<dt id="ida_bytes.get_stroff_path"><code class="name flex">
<span>def <span class="ident">get_stroff_path</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get struct path of operand.</div>
<div class="epy_par">
<strong class="epy_sig">get_stroff_path(path, delta, ea, n) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">path</strong>: buffer for structure path (strpath). see
nalt.hpp
for<div class="epy_nested">
more info. (C++: tid_t
*)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">delta</strong>: struct offset delta (C++: adiff_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">ea</strong>: linear address (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">n</strong>: number of operand (0, 1, -1) (C++: int)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: length of strpath</div>
</div></div>
</dd>
<dt id="ida_bytes.get_wide_byte"><code class="name flex">
<span>def <span class="ident">get_wide_byte</span></span>(<span>*args) &#8209;&gt;&#160;uint64</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get one wide byte of the program at 'ea'. Some processors may access
more than 8bit quantity at an address. These processors have 32-bit
byte organization from the IDA's point of view.</div>
<div class="epy_par">
<strong class="epy_sig">get_wide_byte(ea) -&gt; uint64</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.get_wide_dword"><code class="name flex">
<span>def <span class="ident">get_wide_dword</span></span>(<span>*args) &#8209;&gt;&#160;uint64</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get two wide words (4 'bytes') of the program at 'ea'. Some processors
may access more than 8bit quantity at an address. These processors
have 32-bit byte organization from the IDA's point of view. This
function takes into account order of bytes specified in</div>
<div class="epy_par">
\inf{is_be()}<div class="epy_nested">
this function works incorrectly if \ph{nbits} &gt; 16</div>
</div>
<div class="epy_par">
<strong class="epy_sig">get_wide_dword(ea) -&gt; uint64</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.get_wide_word"><code class="name flex">
<span>def <span class="ident">get_wide_word</span></span>(<span>*args) &#8209;&gt;&#160;uint64</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get one wide word (2 'byte') of the program at 'ea'. Some processors
may access more than 8bit quantity at an address. These processors
have 32-bit byte organization from the IDA's point of view. This
function takes into account order of bytes specified in \inf{is_be()}</div>
<div class="epy_par">
<strong class="epy_sig">get_wide_word(ea) -&gt; uint64</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.get_word"><code class="name flex">
<span>def <span class="ident">get_word</span></span>(<span>*args) &#8209;&gt;&#160;ushort</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get one word (16-bit) of the program at 'ea'. This function takes into
account order of bytes specified in \inf{is_be()}
This function works
only for 8bit byte processors.</div>
<div class="epy_par">
<strong class="epy_sig">get_word(ea) -&gt; ushort</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.get_zero_ranges"><code class="name flex">
<span>def <span class="ident">get_zero_ranges</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Return set of ranges with zero initialized bytes. The returned set
includes only big zero initialized ranges (at least &gt;1KB). Some zero
initialized byte ranges may be not included. Only zero bytes that use
the sparse storage method (STT_MM) are reported.</div>
<div class="epy_par">
<strong class="epy_sig">get_zero_ranges(zranges, range) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">zranges</strong>: pointer to the return value. cannot be nullptr (C++:<div class="epy_nested">
rangeset_t
*)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">range</strong>: the range of addresses to verify. can be nullptr - means<div class="epy_nested">
all ranges (C++: const
range_t
*)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: true if the result is a non-empty set</div>
</div></div>
</dd>
<dt id="ida_bytes.getn_hidden_range"><code class="name flex">
<span>def <span class="ident">getn_hidden_range</span></span>(<span>*args) &#8209;&gt;&#160;<a title="ida_bytes.hidden_range_t" href="#ida_bytes.hidden_range_t">hidden_range_t</a>&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get pointer to hidden range structure, in: number of hidden range.</div>
<div class="epy_par">
<strong class="epy_sig">getn_hidden_range(n) -&gt; hidden_range_t</strong><div class="epy_nested">
<strong class="epy_parameter">n</strong>: number of hidden range, is in range 0..<div class="epy_nested">
get_hidden_range_qty() -1 (C++: int)</div>
</div>
</div></div>
</dd>
<dt id="ida_bytes.has_any_name"><code class="name flex">
<span>def <span class="ident">has_any_name</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Does the current byte have any name?</div>
<div class="epy_par">
<strong class="epy_sig">has_any_name(F) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.has_auto_name"><code class="name flex">
<span>def <span class="ident">has_auto_name</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Does the current byte have auto-generated (no special prefix) name?</div>
<div class="epy_par">
<strong class="epy_sig">has_auto_name(F) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.has_cmt"><code class="name flex">
<span>def <span class="ident">has_cmt</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Does the current byte have an indented comment?</div>
<div class="epy_par">
<strong class="epy_sig">has_cmt(F) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.has_dummy_name"><code class="name flex">
<span>def <span class="ident">has_dummy_name</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Does the current byte have dummy (auto-generated, with special prefix)
name?</div>
<div class="epy_par">
<strong class="epy_sig">has_dummy_name(F) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.has_extra_cmts"><code class="name flex">
<span>def <span class="ident">has_extra_cmts</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Does the current byte have additional anterior or posterior lines?</div>
<div class="epy_par">
<strong class="epy_sig">has_extra_cmts(F) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.has_immd"><code class="name flex">
<span>def <span class="ident">has_immd</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Has immediate value?</div>
<div class="epy_par">
<strong class="epy_sig">has_immd(F) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.has_name"><code class="name flex">
<span>def <span class="ident">has_name</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Does the current byte have non-trivial (non-dummy) name?</div>
<div class="epy_par">
<strong class="epy_sig">has_name(F) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.has_user_name"><code class="name flex">
<span>def <span class="ident">has_user_name</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Does the current byte have user-specified name?</div>
<div class="epy_par">
<strong class="epy_sig">has_user_name(F) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.has_value"><code class="name flex">
<span>def <span class="ident">has_value</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Do flags contain byte value?</div>
<div class="epy_par">
<strong class="epy_sig">has_value(F) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.has_xref"><code class="name flex">
<span>def <span class="ident">has_xref</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Does the current byte have cross-references to it?</div>
<div class="epy_par">
<strong class="epy_sig">has_xref(F) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.hex_flag"><code class="name flex">
<span>def <span class="ident">hex_flag</span></span>(<span>*args) &#8209;&gt;&#160;flags_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get number flag of the base, regardless of current processor - better
to use 'num_flag()'</div></div>
</dd>
<dt id="ida_bytes.is_align"><code class="name flex">
<span>def <span class="ident">is_align</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
'FF_ALIGN'</div>
<div class="epy_par">
<strong class="epy_sig">is_align(F) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.is_attached_custom_data_format"><code class="name flex">
<span>def <span class="ident">is_attached_custom_data_format</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is the custom data format attached to the custom data type?</div>
<div class="epy_par">
<strong class="epy_sig">is_attached_custom_data_format(dtid, dfid) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">dtid</strong>: data type id (C++: int)</div>
<div class="epy_nested">
<strong class="epy_parameter">dfid</strong>: data format id (C++: int)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: true or false</div>
</div></div>
</dd>
<dt id="ida_bytes.is_bnot"><code class="name flex">
<span>def <span class="ident">is_bnot</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Should we negate the operand?. \ash{a_bnot}
should be defined in the
idp module in order to work with this function</div>
<div class="epy_par">
<strong class="epy_sig">is_bnot(ea, F, n) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">n</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_bytes.is_byte"><code class="name flex">
<span>def <span class="ident">is_byte</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
'FF_BYTE'</div>
<div class="epy_par">
<strong class="epy_sig">is_byte(F) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.is_char"><code class="name flex">
<span>def <span class="ident">is_char</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
is character constant?</div>
<div class="epy_par">
<strong class="epy_sig">is_char(F, n) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">n</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_bytes.is_char0"><code class="name flex">
<span>def <span class="ident">is_char0</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is the first operand character constant? (example: push 'a')</div>
<div class="epy_par">
<strong class="epy_sig">is_char0(F) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.is_char1"><code class="name flex">
<span>def <span class="ident">is_char1</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is the second operand character constant? (example: mov al, 'a')</div>
<div class="epy_par">
<strong class="epy_sig">is_char1(F) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.is_code"><code class="name flex">
<span>def <span class="ident">is_code</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Does flag denote start of an instruction?</div>
<div class="epy_par">
<strong class="epy_sig">is_code(F) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.is_custfmt"><code class="name flex">
<span>def <span class="ident">is_custfmt</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
is custom data format?</div>
<div class="epy_par">
<strong class="epy_sig">is_custfmt(F, n) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">n</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_bytes.is_custfmt0"><code class="name flex">
<span>def <span class="ident">is_custfmt0</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Does the first operand use a custom data representation?</div>
<div class="epy_par">
<strong class="epy_sig">is_custfmt0(F) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.is_custfmt1"><code class="name flex">
<span>def <span class="ident">is_custfmt1</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Does the second operand use a custom data representation?</div>
<div class="epy_par">
<strong class="epy_sig">is_custfmt1(F) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.is_custom"><code class="name flex">
<span>def <span class="ident">is_custom</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
'FF_CUSTOM'</div>
<div class="epy_par">
<strong class="epy_sig">is_custom(F) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.is_data"><code class="name flex">
<span>def <span class="ident">is_data</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Does flag denote start of data?</div>
<div class="epy_par">
<strong class="epy_sig">is_data(F) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.is_defarg"><code class="name flex">
<span>def <span class="ident">is_defarg</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
is defined?</div>
<div class="epy_par">
<strong class="epy_sig">is_defarg(F, n) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">n</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_bytes.is_defarg0"><code class="name flex">
<span>def <span class="ident">is_defarg0</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is the first operand defined? Initially operand has no defined
representation.</div>
<div class="epy_par">
<strong class="epy_sig">is_defarg0(F) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.is_defarg1"><code class="name flex">
<span>def <span class="ident">is_defarg1</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is the second operand defined? Initially operand has no defined
representation.</div>
<div class="epy_par">
<strong class="epy_sig">is_defarg1(F) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.is_double"><code class="name flex">
<span>def <span class="ident">is_double</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
'FF_DOUBLE'</div>
<div class="epy_par">
<strong class="epy_sig">is_double(F) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.is_dword"><code class="name flex">
<span>def <span class="ident">is_dword</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
'FF_DWORD'</div>
<div class="epy_par">
<strong class="epy_sig">is_dword(F) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.is_enum"><code class="name flex">
<span>def <span class="ident">is_enum</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
is enum?</div>
<div class="epy_par">
<strong class="epy_sig">is_enum(F, n) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">n</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_bytes.is_enum0"><code class="name flex">
<span>def <span class="ident">is_enum0</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is the first operand a symbolic constant (enum member)?</div>
<div class="epy_par">
<strong class="epy_sig">is_enum0(F) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.is_enum1"><code class="name flex">
<span>def <span class="ident">is_enum1</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is the second operand a symbolic constant (enum member)?</div>
<div class="epy_par">
<strong class="epy_sig">is_enum1(F) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.is_float"><code class="name flex">
<span>def <span class="ident">is_float</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
'FF_FLOAT'</div>
<div class="epy_par">
<strong class="epy_sig">is_float(F) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.is_float0"><code class="name flex">
<span>def <span class="ident">is_float0</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is the first operand a floating point number?</div>
<div class="epy_par">
<strong class="epy_sig">is_float0(F) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.is_float1"><code class="name flex">
<span>def <span class="ident">is_float1</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is the second operand a floating point number?</div>
<div class="epy_par">
<strong class="epy_sig">is_float1(F) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.is_flow"><code class="name flex">
<span>def <span class="ident">is_flow</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Does the previous instruction exist and pass execution flow to the
current byte?</div>
<div class="epy_par">
<strong class="epy_sig">is_flow(F) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.is_fltnum"><code class="name flex">
<span>def <span class="ident">is_fltnum</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
is floating point number?</div>
<div class="epy_par">
<strong class="epy_sig">is_fltnum(F, n) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">n</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_bytes.is_forced_operand"><code class="name flex">
<span>def <span class="ident">is_forced_operand</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is operand manually defined?.</div>
<div class="epy_par">
<strong class="epy_sig">is_forced_operand(ea, n) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong>: linear address (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">n</strong>: number of operand (0, 1, 2) (C++: int)</div>
</div></div>
</dd>
<dt id="ida_bytes.is_func"><code class="name flex">
<span>def <span class="ident">is_func</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is function start?</div>
<div class="epy_par">
<strong class="epy_sig">is_func(F) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.is_head"><code class="name flex">
<span>def <span class="ident">is_head</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Does flag denote start of instruction OR data?</div>
<div class="epy_par">
<strong class="epy_sig">is_head(F) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.is_invsign"><code class="name flex">
<span>def <span class="ident">is_invsign</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Should sign of n-th operand inverted during output?. allowed values of
n: 0-first operand, 1-other operands</div>
<div class="epy_par">
<strong class="epy_sig">is_invsign(ea, F, n) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">n</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_bytes.is_loaded"><code class="name flex">
<span>def <span class="ident">is_loaded</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Does the specified address have a byte value (is initialized?)</div>
<div class="epy_par">
<strong class="epy_sig">is_loaded(ea) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.is_lzero"><code class="name flex">
<span>def <span class="ident">is_lzero</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Display leading zeroes in operands. The global switch for the leading
zeroes is in \inf{s_genflags}
The leading zeroes doesn't work if the
octal numbers start with 0 Display leading zeroes? (takes into account</div>
<div class="epy_par">
\inf{s_genflags}<div class="epy_nested">
)</div>
</div>
<div class="epy_par">
<strong class="epy_sig">is_lzero(ea, n) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">n</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_bytes.is_manual"><code class="name flex">
<span>def <span class="ident">is_manual</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
is forced operand? (use 'is_forced_operand()' )</div>
<div class="epy_par">
<strong class="epy_sig">is_manual(F, n) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">n</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_bytes.is_manual_insn"><code class="name flex">
<span>def <span class="ident">is_manual_insn</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is the instruction overridden?</div>
<div class="epy_par">
<strong class="epy_sig">is_manual_insn(ea) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong>: linear address of the instruction or data item (C++: ea_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.is_mapped"><code class="name flex">
<span>def <span class="ident">is_mapped</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is the specified address 'ea' present in the program?</div>
<div class="epy_par">
<strong class="epy_sig">is_mapped(ea) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.is_not_tail"><code class="name flex">
<span>def <span class="ident">is_not_tail</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Does flag denote tail byte?</div>
<div class="epy_par">
<strong class="epy_sig">is_not_tail(F) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.is_numop"><code class="name flex">
<span>def <span class="ident">is_numop</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
is number (bin, oct, dec, hex)?</div>
<div class="epy_par">
<strong class="epy_sig">is_numop(F, n) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">n</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_bytes.is_numop0"><code class="name flex">
<span>def <span class="ident">is_numop0</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is the first operand a number (i.e. binary, octal, decimal or hex?)</div>
<div class="epy_par">
<strong class="epy_sig">is_numop0(F) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.is_numop1"><code class="name flex">
<span>def <span class="ident">is_numop1</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is the second operand a number (i.e. binary, octal, decimal or hex?)</div>
<div class="epy_par">
<strong class="epy_sig">is_numop1(F) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.is_off"><code class="name flex">
<span>def <span class="ident">is_off</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
is offset?</div>
<div class="epy_par">
<strong class="epy_sig">is_off(F, n) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">n</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_bytes.is_off0"><code class="name flex">
<span>def <span class="ident">is_off0</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is the first operand offset? (example: push offset xxx)</div>
<div class="epy_par">
<strong class="epy_sig">is_off0(F) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.is_off1"><code class="name flex">
<span>def <span class="ident">is_off1</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is the second operand offset? (example: mov ax, offset xxx)</div>
<div class="epy_par">
<strong class="epy_sig">is_off1(F) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.is_oword"><code class="name flex">
<span>def <span class="ident">is_oword</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
'FF_OWORD'</div>
<div class="epy_par">
<strong class="epy_sig">is_oword(F) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.is_pack_real"><code class="name flex">
<span>def <span class="ident">is_pack_real</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
'FF_PACKREAL'</div>
<div class="epy_par">
<strong class="epy_sig">is_pack_real(F) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.is_qword"><code class="name flex">
<span>def <span class="ident">is_qword</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
'FF_QWORD'</div>
<div class="epy_par">
<strong class="epy_sig">is_qword(F) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.is_same_data_type"><code class="name flex">
<span>def <span class="ident">is_same_data_type</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Do the given flags specify the same data type?</div>
<div class="epy_par">
<strong class="epy_sig">is_same_data_type(F1, F2) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F1</strong> (C++: flags_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">F2</strong> (C++: flags_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.is_seg"><code class="name flex">
<span>def <span class="ident">is_seg</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
is segment?</div>
<div class="epy_par">
<strong class="epy_sig">is_seg(F, n) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">n</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_bytes.is_seg0"><code class="name flex">
<span>def <span class="ident">is_seg0</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is the first operand segment selector? (example: push seg seg001)</div>
<div class="epy_par">
<strong class="epy_sig">is_seg0(F) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.is_seg1"><code class="name flex">
<span>def <span class="ident">is_seg1</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is the second operand segment selector? (example: mov dx, seg dseg)</div>
<div class="epy_par">
<strong class="epy_sig">is_seg1(F) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.is_stkvar"><code class="name flex">
<span>def <span class="ident">is_stkvar</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
is stack variable?</div>
<div class="epy_par">
<strong class="epy_sig">is_stkvar(F, n) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">n</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_bytes.is_stkvar0"><code class="name flex">
<span>def <span class="ident">is_stkvar0</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is the first operand a stack variable?</div>
<div class="epy_par">
<strong class="epy_sig">is_stkvar0(F) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.is_stkvar1"><code class="name flex">
<span>def <span class="ident">is_stkvar1</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is the second operand a stack variable?</div>
<div class="epy_par">
<strong class="epy_sig">is_stkvar1(F) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.is_strlit"><code class="name flex">
<span>def <span class="ident">is_strlit</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
'FF_STRLIT'</div>
<div class="epy_par">
<strong class="epy_sig">is_strlit(F) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.is_stroff"><code class="name flex">
<span>def <span class="ident">is_stroff</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
is struct offset?</div>
<div class="epy_par">
<strong class="epy_sig">is_stroff(F, n) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">n</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_bytes.is_stroff0"><code class="name flex">
<span>def <span class="ident">is_stroff0</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is the first operand an offset within a struct?</div>
<div class="epy_par">
<strong class="epy_sig">is_stroff0(F) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.is_stroff1"><code class="name flex">
<span>def <span class="ident">is_stroff1</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is the second operand an offset within a struct?</div>
<div class="epy_par">
<strong class="epy_sig">is_stroff1(F) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.is_struct"><code class="name flex">
<span>def <span class="ident">is_struct</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
'FF_STRUCT'</div>
<div class="epy_par">
<strong class="epy_sig">is_struct(F) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.is_suspop"><code class="name flex">
<span>def <span class="ident">is_suspop</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
is suspicious operand?</div>
<div class="epy_par">
<strong class="epy_sig">is_suspop(ea, F, n) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">n</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_bytes.is_tail"><code class="name flex">
<span>def <span class="ident">is_tail</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Does flag denote tail byte?</div>
<div class="epy_par">
<strong class="epy_sig">is_tail(F) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.is_tbyte"><code class="name flex">
<span>def <span class="ident">is_tbyte</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
'FF_TBYTE'</div>
<div class="epy_par">
<strong class="epy_sig">is_tbyte(F) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.is_unknown"><code class="name flex">
<span>def <span class="ident">is_unknown</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Does flag denote unexplored byte?</div>
<div class="epy_par">
<strong class="epy_sig">is_unknown(F) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.is_varsize_item"><code class="name flex">
<span>def <span class="ident">is_varsize_item</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is the item at 'ea' variable size?.</div>
<div class="epy_par">
<strong class="epy_sig">is_varsize_item(ea, F, ti=None, itemsize=None) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong>: linear address of the item (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">F</strong>: flags (C++: flags_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">ti</strong>: additional information about the data type. For example, if<div class="epy_nested">
the current item is a structure instance, then ti-&gt;tid is
structure id. Otherwise is ignored (may be nullptr). If
specified as nullptr, will be automatically retrieved from
the database (C++: const
opinfo_t
*)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">itemsize</strong>: if not nullptr and the item is varsize, itemsize will<div class="epy_nested">
contain the calculated item size (for struct types,
the minimal size is returned) (C++: asize_t *)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 - varsize item</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - fixed item</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: -1 - error (bad data definition)</div>
</div></div>
</dd>
<dt id="ida_bytes.is_word"><code class="name flex">
<span>def <span class="ident">is_word</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
'FF_WORD'</div>
<div class="epy_par">
<strong class="epy_sig">is_word(F) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.is_yword"><code class="name flex">
<span>def <span class="ident">is_yword</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
'FF_YWORD'</div>
<div class="epy_par">
<strong class="epy_sig">is_yword(F) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.is_zword"><code class="name flex">
<span>def <span class="ident">is_zword</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
'FF_ZWORD'</div>
<div class="epy_par">
<strong class="epy_sig">is_zword(F) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.leading_zero_important"><code class="name flex">
<span>def <span class="ident">leading_zero_important</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Check if leading zeroes are important.</div>
<div class="epy_par">
<strong class="epy_sig">leading_zero_important(ea, n) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">n</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_bytes.nbits"><code class="name flex">
<span>def <span class="ident">nbits</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get number of bits in a byte at the given address.</div>
<div class="epy_par">
<strong class="epy_sig">nbits(ea) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: \ph{dnbits()}
if the address doesn't belong to a segment,<div class="epy_nested">
otherwise the result depends on the segment type</div>
</div>
</div></div>
</dd>
<dt id="ida_bytes.next_addr"><code class="name flex">
<span>def <span class="ident">next_addr</span></span>(<span>*args) &#8209;&gt;&#160;ea_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get next address in the program (i.e. next address which has flags).</div>
<div class="epy_par">
<strong class="epy_sig">next_addr(ea) -&gt; ea_t</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: BADADDR
if no such address exist.</div>
</div></div>
</dd>
<dt id="ida_bytes.next_chunk"><code class="name flex">
<span>def <span class="ident">next_chunk</span></span>(<span>*args) &#8209;&gt;&#160;ea_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get the first address of next contiguous chunk in the program.</div>
<div class="epy_par">
<strong class="epy_sig">next_chunk(ea) -&gt; ea_t</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: BADADDR
if next chunk doesn't exist.</div>
</div></div>
</dd>
<dt id="ida_bytes.next_head"><code class="name flex">
<span>def <span class="ident">next_head</span></span>(<span>*args) &#8209;&gt;&#160;ea_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get start of next defined item.</div>
<div class="epy_par">
<strong class="epy_sig">next_head(ea, maxea) -&gt; ea_t</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong>: begin search at this address (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">maxea</strong>: not included in the search range (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: BADADDR
if none exists.</div>
</div></div>
</dd>
<dt id="ida_bytes.next_inited"><code class="name flex">
<span>def <span class="ident">next_inited</span></span>(<span>*args) &#8209;&gt;&#160;ea_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Find the next initialized address.</div>
<div class="epy_par">
<strong class="epy_sig">next_inited(ea, maxea) -&gt; ea_t</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">maxea</strong> (C++: ea_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.next_not_tail"><code class="name flex">
<span>def <span class="ident">next_not_tail</span></span>(<span>*args) &#8209;&gt;&#160;ea_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get address of next non-tail byte.</div>
<div class="epy_par">
<strong class="epy_sig">next_not_tail(ea) -&gt; ea_t</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: BADADDR
if none exists.</div>
</div></div>
</dd>
<dt id="ida_bytes.next_that"><code class="name flex">
<span>def <span class="ident">next_that</span></span>(<span>*args) &#8209;&gt;&#160;ea_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">next_that(ea, maxea, callable) -&gt; ea_t</strong><div class="epy_nested">
Find next address with a flag satisfying the function 'testf'.
Start searching from address 'ea'+1 and inspect bytes up to 'maxea'.
maxea is not included in the search range.</div>
<div class="epy_nested">
<strong class="epy_parameter">callable</strong>: a Python callable with the following prototype:<div class="epy_nested">
callable(flags). Return True to stop enumeration.</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: the found address or BADADDR.</div>
</div></div>
</dd>
<dt id="ida_bytes.next_unknown"><code class="name flex">
<span>def <span class="ident">next_unknown</span></span>(<span>*args) &#8209;&gt;&#160;ea_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Similar to 'next_that()' , but will find the next address that is
unexplored.</div>
<div class="epy_par">
<strong class="epy_sig">next_unknown(ea, maxea) -&gt; ea_t</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">maxea</strong> (C++: ea_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.next_visea"><code class="name flex">
<span>def <span class="ident">next_visea</span></span>(<span>*args) &#8209;&gt;&#160;ea_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get next visible address.</div>
<div class="epy_par">
<strong class="epy_sig">next_visea(ea) -&gt; ea_t</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: BADADDR
if none exists.</div>
</div></div>
</dd>
<dt id="ida_bytes.num_flag"><code class="name flex">
<span>def <span class="ident">num_flag</span></span>(<span>*args) &#8209;&gt;&#160;flags_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get number of default base (bin, oct, dec, hex)</div></div>
</dd>
<dt id="ida_bytes.oct_flag"><code class="name flex">
<span>def <span class="ident">oct_flag</span></span>(<span>*args) &#8209;&gt;&#160;flags_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get number flag of the base, regardless of current processor - better
to use 'num_flag()'</div></div>
</dd>
<dt id="ida_bytes.off_flag"><code class="name flex">
<span>def <span class="ident">off_flag</span></span>(<span>*args) &#8209;&gt;&#160;flags_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
see 'Bits: instruction operand types'</div></div>
</dd>
<dt id="ida_bytes.op_adds_xrefs"><code class="name flex">
<span>def <span class="ident">op_adds_xrefs</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Should processor module create xrefs from the operand?. Currently
'offset' and 'structure offset' operands create xrefs</div>
<div class="epy_par">
<strong class="epy_sig">op_adds_xrefs(F, n) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">n</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_bytes.op_bin"><code class="name flex">
<span>def <span class="ident">op_bin</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
set op type to 'bin_flag()'</div>
<div class="epy_par">
<strong class="epy_sig">op_bin(ea, n) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">n</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_bytes.op_chr"><code class="name flex">
<span>def <span class="ident">op_chr</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
set op type to 'char_flag()'</div>
<div class="epy_par">
<strong class="epy_sig">op_chr(ea, n) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">n</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_bytes.op_custfmt"><code class="name flex">
<span>def <span class="ident">op_custfmt</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Set custom data format for operand (fid-custom data format id)</div>
<div class="epy_par">
<strong class="epy_sig">op_custfmt(ea, n, fid) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">n</strong> (C++: int)</div>
<div class="epy_nested">
<strong class="epy_parameter">fid</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_bytes.op_dec"><code class="name flex">
<span>def <span class="ident">op_dec</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
set op type to 'dec_flag()'</div>
<div class="epy_par">
<strong class="epy_sig">op_dec(ea, n) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">n</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_bytes.op_enum"><code class="name flex">
<span>def <span class="ident">op_enum</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Set operand representation to be 'enum_t'. If applied to unexplored
bytes, converts them to 16/32bit word data</div>
<div class="epy_par">
<strong class="epy_sig">op_enum(ea, n, id, serial) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong>: linear address (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">n</strong>: number of operand (0, 1, -1) (C++: int)</div>
<div class="epy_nested">
<strong class="epy_parameter">id</strong>: id of enum (C++: enum_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">serial</strong>: the serial number of the constant in the enumeration,<div class="epy_nested">
usually 0. the serial numbers are used if the
enumeration contains several constants with the same
value (C++: uchar)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: success</div>
</div></div>
</dd>
<dt id="ida_bytes.op_flt"><code class="name flex">
<span>def <span class="ident">op_flt</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
set op type to 'flt_flag()'</div>
<div class="epy_par">
<strong class="epy_sig">op_flt(ea, n) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">n</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_bytes.op_hex"><code class="name flex">
<span>def <span class="ident">op_hex</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
set op type to 'hex_flag()'</div>
<div class="epy_par">
<strong class="epy_sig">op_hex(ea, n) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">n</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_bytes.op_num"><code class="name flex">
<span>def <span class="ident">op_num</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
set op type to 'num_flag()'</div>
<div class="epy_par">
<strong class="epy_sig">op_num(ea, n) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">n</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_bytes.op_oct"><code class="name flex">
<span>def <span class="ident">op_oct</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
set op type to 'oct_flag()'</div>
<div class="epy_par">
<strong class="epy_sig">op_oct(ea, n) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">n</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_bytes.op_seg"><code class="name flex">
<span>def <span class="ident">op_seg</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Set operand representation to be 'segment'. If applied to unexplored
bytes, converts them to 16/32bit word data</div>
<div class="epy_par">
<strong class="epy_sig">op_seg(ea, n) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong>: linear address (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">n</strong>: number of operand (0, 1, -1) (C++: int)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: success</div>
</div></div>
</dd>
<dt id="ida_bytes.op_stkvar"><code class="name flex">
<span>def <span class="ident">op_stkvar</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Set operand representation to be 'stack variable'. Should be applied
to an instruction within a function. Should be applied after creating
a stack var using 'insn_t::create_stkvar()' .</div>
<div class="epy_par">
<strong class="epy_sig">op_stkvar(ea, n) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong>: linear address (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">n</strong>: number of operand (0, 1, -1) (C++: int)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: success</div>
</div></div>
</dd>
<dt id="ida_bytes.op_stroff"><code class="name flex">
<span>def <span class="ident">op_stroff</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Set operand representation to be 'struct offset'. If applied to
unexplored bytes, converts them to 16/32bit word data</div>
<div class="epy_par">
<strong class="epy_sig">op_stroff(insn, n, path, path_len, delta) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">insn</strong>: the instruction
- an ida_ua.insn_t, or an address (C++:<div class="epy_nested">
const insn_t &amp;)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">n</strong>: number of operand (0, 1, -1) (C++: int)</div>
<div class="epy_nested">
<strong class="epy_parameter">path</strong>: structure path (strpath). see
nalt.hpp
for more info.<div class="epy_nested">
(C++: const
tid_t
*)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">path_len</strong>: length of the structure path (C++: int)</div>
<div class="epy_nested">
<strong class="epy_parameter">delta</strong>: struct offset delta. usually 0. denotes the difference<div class="epy_nested">
between the structure base and the pointer into the
structure. (C++: adiff_t)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: success</div>
<div class="epy_nested">
Example:
Python&gt;
Python&gt; ins = ida_ua.insn_t()
Python&gt; if ida_ua.decode_insn(ins, some_address):
Python&gt;
path_len = 1
Python&gt;
path = ida_pro.tid_array(path_len)
Python&gt;
path[0] = ida_struct.get_struc_id("my_stucture_t")
Python&gt;
ida_bytes.op_stroff(ins, 0, path.cast(), path_len, 0)
Python&gt;</div>
</div></div>
</dd>
<dt id="ida_bytes.oword_flag"><code class="name flex">
<span>def <span class="ident">oword_flag</span></span>(<span>*args) &#8209;&gt;&#160;flags_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get a flags_t representing a octaword.</div></div>
</dd>
<dt id="ida_bytes.packreal_flag"><code class="name flex">
<span>def <span class="ident">packreal_flag</span></span>(<span>*args) &#8209;&gt;&#160;flags_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get a flags_t representing a packed decimal real.</div></div>
</dd>
<dt id="ida_bytes.parse_binpat_str"><code class="name flex">
<span>def <span class="ident">parse_binpat_str</span></span>(<span>*args) &#8209;&gt;&#160;qstring&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Convert user-specified binary string to internal representation. The
'in' parameter contains space-separated tokens:</div>
<ul class="epy_ul">
<li class="epy_li"><span class="epy_par">
numbers (numeric base is determined by 'radix')<ul class="epy_ul">
<li class="epy_li"><span class="epy_nested">
if value of number fits a byte, it is considered as a byte</span>
</li>
<li class="epy_li"><span class="epy_nested">
if value of number fits a word, it is considered as 2 bytes</span>
</li>
<li class="epy_li"><span class="epy_nested">
if value of number fits a dword,it is considered as 4 bytes</span>
</li>
</ul>
</span>
</li>
<li class="epy_li"><span class="epy_par">
"..." string constants</span>
</li>
<li class="epy_li"><span class="epy_par">
'x'
single-character constants</span>
</li>
<li class="epy_li"><span class="epy_par">
?
variable bytes</span>
</li>
</ul>
<div class="epy_par">
Note that string constants are surrounded with double quotes.Here are
a few examples (assuming base 16):</div>
<div class="epy_par">
CD 21
- bytes 0xCD, 0x21
21CD
- bytes 0xCD, 0x21 (little endian ) or 0x21, 0xCD (big-endian)
"Hello", 0
- the null terminated string "Hello"
L"Hello"
- 'H', 0, 'e', 0, 'l', 0, 'l', 0, 'o', 0
B8 ? ? ? ? 90
- byte 0xB8, 4 bytes with any value, byte 0x90</div>
<div class="epy_par">
<strong class="epy_sig">parse_binpat_str(out, ea, _in, radix, strlits_encoding=0) -&gt; str</strong><div class="epy_nested">
<strong class="epy_parameter">out</strong>: a vector of compiled binary patterns, for use with<div class="epy_nested">
bin_search2() (C++: compiled_binpat_vec_t
*)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">ea</strong>: linear address to convert for (the conversion depends on<div class="epy_nested">
the address, because the number of bits in a byte depend on
the segment type) (C++: ea_t)</div>
</div>
<div class="epy_nested">
in: char const *</div>
<div class="epy_nested">
<strong class="epy_parameter">radix</strong>: numeric base of numbers (8,10,16) (C++: int)</div>
<div class="epy_nested">
<strong class="epy_parameter">strlits_encoding</strong>: the target encoding into which the string<div class="epy_nested">
literals present in 'in', should be encoded.
Can be any from [1,
get_encoding_qty() ), or
the special values PBSENC_* (C++: int)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: false either in case of parsing error, or if at least one<div class="epy_nested">
requested target encoding couldn't encode the string literals
present in "in".</div>
</div>
</div></div>
</dd>
<dt id="ida_bytes.patch_byte"><code class="name flex">
<span>def <span class="ident">patch_byte</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Patch a byte of the program. The original value of the byte is saved
and can be obtained by 'get_original_byte()' . This function works for
wide byte processors too.</div>
<div class="epy_par">
<strong class="epy_sig">patch_byte(ea, x) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">x</strong> (C++: uint64)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: true - the database has been modified,</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: false - the debugger is running and the process' memory has<div class="epy_nested">
value 'x' at address 'ea', or the debugger is not
running, and the IDB has value 'x' at address 'ea
already.</div>
</div>
</div></div>
</dd>
<dt id="ida_bytes.patch_bytes"><code class="name flex">
<span>def <span class="ident">patch_bytes</span></span>(<span>*args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Patch the specified number of bytes of the program. Original values of
bytes are saved and are available with get_original...() functions.
See also 'put_bytes()' .</div>
<div class="epy_par">
<strong class="epy_sig">patch_bytes(ea, buf)</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong>: linear address (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">buf</strong>: buffer with new values of bytes (C++: const void *)</div>
</div></div>
</dd>
<dt id="ida_bytes.patch_dword"><code class="name flex">
<span>def <span class="ident">patch_dword</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Patch a dword of the program. The original value of the dword is saved
and can be obtained by 'get_original_dword()' . This function DOESN'T
work for wide byte processors. This function takes into account order
of bytes specified in \inf{is_be()}</div>
<div class="epy_par">
<strong class="epy_sig">patch_dword(ea, x) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">x</strong> (C++: uint64)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: true - the database has been modified,</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: false - the debugger is running and the process' memory has<div class="epy_nested">
value 'x' at address 'ea', or the debugger is not
running, and the IDB has value 'x' at address 'ea
already.</div>
</div>
</div></div>
</dd>
<dt id="ida_bytes.patch_qword"><code class="name flex">
<span>def <span class="ident">patch_qword</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Patch a qword of the program. The original value of the qword is saved
and can be obtained by 'get_original_qword()' . This function DOESN'T
work for wide byte processors. This function takes into account order
of bytes specified in \inf{is_be()}</div>
<div class="epy_par">
<strong class="epy_sig">patch_qword(ea, x) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">x</strong> (C++: uint64)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: true - the database has been modified,</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: false - the debugger is running and the process' memory has<div class="epy_nested">
value 'x' at address 'ea', or the debugger is not
running, and the IDB has value 'x' at address 'ea
already.</div>
</div>
</div></div>
</dd>
<dt id="ida_bytes.patch_word"><code class="name flex">
<span>def <span class="ident">patch_word</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Patch a word of the program. The original value of the word is saved
and can be obtained by 'get_original_word()' . This function works for
wide byte processors too. This function takes into account order of
bytes specified in \inf{is_be()}</div>
<div class="epy_par">
<strong class="epy_sig">patch_word(ea, x) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">x</strong> (C++: uint64)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: true - the database has been modified,</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: false - the debugger is running and the process' memory has<div class="epy_nested">
value 'x' at address 'ea', or the debugger is not
running, and the IDB has value 'x' at address 'ea
already.</div>
</div>
</div></div>
</dd>
<dt id="ida_bytes.prev_addr"><code class="name flex">
<span>def <span class="ident">prev_addr</span></span>(<span>*args) &#8209;&gt;&#160;ea_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get previous address in the program.</div>
<div class="epy_par">
<strong class="epy_sig">prev_addr(ea) -&gt; ea_t</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: BADADDR
if no such address exist.</div>
</div></div>
</dd>
<dt id="ida_bytes.prev_chunk"><code class="name flex">
<span>def <span class="ident">prev_chunk</span></span>(<span>*args) &#8209;&gt;&#160;ea_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get the last address of previous contiguous chunk in the program.</div>
<div class="epy_par">
<strong class="epy_sig">prev_chunk(ea) -&gt; ea_t</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: BADADDR
if previous chunk doesn't exist.</div>
</div></div>
</dd>
<dt id="ida_bytes.prev_head"><code class="name flex">
<span>def <span class="ident">prev_head</span></span>(<span>*args) &#8209;&gt;&#160;ea_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get start of previous defined item.</div>
<div class="epy_par">
<strong class="epy_sig">prev_head(ea, minea) -&gt; ea_t</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong>: begin search at this address (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">minea</strong>: included in the search range (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: BADADDR
if none exists.</div>
</div></div>
</dd>
<dt id="ida_bytes.prev_inited"><code class="name flex">
<span>def <span class="ident">prev_inited</span></span>(<span>*args) &#8209;&gt;&#160;ea_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Find the previous initialized address.</div>
<div class="epy_par">
<strong class="epy_sig">prev_inited(ea, minea) -&gt; ea_t</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">minea</strong> (C++: ea_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.prev_not_tail"><code class="name flex">
<span>def <span class="ident">prev_not_tail</span></span>(<span>*args) &#8209;&gt;&#160;ea_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get address of previous non-tail byte.</div>
<div class="epy_par">
<strong class="epy_sig">prev_not_tail(ea) -&gt; ea_t</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: BADADDR
if none exists.</div>
</div></div>
</dd>
<dt id="ida_bytes.prev_that"><code class="name flex">
<span>def <span class="ident">prev_that</span></span>(<span>*args) &#8209;&gt;&#160;ea_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Find previous address with a flag satisfying the function 'testf'.do
not pass 'is_unknown()' to this function to find unexplored bytes It
will fail under the debugger. To find unexplored bytes, use
'prev_unknown()' .</div>
<div class="epy_par">
<strong class="epy_sig">prev_that(ea, minea, callable) -&gt; ea_t</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong>: start searching from this address - 1. (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">minea</strong>: included in the search range. (C++: ea_t)
callable: PyObject *</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: the found address or
BADADDR .</div>
</div></div>
</dd>
<dt id="ida_bytes.prev_unknown"><code class="name flex">
<span>def <span class="ident">prev_unknown</span></span>(<span>*args) &#8209;&gt;&#160;ea_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Similar to 'prev_that()' , but will find the previous address that is
unexplored.</div>
<div class="epy_par">
<strong class="epy_sig">prev_unknown(ea, minea) -&gt; ea_t</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">minea</strong> (C++: ea_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.prev_visea"><code class="name flex">
<span>def <span class="ident">prev_visea</span></span>(<span>*args) &#8209;&gt;&#160;ea_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get previous visible address.</div>
<div class="epy_par">
<strong class="epy_sig">prev_visea(ea) -&gt; ea_t</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: BADADDR
if none exists.</div>
</div></div>
</dd>
<dt id="ida_bytes.print_strlit_type"><code class="name flex">
<span>def <span class="ident">print_strlit_type</span></span>(<span>*args) &#8209;&gt;&#160;PyObject&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get string type information: the string type name (possibly decorated
with hotkey markers), and the tooltip.</div>
<div class="epy_par">
<strong class="epy_sig">print_strlit_type(strtype, flags=0) -&gt; PyObject *</strong><div class="epy_nested">
<strong class="epy_parameter">strtype</strong>: the string type (C++: int32)</div>
<div class="epy_nested">
<strong class="epy_parameter">flags</strong>: or'ed PSTF_* constants (C++: int)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: length of generated text</div>
</div></div>
</dd>
<dt id="ida_bytes.put_byte"><code class="name flex">
<span>def <span class="ident">put_byte</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Set value of one byte of the program. This function modifies the
database. If the debugger is active then the debugged process memory
is patched too.The original value of the byte is completely lost and
can't be recovered by the 'get_original_byte()' function. See also
'put_dbg_byte()' to write to the process memory directly when the
debugger is active. This function can handle wide byte processors.</div>
<div class="epy_par">
<strong class="epy_sig">put_byte(ea, x) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong>: linear address (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">x</strong>: byte value (C++: uint64)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: true if the database has been modified</div>
</div></div>
</dd>
<dt id="ida_bytes.put_bytes"><code class="name flex">
<span>def <span class="ident">put_bytes</span></span>(<span>*args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Modify the specified number of bytes of the program. This function
does not save the original values of bytes. See also 'patch_bytes()' .</div>
<div class="epy_par">
<strong class="epy_sig">put_bytes(ea, buf)</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong>: linear address (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">buf</strong>: buffer with new values of bytes (C++: const void *)</div>
</div></div>
</dd>
<dt id="ida_bytes.put_dword"><code class="name flex">
<span>def <span class="ident">put_dword</span></span>(<span>*args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Set value of one dword of the program. This function takes into
account order of bytes specified in \inf{is_be()}
This function works
for wide byte processors too.the original value of the dword is
completely lost and can't be recovered by the 'get_original_dword()'
function.</div>
<div class="epy_par">
<strong class="epy_sig">put_dword(ea, x)</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong>: linear address (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">x</strong>: dword value (C++: uint64)</div>
</div></div>
</dd>
<dt id="ida_bytes.put_qword"><code class="name flex">
<span>def <span class="ident">put_qword</span></span>(<span>*args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Set value of one qword (8 bytes) of the program. This function takes
into account order of bytes specified in \inf{is_be()}
This function
DOESN'T works for wide byte processors.</div>
<div class="epy_par">
<strong class="epy_sig">put_qword(ea, x)</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong>: linear address (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">x</strong>: qword value (C++: uint64)</div>
</div></div>
</dd>
<dt id="ida_bytes.put_word"><code class="name flex">
<span>def <span class="ident">put_word</span></span>(<span>*args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Set value of one word of the program. This function takes into account
order of bytes specified in \inf{is_be()}
This function works for wide
byte processors too.The original value of the word is completely lost
and can't be recovered by the 'get_original_word()' function. ea -
linear address x - word value</div>
<div class="epy_par">
<strong class="epy_sig">put_word(ea, x)</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">x</strong> (C++: uint64)</div>
</div></div>
</dd>
<dt id="ida_bytes.qword_flag"><code class="name flex">
<span>def <span class="ident">qword_flag</span></span>(<span>*args) &#8209;&gt;&#160;flags_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get a flags_t representing a quad word.</div></div>
</dd>
<dt id="ida_bytes.register_custom_data_format"><code class="name flex">
<span>def <span class="ident">register_custom_data_format</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">register_custom_data_format(py_df) -&gt; int</strong><div class="epy_nested">
Registers a custom data format with a given data type.</div>
<div class="epy_nested">
<strong class="epy_parameter">df</strong>: an instance of data_format_t</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>:<div class="epy_nested">
&lt; 0 if failed to register
&gt; 0 data format id</div>
</div>
</div></div>
</dd>
<dt id="ida_bytes.register_custom_data_type"><code class="name flex">
<span>def <span class="ident">register_custom_data_type</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">register_custom_data_type(py_dt) -&gt; int</strong><div class="epy_nested">
Registers a custom data type.</div>
<div class="epy_nested">
<strong class="epy_parameter">dt</strong>: an instance of the data_type_t class</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>:<div class="epy_nested">
&lt; 0 if failed to register
&gt; 0 data type id</div>
</div>
</div></div>
</dd>
<dt id="ida_bytes.register_data_types_and_formats"><code class="name flex">
<span>def <span class="ident">register_data_types_and_formats</span></span>(<span>formats)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Registers multiple data types and formats at once.
To register one type/format at a time use register_custom_data_type/register_custom_data_format</div>
<div class="epy_par">
It employs a special table of types and formats described below:</div>
<div class="epy_par">
The 'formats' is a list of tuples. If a tuple has one element then it is the format to be registered with dtid=0
If the tuple has more than one element, then tuple[0] is the data type and tuple[1:] are the data formats. For example:
many_formats = [<div class="epy_nested">
(pascal_data_type(), pascal_data_format()),
(simplevm_data_type(), simplevm_data_format()),
(makedword_data_format(),),
(simplevm_data_format(),)</div>
</div>
<div class="epy_par">
]
The first two tuples describe data types and their associated formats.
The last two tuples describe two data formats to be used with built-in data types.
The data format may be attached to several data types. The id of the
data format is stored in the first data_format_t object. For example:
assert many_formats[1][1] != -1
assert many_formats[2][0] != -1
assert many_formats[3][0] == -1</div></div>
</dd>
<dt id="ida_bytes.revert_byte"><code class="name flex">
<span>def <span class="ident">revert_byte</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Revert patched byte</div>
<div class="epy_par">
<strong class="epy_sig">revert_byte(ea) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: true - byte was patched before and reverted now</div>
</div></div>
</dd>
<dt id="ida_bytes.seg_flag"><code class="name flex">
<span>def <span class="ident">seg_flag</span></span>(<span>*args) &#8209;&gt;&#160;flags_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
see 'Bits: instruction operand types'</div></div>
</dd>
<dt id="ida_bytes.set_cmt"><code class="name flex">
<span>def <span class="ident">set_cmt</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Set an indented comment.</div>
<div class="epy_par">
<strong class="epy_sig">set_cmt(ea, comm, rptble) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong>: linear address (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">comm</strong>: comment string
nullptr: do nothing (return 0)
"" :<div class="epy_nested">
delete comment (C++: const char *)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">rptble</strong>: is repeatable? (C++: bool)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: success</div>
</div></div>
</dd>
<dt id="ida_bytes.set_forced_operand"><code class="name flex">
<span>def <span class="ident">set_forced_operand</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Set forced operand.</div>
<div class="epy_par">
<strong class="epy_sig">set_forced_operand(ea, n, op) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong>: linear address (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">n</strong>: number of operand (0, 1, 2) (C++: int)</div>
<div class="epy_nested">
<strong class="epy_parameter">op</strong>: text of operand
nullptr: do nothing (return 0)
"" :<div class="epy_nested">
delete forced operand (C++: const char *)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: success</div>
</div></div>
</dd>
<dt id="ida_bytes.set_immd"><code class="name flex">
<span>def <span class="ident">set_immd</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Set 'has immediate operand' flag. Returns true if the 'FF_IMMD' bit
was not set and now is set</div>
<div class="epy_par">
<strong class="epy_sig">set_immd(ea) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
</div></div>
</dd>
<dt id="ida_bytes.set_lzero"><code class="name flex">
<span>def <span class="ident">set_lzero</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Set toggle lzero bit.</div>
<div class="epy_par">
<strong class="epy_sig">set_lzero(ea, n) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">n</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_bytes.set_manual_insn"><code class="name flex">
<span>def <span class="ident">set_manual_insn</span></span>(<span>*args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Set manual instruction string.</div>
<div class="epy_par">
<strong class="epy_sig">set_manual_insn(ea, manual_insn)</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong>: linear address of the instruction or data item (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">manual_insn</strong>: "" - delete manual string. nullptr - do nothing<div class="epy_nested">
(C++: const char *)</div>
</div>
</div></div>
</dd>
<dt id="ida_bytes.set_op_type"><code class="name flex">
<span>def <span class="ident">set_op_type</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
(internal function) change representation of operand(s).</div>
<div class="epy_par">
<strong class="epy_sig">set_op_type(ea, type, n) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong>: linear address (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">type</strong>: new flag value (should be obtained from
char_flag() ,<div class="epy_nested">
num_flag()
and similar functions) (C++: flags_t)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">n</strong>: number of operand (0, 1, -1) (C++: int)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 - ok</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - failed (applied to a tail byte)</div>
</div></div>
</dd>
<dt id="ida_bytes.set_opinfo"><code class="name flex">
<span>def <span class="ident">set_opinfo</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Set additional information about an operand representation. This
function is a low level one. Only the kernel should use it.</div>
<div class="epy_par">
<strong class="epy_sig">set_opinfo(ea, n, flag, ti, suppress_events=False) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong>: linear address of the item (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">n</strong>: number of operand, 0 or 1 (C++: int)</div>
<div class="epy_nested">
<strong class="epy_parameter">flag</strong>: flags of the item (C++: flags_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">ti</strong>: additional representation information (C++: const
opinfo_t<div class="epy_nested">
*)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">suppress_events</strong>: do not generate changing_op_type and<div class="epy_nested">
op_type_changed events (C++: bool)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: success</div>
</div></div>
</dd>
<dt id="ida_bytes.stkvar_flag"><code class="name flex">
<span>def <span class="ident">stkvar_flag</span></span>(<span>*args) &#8209;&gt;&#160;flags_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
see 'Bits: instruction operand types'</div></div>
</dd>
<dt id="ida_bytes.strlit_flag"><code class="name flex">
<span>def <span class="ident">strlit_flag</span></span>(<span>*args) &#8209;&gt;&#160;flags_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get a flags_t representing a string literal.</div></div>
</dd>
<dt id="ida_bytes.stroff_flag"><code class="name flex">
<span>def <span class="ident">stroff_flag</span></span>(<span>*args) &#8209;&gt;&#160;flags_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
see 'Bits: instruction operand types'</div></div>
</dd>
<dt id="ida_bytes.stru_flag"><code class="name flex">
<span>def <span class="ident">stru_flag</span></span>(<span>*args) &#8209;&gt;&#160;flags_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get a flags_t representing a struct.</div></div>
</dd>
<dt id="ida_bytes.tbyte_flag"><code class="name flex">
<span>def <span class="ident">tbyte_flag</span></span>(<span>*args) &#8209;&gt;&#160;flags_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get a flags_t representing a tbyte.</div></div>
</dd>
<dt id="ida_bytes.toggle_bnot"><code class="name flex">
<span>def <span class="ident">toggle_bnot</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Toggle binary negation of operand. also see 'is_bnot()'</div>
<div class="epy_par">
<strong class="epy_sig">toggle_bnot(ea, n) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">n</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_bytes.toggle_lzero"><code class="name flex">
<span>def <span class="ident">toggle_lzero</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">toggle_lzero(ea, n) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">n</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_bytes.toggle_sign"><code class="name flex">
<span>def <span class="ident">toggle_sign</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Toggle sign of n-th operand. allowed values of n: 0-first operand,
1-other operands</div>
<div class="epy_par">
<strong class="epy_sig">toggle_sign(ea, n) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">n</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_bytes.unregister_custom_data_format"><code class="name flex">
<span>def <span class="ident">unregister_custom_data_format</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">unregister_custom_data_format(dfid) -&gt; bool</strong><div class="epy_nested">
Unregisters a custom data format</div>
<div class="epy_nested">
<strong class="epy_parameter">dfid</strong>: data format id</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: Boolean</div>
</div></div>
</dd>
<dt id="ida_bytes.unregister_custom_data_type"><code class="name flex">
<span>def <span class="ident">unregister_custom_data_type</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">unregister_custom_data_type(dtid) -&gt; bool</strong><div class="epy_nested">
Unregisters a custom data type.</div>
<div class="epy_nested">
<strong class="epy_parameter">dtid</strong>: the data type id</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: Boolean</div>
</div></div>
</dd>
<dt id="ida_bytes.unregister_data_types_and_formats"><code class="name flex">
<span>def <span class="ident">unregister_data_types_and_formats</span></span>(<span>formats)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
As opposed to register_data_types_and_formats(), this function
unregisters multiple data types and formats at once.</div></div>
</dd>
<dt id="ida_bytes.update_hidden_range"><code class="name flex">
<span>def <span class="ident">update_hidden_range</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Update hidden range information in the database. You cannot use this
function to change the range boundaries</div>
<div class="epy_par">
<strong class="epy_sig">update_hidden_range(ha) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ha</strong>: range to update (C++: const
hidden_range_t
*)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: success</div>
</div></div>
</dd>
<dt id="ida_bytes.use_mapping"><code class="name flex">
<span>def <span class="ident">use_mapping</span></span>(<span>*args) &#8209;&gt;&#160;ea_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Translate address according to current mappings.</div>
<div class="epy_par">
<strong class="epy_sig">use_mapping(ea) -&gt; ea_t</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong>: address to translate (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: translated address</div>
</div></div>
</dd>
<dt id="ida_bytes.visit_patched_bytes"><code class="name flex">
<span>def <span class="ident">visit_patched_bytes</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">visit_patched_bytes(ea1, ea2, py_callable) -&gt; int</strong><div class="epy_nested">
Enumerates patched bytes in the given range and invokes a callable</div>
<div class="epy_nested">
<strong class="epy_parameter">ea1</strong>: start address</div>
<div class="epy_nested">
<strong class="epy_parameter">ea2</strong>: end address</div>
<div class="epy_nested">
<strong class="epy_parameter">callable</strong>: a Python callable with the following prototype:<div class="epy_nested">
callable(ea, fpos, org_val, patch_val).
If the callable returns non-zero then that value will be
returned to the caller and the enumeration will be
interrupted.</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: Zero if the enumeration was successful or the return<div class="epy_nested">
value of the callback if enumeration was interrupted.</div>
</div>
</div></div>
</dd>
<dt id="ida_bytes.word_flag"><code class="name flex">
<span>def <span class="ident">word_flag</span></span>(<span>*args) &#8209;&gt;&#160;flags_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get a flags_t representing a word.</div></div>
</dd>
<dt id="ida_bytes.yword_flag"><code class="name flex">
<span>def <span class="ident">yword_flag</span></span>(<span>*args) &#8209;&gt;&#160;flags_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get a flags_t representing a ymm word.</div></div>
</dd>
<dt id="ida_bytes.zword_flag"><code class="name flex">
<span>def <span class="ident">zword_flag</span></span>(<span>*args) &#8209;&gt;&#160;flags_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get a flags_t representing a zmm word.</div></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ida_bytes.compiled_binpat_t"><code class="flex name class">
<span>class <span class="ident">compiled_binpat_t</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ compiled_binpat_t class.</div>
<div class="epy_par">
<strong class="epy_sig">__init__(self) -&gt; compiled_binpat_t</strong></div></div>
<h3>Instance variables</h3>
<dl>
<dt id="ida_bytes.compiled_binpat_t.bytes"><code class="name">var <span class="ident">bytes</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">compiled_binpat_t_bytes_get(self) -&gt; bytevec_t *</strong></div></div>
</dd>
<dt id="ida_bytes.compiled_binpat_t.encidx"><code class="name">var <span class="ident">encidx</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">compiled_binpat_t_encidx_get(self) -&gt; int</strong></div></div>
</dd>
<dt id="ida_bytes.compiled_binpat_t.mask"><code class="name">var <span class="ident">mask</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">compiled_binpat_t_mask_get(self) -&gt; bytevec_t *</strong></div></div>
</dd>
<dt id="ida_bytes.compiled_binpat_t.strlits"><code class="name">var <span class="ident">strlits</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">compiled_binpat_t_strlits_get(self) -&gt; rangevec_t</strong></div></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ida_bytes.compiled_binpat_t.all_bytes_defined"><code class="name flex">
<span>def <span class="ident">all_bytes_defined</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">all_bytes_defined(self) -&gt; bool</strong></div></div>
</dd>
<dt id="ida_bytes.compiled_binpat_t.qclear"><code class="name flex">
<span>def <span class="ident">qclear</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">qclear(self)</strong></div></div>
</dd>
</dl>
</dd>
<dt id="ida_bytes.compiled_binpat_vec_t"><code class="flex name class">
<span>class <span class="ident">compiled_binpat_vec_t</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ qvector&lt; compiled_binpat_t &gt; class.</div>
<div class="epy_par">
<strong class="epy_sig">__init__(self) -&gt; compiled_binpat_vec_t</strong><div class="epy_nested">
x: qvector&lt; compiled_binpat_t &gt; const &amp;</div>
</div></div>
<h3>Methods</h3>
<dl>
<dt id="ida_bytes.compiled_binpat_vec_t.add_unique"><code class="name flex">
<span>def <span class="ident">add_unique</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">add_unique(self, x) -&gt; bool</strong><div class="epy_nested">
x: compiled_binpat_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_bytes.compiled_binpat_vec_t.at"><code class="name flex">
<span>def <span class="ident">at</span></span>(<span>self, *args) &#8209;&gt;&#160;<a title="ida_bytes.compiled_binpat_t" href="#ida_bytes.compiled_binpat_t">compiled_binpat_t</a>&#160;const&#160;&amp;</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">at(self, _idx) -&gt; compiled_binpat_t</strong><div class="epy_nested">
_idx: size_t</div>
</div></div>
</dd>
<dt id="ida_bytes.compiled_binpat_vec_t.back"><code class="name flex">
<span>def <span class="ident">back</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"/>
</dd>
<dt id="ida_bytes.compiled_binpat_vec_t.begin"><code class="name flex">
<span>def <span class="ident">begin</span></span>(<span>self, *args) &#8209;&gt;&#160;qvectorcompiled_binpat_t&#160;&gt;::const_iterator</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">begin(self) -&gt; compiled_binpat_t</strong></div>
<div class="epy_par">
<strong class="epy_sig">begin(self) -&gt; compiled_binpat_t</strong></div></div>
</dd>
<dt id="ida_bytes.compiled_binpat_vec_t.capacity"><code class="name flex">
<span>def <span class="ident">capacity</span></span>(<span>self, *args) &#8209;&gt;&#160;size_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">capacity(self) -&gt; size_t</strong></div></div>
</dd>
<dt id="ida_bytes.compiled_binpat_vec_t.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">clear(self)</strong></div></div>
</dd>
<dt id="ida_bytes.compiled_binpat_vec_t.empty"><code class="name flex">
<span>def <span class="ident">empty</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">empty(self) -&gt; bool</strong></div></div>
</dd>
<dt id="ida_bytes.compiled_binpat_vec_t.end"><code class="name flex">
<span>def <span class="ident">end</span></span>(<span>self, *args) &#8209;&gt;&#160;qvectorcompiled_binpat_t&#160;&gt;::const_iterator</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">end(self) -&gt; compiled_binpat_t</strong></div>
<div class="epy_par">
<strong class="epy_sig">end(self) -&gt; compiled_binpat_t</strong></div></div>
</dd>
<dt id="ida_bytes.compiled_binpat_vec_t.erase"><code class="name flex">
<span>def <span class="ident">erase</span></span>(<span>self, *args) &#8209;&gt;&#160;qvectorcompiled_binpat_t&#160;&gt;::iterator</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">erase(self, it) -&gt; compiled_binpat_t</strong><div class="epy_nested">
it: qvector&lt; compiled_binpat_t &gt;::iterator</div>
</div>
<div class="epy_par">
<strong class="epy_sig">erase(self, first, last) -&gt; compiled_binpat_t</strong><div class="epy_nested">
first: qvector&lt; compiled_binpat_t &gt;::iterator
last: qvector&lt; compiled_binpat_t &gt;::iterator</div>
</div></div>
</dd>
<dt id="ida_bytes.compiled_binpat_vec_t.extract"><code class="name flex">
<span>def <span class="ident">extract</span></span>(<span>self, *args) &#8209;&gt;&#160;<a title="ida_bytes.compiled_binpat_t" href="#ida_bytes.compiled_binpat_t">compiled_binpat_t</a>&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">extract(self) -&gt; compiled_binpat_t</strong></div></div>
</dd>
<dt id="ida_bytes.compiled_binpat_vec_t.find"><code class="name flex">
<span>def <span class="ident">find</span></span>(<span>self, *args) &#8209;&gt;&#160;qvectorcompiled_binpat_t&#160;&gt;::const_iterator</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">find(self, x) -&gt; compiled_binpat_t</strong><div class="epy_nested">
x: compiled_binpat_t const &amp;</div>
</div>
<div class="epy_par">
<strong class="epy_sig">find(self, x) -&gt; compiled_binpat_t</strong><div class="epy_nested">
x: compiled_binpat_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_bytes.compiled_binpat_vec_t.front"><code class="name flex">
<span>def <span class="ident">front</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"/>
</dd>
<dt id="ida_bytes.compiled_binpat_vec_t.grow"><code class="name flex">
<span>def <span class="ident">grow</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
grow(self, x=compiled_binpat_t())<div class="epy_nested">
x: compiled_binpat_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_bytes.compiled_binpat_vec_t.has"><code class="name flex">
<span>def <span class="ident">has</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">has(self, x) -&gt; bool</strong><div class="epy_nested">
x: compiled_binpat_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_bytes.compiled_binpat_vec_t.inject"><code class="name flex">
<span>def <span class="ident">inject</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">inject(self, s, len)</strong><div class="epy_nested">
s: compiled_binpat_t *
len: size_t</div>
</div></div>
</dd>
<dt id="ida_bytes.compiled_binpat_vec_t.insert"><code class="name flex">
<span>def <span class="ident">insert</span></span>(<span>self, *args) &#8209;&gt;&#160;qvectorcompiled_binpat_t&#160;&gt;::iterator</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">insert(self, it, x) -&gt; compiled_binpat_t</strong><div class="epy_nested">
it: qvector&lt; compiled_binpat_t &gt;::iterator
x: compiled_binpat_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_bytes.compiled_binpat_vec_t.pop_back"><code class="name flex">
<span>def <span class="ident">pop_back</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">pop_back(self)</strong></div></div>
</dd>
<dt id="ida_bytes.compiled_binpat_vec_t.push_back"><code class="name flex">
<span>def <span class="ident">push_back</span></span>(<span>self, *args) &#8209;&gt;&#160;<a title="ida_bytes.compiled_binpat_t" href="#ida_bytes.compiled_binpat_t">compiled_binpat_t</a>&#160;&amp;</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">push_back(self, x)</strong><div class="epy_nested">
x: compiled_binpat_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_bytes.compiled_binpat_vec_t.qclear"><code class="name flex">
<span>def <span class="ident">qclear</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">qclear(self)</strong></div></div>
</dd>
<dt id="ida_bytes.compiled_binpat_vec_t.reserve"><code class="name flex">
<span>def <span class="ident">reserve</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">reserve(self, cnt)</strong><div class="epy_nested">
cnt: size_t</div>
</div></div>
</dd>
<dt id="ida_bytes.compiled_binpat_vec_t.resize"><code class="name flex">
<span>def <span class="ident">resize</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">resize(self, _newsize, x)</strong><div class="epy_nested">
_newsize: size_t
x: compiled_binpat_t const &amp;</div>
</div>
<div class="epy_par">
<strong class="epy_sig">resize(self, _newsize)</strong><div class="epy_nested">
_newsize: size_t</div>
</div></div>
</dd>
<dt id="ida_bytes.compiled_binpat_vec_t.size"><code class="name flex">
<span>def <span class="ident">size</span></span>(<span>self, *args) &#8209;&gt;&#160;size_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">size(self) -&gt; size_t</strong></div></div>
</dd>
<dt id="ida_bytes.compiled_binpat_vec_t.swap"><code class="name flex">
<span>def <span class="ident">swap</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">swap(self, r)</strong><div class="epy_nested">
r: qvector&lt; compiled_binpat_t &gt; &amp;</div>
</div></div>
</dd>
<dt id="ida_bytes.compiled_binpat_vec_t.truncate"><code class="name flex">
<span>def <span class="ident">truncate</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">truncate(self)</strong></div></div>
</dd>
</dl>
</dd>
<dt id="ida_bytes.data_format_t"><code class="flex name class">
<span>class <span class="ident">data_format_t</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ data_format_t class.</div></div>
<h3>Instance variables</h3>
<dl>
<dt id="ida_bytes.data_format_t.hotkey"><code class="name">var <span class="ident">hotkey</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">data_format_t_hotkey_get(self) -&gt; char const *</strong></div></div>
</dd>
<dt id="ida_bytes.data_format_t.id"><code class="name">var <span class="ident">id</span> :&#160;int</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">__get_id(self) -&gt; int</strong></div></div>
</dd>
<dt id="ida_bytes.data_format_t.menu_name"><code class="name">var <span class="ident">menu_name</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">data_format_t_menu_name_get(self) -&gt; char const *</strong></div></div>
</dd>
<dt id="ida_bytes.data_format_t.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">data_format_t_name_get(self) -&gt; char const *</strong></div></div>
</dd>
<dt id="ida_bytes.data_format_t.props"><code class="name">var <span class="ident">props</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">data_format_t_props_get(self) -&gt; int</strong></div></div>
</dd>
<dt id="ida_bytes.data_format_t.text_width"><code class="name">var <span class="ident">text_width</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">data_format_t_text_width_get(self) -&gt; int32</strong></div></div>
</dd>
<dt id="ida_bytes.data_format_t.value_size"><code class="name">var <span class="ident">value_size</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">data_format_t_value_size_get(self) -&gt; asize_t</strong></div></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ida_bytes.data_format_t.is_present_in_menus"><code class="name flex">
<span>def <span class="ident">is_present_in_menus</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Should this format be shown in UI menus</div></div>
</dd>
</dl>
</dd>
<dt id="ida_bytes.data_type_t"><code class="flex name class">
<span>class <span class="ident">data_type_t</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ data_type_t class.</div></div>
<h3>Instance variables</h3>
<dl>
<dt id="ida_bytes.data_type_t.asm_keyword"><code class="name">var <span class="ident">asm_keyword</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">data_type_t_asm_keyword_get(self) -&gt; char const *</strong></div></div>
</dd>
<dt id="ida_bytes.data_type_t.hotkey"><code class="name">var <span class="ident">hotkey</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">data_type_t_hotkey_get(self) -&gt; char const *</strong></div></div>
</dd>
<dt id="ida_bytes.data_type_t.id"><code class="name">var <span class="ident">id</span> :&#160;int</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">__get_id(self) -&gt; int</strong></div></div>
</dd>
<dt id="ida_bytes.data_type_t.menu_name"><code class="name">var <span class="ident">menu_name</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">data_type_t_menu_name_get(self) -&gt; char const *</strong></div></div>
</dd>
<dt id="ida_bytes.data_type_t.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">data_type_t_name_get(self) -&gt; char const *</strong></div></div>
</dd>
<dt id="ida_bytes.data_type_t.props"><code class="name">var <span class="ident">props</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">data_type_t_props_get(self) -&gt; int</strong></div></div>
</dd>
<dt id="ida_bytes.data_type_t.value_size"><code class="name">var <span class="ident">value_size</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">data_type_t_value_size_get(self) -&gt; asize_t</strong></div></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ida_bytes.data_type_t.is_present_in_menus"><code class="name flex">
<span>def <span class="ident">is_present_in_menus</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Should this type be shown in UI menus</div></div>
</dd>
</dl>
</dd>
<dt id="ida_bytes.hidden_range_t"><code class="flex name class">
<span>class <span class="ident">hidden_range_t</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ hidden_range_t class.</div>
<div class="epy_par">
<strong class="epy_sig">__init__(self) -&gt; hidden_range_t</strong></div></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="ida_range.range_t" href="ida_range.html#ida_range.range_t">range_t</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="ida_bytes.hidden_range_t.color"><code class="name">var <span class="ident">color</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">hidden_range_t_color_get(self) -&gt; bgcolor_t</strong></div></div>
</dd>
<dt id="ida_bytes.hidden_range_t.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">hidden_range_t_description_get(self) -&gt; char *</strong></div></div>
</dd>
<dt id="ida_bytes.hidden_range_t.footer"><code class="name">var <span class="ident">footer</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">hidden_range_t_footer_get(self) -&gt; char *</strong></div></div>
</dd>
<dt id="ida_bytes.hidden_range_t.header"><code class="name">var <span class="ident">header</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">hidden_range_t_header_get(self) -&gt; char *</strong></div></div>
</dd>
<dt id="ida_bytes.hidden_range_t.visible"><code class="name">var <span class="ident">visible</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">hidden_range_t_visible_get(self) -&gt; bool</strong></div></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="ida_range.range_t" href="ida_range.html#ida_range.range_t">range_t</a></b></code>:
<ul class="hlist">
<li><code><a title="ida_range.range_t.clear" href="ida_range.html#ida_range.range_t.clear">clear</a></code></li>
<li><code><a title="ida_range.range_t.compare" href="ida_range.html#ida_range.range_t.compare">compare</a></code></li>
<li><code><a title="ida_range.range_t.contains" href="ida_range.html#ida_range.range_t.contains">contains</a></code></li>
<li><code><a title="ida_range.range_t.empty" href="ida_range.html#ida_range.range_t.empty">empty</a></code></li>
<li><code><a title="ida_range.range_t.end_ea" href="ida_range.html#ida_range.range_t.end_ea">end_ea</a></code></li>
<li><code><a title="ida_range.range_t.extend" href="ida_range.html#ida_range.range_t.extend">extend</a></code></li>
<li><code><a title="ida_range.range_t.intersect" href="ida_range.html#ida_range.range_t.intersect">intersect</a></code></li>
<li><code><a title="ida_range.range_t.overlaps" href="ida_range.html#ida_range.range_t.overlaps">overlaps</a></code></li>
<li><code><a title="ida_range.range_t.size" href="ida_range.html#ida_range.range_t.size">size</a></code></li>
<li><code><a title="ida_range.range_t.start_ea" href="ida_range.html#ida_range.range_t.start_ea">start_ea</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
</main>
<footer id="footer">
<p>Copyright (c) 2021 Hex-Rays SA. <a href="/terms_of_use.shtml">Terms of use</a> and <a href="/privacy_policy.shtml">privacy policy</a>.</p>
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> ???</a>.</p>
</footer>
</body>
</html>