<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1"/>
<meta name="generator" content="pdoc ???"/>
<title>idautils API documentation</title>
<meta name="description" content="idautils.py - High level utility functions for IDA"/>
<link rel="preload stylesheet" as="style" href="assets/sanitize.min.css"/>
<link rel="preload stylesheet" as="style" href="assets/typography.min.css"/>
<link rel="stylesheet preload" as="style" href="assets/github.min.css"/>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar &amp;gt; *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl &amp;gt; dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:-webkit-fill-available}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name &amp;gt; span:first-child{white-space:nowrap}.name.class &amp;gt; span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary &amp;gt; *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content: ',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width: 700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content padding:3em 4em;border-left:1px solid #ddd;lid #ddd;}pre code{font-size:1em}.item .name{font-size:1em}main{/* display:flex; *//* flex-direction:row-reverse; *//* justify-content:flex-end; */}.toc ul ul,#index ul{padding-left:1.5em}.toc &gt; ul &gt; li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer="defer" src="assets/highlight.min.js"/>
<script>window.addEventListener('DOMContentLoaded', () =&gt; hljs.initHighlighting())</script>
<style>
#section-intro .epy_par
{
margin-top: 18px;
}
</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>idautils</code></h1>
</header>
<section id="section-intro">
<div class="epy_par">
idautils.py - High level utility functions for IDA</div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#---------------------------------------------------------------------
# IDAPython - Python plugin for Interactive Disassembler
#
# Copyright (c) 2004-2010 Gergely Erdelyi <gergely.erdelyi>
#
# All rights reserved.
#
# For detailed copyright information see the file COPYING in
# the root of the distribution archive.
#---------------------------------------------------------------------
"""
idautils.py - High level utility functions for IDA
"""
import ida_bytes
import ida_dbg
import ida_entry
import ida_funcs
import ida_ida
import ida_idaapi
import ida_idd
import ida_idp
import ida_kernwin
import ida_loader
import ida_nalt
import ida_name
import ida_netnode
import ida_segment
import ida_strlist
import ida_struct
import ida_ua
import ida_xref

import idc
import types
import os
import sys

def refs(ea, funcfirst, funcnext):
    """
    Generic reference collector - INTERNAL USE ONLY.
    """
    ref = funcfirst(ea)
    while ref != ida_idaapi.BADADDR:
        yield ref
        ref = funcnext(ea, ref)


def CodeRefsTo(ea, flow):
    """
    Get a list of code references to 'ea'

    @param ea:   Target address
    @param flow: Follow normal code flow or not
    @type  flow: Boolean (0/1, False/True)

    @return: list of references (may be empty list)

    Example::

        for ref in CodeRefsTo(get_screen_ea(), 1):
            print(ref)
    """
    if flow == 1:
        return refs(ea, ida_xref.get_first_cref_to, ida_xref.get_next_cref_to)
    else:
        return refs(ea, ida_xref.get_first_fcref_to, ida_xref.get_next_fcref_to)


def CodeRefsFrom(ea, flow):
    """
    Get a list of code references from 'ea'

    @param ea:   Target address
    @param flow: Follow normal code flow or not
    @type  flow: Boolean (0/1, False/True)

    @return: list of references (may be empty list)

    Example::

        for ref in CodeRefsFrom(get_screen_ea(), 1):
            print(ref)
    """
    if flow == 1:
        return refs(ea, ida_xref.get_first_cref_from, ida_xref.get_next_cref_from)
    else:
        return refs(ea, ida_xref.get_first_fcref_from, ida_xref.get_next_fcref_from)


def DataRefsTo(ea):
    """
    Get a list of data references to 'ea'

    @param ea:   Target address

    @return: list of references (may be empty list)

    Example::

        for ref in DataRefsTo(get_screen_ea()):
            print(ref)
    """
    return refs(ea, ida_xref.get_first_dref_to, ida_xref.get_next_dref_to)


def DataRefsFrom(ea):
    """
    Get a list of data references from 'ea'

    @param ea:   Target address

    @return: list of references (may be empty list)

    Example::

        for ref in DataRefsFrom(get_screen_ea()):
            print(ref)
    """
    return refs(ea, ida_xref.get_first_dref_from, ida_xref.get_next_dref_from)


# Xref type names table
_ref_types = {
    ida_xref.fl_U  : 'Data_Unknown',
    ida_xref.dr_O  : 'Data_Offset',
    ida_xref.dr_W  : 'Data_Write',
    ida_xref.dr_R  : 'Data_Read',
    ida_xref.dr_T  : 'Data_Text',
    ida_xref.dr_I  : 'Data_Informational',
    ida_xref.fl_CF : 'Code_Far_Call',
    ida_xref.fl_CN : 'Code_Near_Call',
    ida_xref.fl_JF : 'Code_Far_Jump',
    ida_xref.fl_JN : 'Code_Near_Jump',
    20 : 'Code_User',
    ida_xref.fl_F : 'Ordinary_Flow'
}

def XrefTypeName(typecode):
    """
    Convert cross-reference type codes to readable names

    @param typecode: cross-reference type code
    """
    assert typecode in _ref_types, "unknown reference type %d" % typecode
    return _ref_types[typecode]

def _copy_xref(xref):
    """ Make a private copy of the xref class to preserve its contents """
    class _xref(object):
        pass

    xr = _xref()
    for attr in [ 'frm', 'to', 'iscode', 'type', 'user' ]:
        setattr(xr, attr, getattr(xref, attr))
    return xr


def XrefsFrom(ea, flags=0):
    """
    Return all references from address 'ea'

    @param ea: Reference address
    @param flags: one of ida_xref.XREF_ALL (default), ida_xref.XREF_FAR, ida_xref.XREF_DATA

    Example::
           for xref in XrefsFrom(here(), 0):
               print(xref.type, XrefTypeName(xref.type), \
                         'from', hex(xref.frm), 'to', hex(xref.to))
    """
    xref = ida_xref.xrefblk_t()
    if xref.first_from(ea, flags):
        yield _copy_xref(xref)
        while xref.next_from():
            yield _copy_xref(xref)


def XrefsTo(ea, flags=0):
    """
    Return all references to address 'ea'

    @param ea: Reference address
    @param flags: one of ida_xref.XREF_ALL (default), ida_xref.XREF_FAR, ida_xref.XREF_DATA

    Example::
           for xref in XrefsTo(here(), 0):
               print(xref.type, XrefTypeName(xref.type), \
                         'from', hex(xref.frm), 'to', hex(xref.to))
    """
    xref = ida_xref.xrefblk_t()
    if xref.first_to(ea, flags):
        yield _copy_xref(xref)
        while xref.next_to():
            yield _copy_xref(xref)


def Threads():
    """Returns all thread IDs for the current debugee"""
    for i in range(0, idc.get_thread_qty()):
        yield idc.getn_thread(i)


def Heads(start=None, end=None):
    """
    Get a list of heads (instructions or data items)

    @param start: start address (default: inf.min_ea)
    @param end:   end address (default: inf.max_ea)

    @return: list of heads between start and end
    """
    if start is None: start = ida_ida.cvar.inf.min_ea
    if end is None:   end = ida_ida.cvar.inf.max_ea

    ea = start
    if not idc.is_head(ida_bytes.get_flags(ea)):
        ea = ida_bytes.next_head(ea, end)
    while ea &lt; end and ea != ida_idaapi.BADADDR:
        yield ea
        ea = ida_bytes.next_head(ea, end)


def Functions(start=None, end=None):
    """
    Get a list of functions

    @param start: start address (default: inf.min_ea)
    @param end:   end address (default: inf.max_ea)

    @return: list of function entrypoints between start and end

    @note: The last function that starts before 'end' is included even
    if it extends beyond 'end'. Any function that has its chunks scattered
    in multiple segments will be reported multiple times, once in each segment
    as they are listed.
    """
    if start is None: start = ida_ida.cvar.inf.min_ea
    if end is None:   end = ida_ida.cvar.inf.max_ea

    # find first function head chunk in the range
    chunk = ida_funcs.get_fchunk(start)
    if not chunk:
        chunk = ida_funcs.get_next_fchunk(start)
    while chunk and chunk.start_ea &lt; end and (chunk.flags &amp; ida_funcs.FUNC_TAIL) != 0:
        chunk = ida_funcs.get_next_fchunk(chunk.start_ea)
    func = chunk

    while func and func.start_ea &lt; end:
        startea = func.start_ea
        yield startea
        func = ida_funcs.get_next_func(startea)


def Chunks(start):
    """
    Get a list of function chunks

    @param start: address of the function

    @return: list of funcion chunks (tuples of the form (start_ea, end_ea))
             belonging to the function
    """
    func_iter = ida_funcs.func_tail_iterator_t( ida_funcs.get_func( start ) )
    status = func_iter.main()
    while status:
        chunk = func_iter.chunk()
        yield (chunk.start_ea, chunk.end_ea)
        status = next(func_iter)


def Modules():
    """
    Returns a list of module objects with name,size,base and the rebase_to attributes
    """
    mod = ida_idd.modinfo_t()
    result = ida_dbg.get_first_module(mod)
    while result:
        yield ida_idaapi.object_t(name=mod.name, size=mod.size, base=mod.base, rebase_to=mod.rebase_to)
        result = ida_dbg.get_next_module(mod)


def Names():
    """
    Returns a list of names

    @return: List of tuples (ea, name)
    """
    for i in range(ida_name.get_nlist_size()):
        ea   = ida_name.get_nlist_ea(i)
        name = ida_name.get_nlist_name(i)
        yield (ea, name)


def Segments():
    """
    Get list of segments (sections) in the binary image

    @return: List of segment start addresses.
    """
    for n in range(ida_segment.get_segm_qty()):
        seg = ida_segment.getnseg(n)
        if seg:
            yield seg.start_ea


def Entries():
    """
    Returns a list of entry points (exports)

    @return: List of tuples (index, ordinal, ea, name)
    """
    n = ida_entry.get_entry_qty()
    for i in range(0, n):
        ordinal = ida_entry.get_entry_ordinal(i)
        ea      = ida_entry.get_entry(ordinal)
        name    = ida_entry.get_entry_name(ordinal)
        yield (i, ordinal, ea, name)


def FuncItems(start):
    """
    Get a list of function items (instruction or data items inside function boundaries)

    @param start: address of the function

    @return: ea of each item in the function
    """
    func = ida_funcs.get_func(start)
    if not func:
        return
    fii = ida_funcs.func_item_iterator_t()
    ok = fii.set(func)
    while ok:
        yield fii.current()
        ok = fii.next_code()


def Structs():
    """
    Get a list of structures

    @return: List of tuples (idx, sid, name)
    """
    idx  = idc.get_first_struc_idx()
    while idx != ida_idaapi.BADADDR:
        sid = idc.get_struc_by_idx(idx)
        yield (idx, sid, idc.get_struc_name(sid))
        idx = idc.get_next_struc_idx(idx)


def StructMembers(sid):
    """
    Get a list of structure members information (or stack vars if given a frame).

    @param sid: ID of the structure.

    @return: List of tuples (offset, name, size)

    @note: If 'sid' does not refer to a valid structure,
           an exception will be raised.
    @note: This will not return 'holes' in structures/stack frames;
           it only returns defined structure members.
    """
    sptr = ida_struct.get_struc(sid)
    if sptr is None:
        raise Exception("No structure with ID: 0x%x" % sid)
    for m in sptr.members:
        name = idc.get_member_name(sid, m.soff)
        if name:
            size = ida_struct.get_member_size(m)
            yield (m.soff, name, size)


def DecodePrecedingInstruction(ea):
    """
    Decode preceding instruction in the execution flow.

    @param ea: address to decode
    @return: (None or the decode instruction, farref)
             farref will contain 'true' if followed an xref, false otherwise
    """
    insn = ida_ua.insn_t()
    prev_addr, farref  = ida_ua.decode_preceding_insn(insn, ea)
    return (insn, farref) if prev_addr != ida_idaapi.BADADDR else (None, False)


def DecodePreviousInstruction(ea):
    """
    Decodes the previous instruction and returns an insn_t like class

    @param ea: address to decode
    @return: None or a new insn_t instance
    """
    insn = ida_ua.insn_t()
    prev_addr = ida_ua.decode_prev_insn(insn, ea)
    return insn if prev_addr != ida_idaapi.BADADDR else None


def DecodeInstruction(ea):
    """
    Decodes an instruction and returns an insn_t like class

    @param ea: address to decode
    @return: None or a new insn_t instance
    """
    insn = ida_ua.insn_t()
    inslen = ida_ua.decode_insn(insn, ea)
    return insn if inslen &gt; 0 else None


def GetDataList(ea, count, itemsize=1):
    """
    Get data list - INTERNAL USE ONLY
    """
    if itemsize == 1:
        getdata = ida_bytes.get_byte
    elif itemsize == 2:
        getdata = ida_bytes.get_word
    elif itemsize == 4:
        getdata = ida_bytes.get_dword
    elif itemsize == 8:
        getdata = ida_bytes.get_qword
    else:
        raise ValueError("Invalid data size! Must be 1, 2, 4 or 8")

    endea = ea + itemsize * count
    curea = ea
    while curea &lt; endea:
        yield getdata(curea)
        curea += itemsize


def PutDataList(ea, datalist, itemsize=1):
    """
    Put data list - INTERNAL USE ONLY
    """
    putdata = None

    if itemsize == 1:
        putdata = ida_bytes.patch_byte
    if itemsize == 2:
        putdata = ida_bytes.patch_word
    if itemsize == 4:
        putdata = ida_bytes.patch_dword

    assert putdata, "Invalid data size! Must be 1, 2 or 4"

    for val in datalist:
        putdata(ea, val)
        ea = ea + itemsize


def MapDataList(ea, length, func, wordsize=1):
    """
    Map through a list of data words in the database

    @param ea:       start address
    @param length:   number of words to map
    @param func:     mapping function
    @param wordsize: size of words to map [default: 1 byte]

    @return: None
    """
    PutDataList(ea, map(func, GetDataList(ea, length, wordsize)), wordsize)


def GetInputFileMD5():
    """
    Return the MD5 hash of the input binary file

    @return: MD5 string or None on error
    """
    return idc.retrieve_input_file_md5()


class Strings(object):
    """
    Allows iterating over the string list. The set of strings will not be
    modified, unless asked explicitly at setup()-time. This string list also
    is used by the "String window" so it may be changed when this window is
    updated.

    Example:
        s = Strings()

        for i in s:
            print("%x: len=%d type=%d -&gt; '%s'" % (i.ea, i.length, i.strtype, str(i)))

    """
    class StringItem(object):
        """
        Class representing each string item.
        """
        def __init__(self, si):
            self.ea = si.ea
            """String ea"""
            self.strtype = si.type
            """string type (STRTYPE_xxxxx)"""
            self.length = si.length
            """string length"""

        def is_1_byte_encoding(self):
            return ida_nalt.get_strtype_bpu(self.strtype) == 1

        def _toseq(self, as_unicode):
            strbytes = ida_bytes.get_strlit_contents(self.ea, self.length, self.strtype)
            if sys.version_info.major &gt;= 3:
                return strbytes.decode("UTF-8", "replace") if as_unicode else strbytes
            else:
                return unicode(strbytes, "UTF-8", 'replace') if as_unicode else strbytes

        def __str__(self):
            return self._toseq(False if sys.version_info.major &lt; 3 else True)

        def __unicode__(self):
            return self._toseq(True)

    def clear_cache(self):
        """Clears the string list cache"""
        ida_strlist.clear_strlist()

    def __init__(self, default_setup = False):
        """
        Initializes the Strings enumeration helper class

        @param default_setup: Set to True to use default setup (C strings, min len 5, ...)
        """
        self.size = 0
        if default_setup:
            self.setup()
        else:
            # restore saved options
            ida_strlist.get_strlist_options()
        self.refresh()

        self._si = ida_strlist.string_info_t()


    def refresh(self):
        """Refreshes the string list"""
        ida_strlist.build_strlist()
        self.size = ida_strlist.get_strlist_qty()


    def setup(self,
              strtypes = [ida_nalt.STRTYPE_C],
              minlen = 5,
              only_7bit = True,
              ignore_instructions = False,
              display_only_existing_strings = False):

        t = ida_strlist.get_strlist_options()
        t.strtypes = strtypes
        t.minlen = minlen
        t.only_7bit = only_7bit
        t.display_only_existing_strings = display_only_existing_strings
        t.ignore_heads = ignore_instructions
        self.refresh()


    def _get_item(self, index):
        if not ida_strlist.get_strlist_item(self._si, index):
            return None
        return Strings.StringItem(self._si)


    def __iter__(self):
        return (self._get_item(index) for index in range(0, self.size))


    def __getitem__(self, index):
        """Returns a string item or None"""
        if index &gt;= self.size:
            raise KeyError
        else:
            return self._get_item(index)

# -----------------------------------------------------------------------
def GetIdbDir():
    """
    Get IDB directory

    This function returns directory path of the current IDB database
    """
    return os.path.dirname(ida_loader.get_path(ida_loader.PATH_TYPE_IDB)) + os.sep

# -----------------------------------------------------------------------
def GetRegisterList():
    """Returns the register list"""
    return ida_idp.ph_get_regnames()

# -----------------------------------------------------------------------
def GetInstructionList():
    """Returns the instruction list of the current processor module"""
    return [i[0] for i in ida_idp.ph_get_instruc() if i[0]]

# -----------------------------------------------------------------------
def _Assemble(ea, line):
    """
    Please refer to Assemble() - INTERNAL USE ONLY
    """
    if type(line) in ([bytes] + list(ida_idaapi.string_types)):
        lines = [line]
    else:
        lines = line
    ret = []
    for line in lines:
        seg = ida_segment.getseg(ea)
        if not seg:
            return (False, "No segment at ea")
        ip  = ea - (ida_segment.sel2para(seg.sel) &lt;&lt; 4)
        buf = ida_idp.AssembleLine(ea, seg.sel, ip, seg.bitness, line)
        if not buf:
            return (False, "Assembler failed: " + line)
        ea += len(buf)
        ret.append(buf)

    if len(ret) == 1:
        ret = ret[0]
    return (True, ret)


def Assemble(ea, line):
    """
    Assembles one or more lines (does not display an message dialogs)
    If line is a list then this function will attempt to assemble all the lines
    This function will turn on batch mode temporarily so that no messages are displayed on the screen

    @param ea:       start address
    @return: (False, "Error message") or (True, asm_buf) or (True, [asm_buf1, asm_buf2, asm_buf3])
    """
    old_batch = idc.batch(1)
    ret = _Assemble(ea, line)
    idc.batch(old_batch)
    return ret

def _copy_obj(src, dest, skip_list = None):
    """
    Copy non private/non callable attributes from a class instance to another
    @param src: Source class to copy from
    @param dest: If it is a string then it designates the new class type that will be created and copied to.
                 Otherwise dest should be an instance of another class
    @return: A new instance or "dest"
    """
    if type(dest) == bytes:
        # instantiate a new destination class of the specified type name?
        dest = new.classobj(dest, (), {})
    for x in dir(src):
        # skip special and private fields
        if x.startswith("__") and x.endswith("__"):
            continue
        # skip items in the skip list
        if skip_list and x in skip_list:
            continue
        t = getattr(src, x)
        # skip callable
        if callable(t):
            continue
        setattr(dest, x, t)
    return dest

# -----------------------------------------------------------------------
class _reg_dtyp_t(object):
    """
    INTERNAL
    This class describes a register's number and dtyp.
    The equal operator is overloaded so that two instances can be tested for equality
    """
    def __init__(self, reg, dtype):
        self.reg = reg
        self.dtype = dtype

    def __eq__(self, other):
        return (self.reg == other.reg) and (self.dtype == other.dtype)

# -----------------------------------------------------------------------
class _procregs(object):
    """Utility class allowing the users to identify registers in a decoded instruction"""
    def __getattr__(self, attr):
        ri = ida_idp.reg_info_t()
        if not ida_idp.parse_reg_name(ri, attr):
            raise AttributeError()
        r = _reg_dtyp_t(ri.reg, ida_ua.get_dtype_by_size(ri.size))
        self.__dict__[attr] = r
        return r

    def __setattr__(self, attr, value):
        raise AttributeError(attr)


# -----------------------------------------------------------------------
class _cpu(object):
    "Simple wrapper around get_reg_value/set_reg_value"
    # def __getattr__(self, name):
    #     return idc.get_reg_value(name)

    # def __setattr__(self, name, value):
    #     return idc.set_reg_value(value, name)


# --------------------------------------------------------------------------
class __process_ui_actions_helper(object):
    def __init__(self, actions, flags = 0):
        """Expect a list or a string with a list of actions"""
        if isinstance(actions, str):
            lst = actions.split(";")
        elif isinstance(actions, (list, tuple)):
            lst = actions
        else:
            raise ValueError("Must pass a string, list or a tuple")

        # Remember the action list and the flags
        self.__action_list = lst
        self.__flags = flags

        # Reset action index
        self.__idx = 0

    def __len__(self):
        return len(self.__action_list)

    def __call__(self):
        if self.__idx &gt;= len(self.__action_list):
            return False

        # Execute one action
        ida_kernwin.process_ui_action(
                self.__action_list[self.__idx],
                self.__flags)

        # Move to next action
        self.__idx += 1

        # Reschedule
        return True


# --------------------------------------------------------------------------
def ProcessUiActions(actions, flags=0):
    """
    @param actions: A string containing a list of actions separated by semicolon, a list or a tuple
    @param flags: flags to be passed to process_ui_action()
    @return: Boolean. Returns False if the action list was empty or execute_ui_requests() failed.
    """

    # Instantiate a helper
    helper = __process_ui_actions_helper(actions, flags)
    return False if len(helper) &lt; 1 else ida_kernwin.execute_ui_requests((helper,))


# -----------------------------------------------------------------------
class peutils_t(object):
    """
    PE utility class. Retrieves PE information from the database.

    Constants from pe.h
    """
    PE_NODE = "$ PE header" # netnode name for PE header
    PE_ALT_DBG_FPOS   = ida_idaapi.BADADDR &amp; -1 #  altval() -&gt; translated fpos of debuginfo
    PE_ALT_IMAGEBASE  = ida_idaapi.BADADDR &amp; -2 #  altval() -&gt; loading address (usually pe.imagebase)
    PE_ALT_PEHDR_OFF  = ida_idaapi.BADADDR &amp; -3 #  altval() -&gt; offset of PE header
    PE_ALT_NEFLAGS    = ida_idaapi.BADADDR &amp; -4 #  altval() -&gt; neflags
    PE_ALT_TDS_LOADED = ida_idaapi.BADADDR &amp; -5 #  altval() -&gt; tds already loaded(1) or invalid(-1)
    PE_ALT_PSXDLL     = ida_idaapi.BADADDR &amp; -6 #  altval() -&gt; if POSIX(x86) imports from PSXDLL netnode

    def __init__(self):
        self.__penode = ida_netnode.netnode()
        self.__penode.create(peutils_t.PE_NODE)

    imagebase = property(
        lambda self: self.__penode.altval(peutils_t.PE_ALT_IMAGEBASE)
      )

    header = property(
        lambda self: self.__penode.altval(peutils_t.PE_ALT_PEHDR_OFF)
      )

    def __str__(self):
        return "peutils_t(imagebase=%s, header=%s)" % (hex(self.imagebase), hex(self.header))

    def header(self):
        """
        Returns the complete PE header as an instance of peheader_t (defined in the SDK).
        """
        return self.__penode.valobj()

# -----------------------------------------------------------------------
cpu = _cpu()
"""This is a special class instance used to access the registers as if they were attributes of this object.
For example to access the EAX register:
    print("%x" % cpu.Eax)
"""

procregs = _procregs()
"""This object is used to access the processor registers. It is useful when decoding instructions and you want to see which instruction is which.
For example:
    x = idautils.DecodeInstruction(here())
    if x[0] == procregs.Esp:
        print("This operand is the register ESP)
"""</gergely.erdelyi></code></pre>
</details>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="idautils.cpu"><code class="name">var <span class="ident">cpu</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
This is a special class instance used to access the registers as if they were attributes of this object.
For example to access the EAX register:<div class="epy_nested">
print("%x" % cpu.Eax)</div>
</div></div>
</dd>
<dt id="idautils.procregs"><code class="name">var <span class="ident">procregs</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
This object is used to access the processor registers. It is useful when decoding instructions and you want to see which instruction is which.
For example:<div class="epy_nested">
x = idautils.DecodeInstruction(here())
if x[0] == procregs.Esp:<div class="epy_nested">
print("This operand is the register ESP)</div>
</div>
</div></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="idautils.Assemble"><code class="name flex">
<span>def <span class="ident">Assemble</span></span>(<span>ea, line)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Assembles one or more lines (does not display an message dialogs)
If line is a list then this function will attempt to assemble all the lines
This function will turn on batch mode temporarily so that no messages are displayed on the screen</div>
<div class="epy_par">
<strong class="epy_parameter">ea</strong>:
start address</div>
<div class="epy_par">
<strong class="epy_tag">return</strong>: (False, "Error message") or (True, asm_buf) or (True, [asm_buf1, asm_buf2, asm_buf3])</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Assemble(ea, line):
    """
    Assembles one or more lines (does not display an message dialogs)
    If line is a list then this function will attempt to assemble all the lines
    This function will turn on batch mode temporarily so that no messages are displayed on the screen

    @param ea:       start address
    @return: (False, "Error message") or (True, asm_buf) or (True, [asm_buf1, asm_buf2, asm_buf3])
    """
    old_batch = idc.batch(1)
    ret = _Assemble(ea, line)
    idc.batch(old_batch)
    return ret</code></pre>
</details>
</dd>
<dt id="idautils.Chunks"><code class="name flex">
<span>def <span class="ident">Chunks</span></span>(<span>start)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get a list of function chunks</div>
<div class="epy_par">
<strong class="epy_parameter">start</strong>: address of the function</div>
<div class="epy_par">
<strong class="epy_tag">return</strong>: list of funcion chunks (tuples of the form (start_ea, end_ea))<div class="epy_nested">
belonging to the function</div>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Chunks(start):
    """
    Get a list of function chunks

    @param start: address of the function

    @return: list of funcion chunks (tuples of the form (start_ea, end_ea))
             belonging to the function
    """
    func_iter = ida_funcs.func_tail_iterator_t( ida_funcs.get_func( start ) )
    status = func_iter.main()
    while status:
        chunk = func_iter.chunk()
        yield (chunk.start_ea, chunk.end_ea)
        status = next(func_iter)</code></pre>
</details>
</dd>
<dt id="idautils.CodeRefsFrom"><code class="name flex">
<span>def <span class="ident">CodeRefsFrom</span></span>(<span>ea, flow)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get a list of code references from 'ea'</div>
<div class="epy_par">
<strong class="epy_parameter">ea</strong>:
Target address</div>
<div class="epy_par">
<strong class="epy_parameter">flow</strong>: Follow normal code flow or not</div>
<div class="epy_par">
<strong class="epy_tag">type</strong>
flow: Boolean (0/1, False/True)</div>
<div class="epy_par">
<strong class="epy_tag">return</strong>: list of references (may be empty list)</div>
<div class="epy_par">
Example::<div class="epy_nested">
for ref in CodeRefsFrom(get_screen_ea(), 1):</div>
</div>
<div class="epy_par">
<strong class="epy_sig">print(ref)</strong></div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def CodeRefsFrom(ea, flow):
    """
    Get a list of code references from 'ea'

    @param ea:   Target address
    @param flow: Follow normal code flow or not
    @type  flow: Boolean (0/1, False/True)

    @return: list of references (may be empty list)

    Example::

        for ref in CodeRefsFrom(get_screen_ea(), 1):
            print(ref)
    """
    if flow == 1:
        return refs(ea, ida_xref.get_first_cref_from, ida_xref.get_next_cref_from)
    else:
        return refs(ea, ida_xref.get_first_fcref_from, ida_xref.get_next_fcref_from)</code></pre>
</details>
</dd>
<dt id="idautils.CodeRefsTo"><code class="name flex">
<span>def <span class="ident">CodeRefsTo</span></span>(<span>ea, flow)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get a list of code references to 'ea'</div>
<div class="epy_par">
<strong class="epy_parameter">ea</strong>:
Target address</div>
<div class="epy_par">
<strong class="epy_parameter">flow</strong>: Follow normal code flow or not</div>
<div class="epy_par">
<strong class="epy_tag">type</strong>
flow: Boolean (0/1, False/True)</div>
<div class="epy_par">
<strong class="epy_tag">return</strong>: list of references (may be empty list)</div>
<div class="epy_par">
Example::<div class="epy_nested">
for ref in CodeRefsTo(get_screen_ea(), 1):</div>
</div>
<div class="epy_par">
<strong class="epy_sig">print(ref)</strong></div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def CodeRefsTo(ea, flow):
    """
    Get a list of code references to 'ea'

    @param ea:   Target address
    @param flow: Follow normal code flow or not
    @type  flow: Boolean (0/1, False/True)

    @return: list of references (may be empty list)

    Example::

        for ref in CodeRefsTo(get_screen_ea(), 1):
            print(ref)
    """
    if flow == 1:
        return refs(ea, ida_xref.get_first_cref_to, ida_xref.get_next_cref_to)
    else:
        return refs(ea, ida_xref.get_first_fcref_to, ida_xref.get_next_fcref_to)</code></pre>
</details>
</dd>
<dt id="idautils.DataRefsFrom"><code class="name flex">
<span>def <span class="ident">DataRefsFrom</span></span>(<span>ea)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get a list of data references from 'ea'</div>
<div class="epy_par">
<strong class="epy_parameter">ea</strong>:
Target address</div>
<div class="epy_par">
<strong class="epy_tag">return</strong>: list of references (may be empty list)</div>
<div class="epy_par">
Example::<div class="epy_nested">
for ref in DataRefsFrom(get_screen_ea()):</div>
</div>
<div class="epy_par">
<strong class="epy_sig">print(ref)</strong></div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def DataRefsFrom(ea):
    """
    Get a list of data references from 'ea'

    @param ea:   Target address

    @return: list of references (may be empty list)

    Example::

        for ref in DataRefsFrom(get_screen_ea()):
            print(ref)
    """
    return refs(ea, ida_xref.get_first_dref_from, ida_xref.get_next_dref_from)</code></pre>
</details>
</dd>
<dt id="idautils.DataRefsTo"><code class="name flex">
<span>def <span class="ident">DataRefsTo</span></span>(<span>ea)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get a list of data references to 'ea'</div>
<div class="epy_par">
<strong class="epy_parameter">ea</strong>:
Target address</div>
<div class="epy_par">
<strong class="epy_tag">return</strong>: list of references (may be empty list)</div>
<div class="epy_par">
Example::<div class="epy_nested">
for ref in DataRefsTo(get_screen_ea()):</div>
</div>
<div class="epy_par">
<strong class="epy_sig">print(ref)</strong></div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def DataRefsTo(ea):
    """
    Get a list of data references to 'ea'

    @param ea:   Target address

    @return: list of references (may be empty list)

    Example::

        for ref in DataRefsTo(get_screen_ea()):
            print(ref)
    """
    return refs(ea, ida_xref.get_first_dref_to, ida_xref.get_next_dref_to)</code></pre>
</details>
</dd>
<dt id="idautils.DecodeInstruction"><code class="name flex">
<span>def <span class="ident">DecodeInstruction</span></span>(<span>ea)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Decodes an instruction and returns an insn_t like class</div>
<div class="epy_par">
<strong class="epy_parameter">ea</strong>: address to decode</div>
<div class="epy_par">
<strong class="epy_tag">return</strong>: None or a new insn_t instance</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def DecodeInstruction(ea):
    """
    Decodes an instruction and returns an insn_t like class

    @param ea: address to decode
    @return: None or a new insn_t instance
    """
    insn = ida_ua.insn_t()
    inslen = ida_ua.decode_insn(insn, ea)
    return insn if inslen &gt; 0 else None</code></pre>
</details>
</dd>
<dt id="idautils.DecodePrecedingInstruction"><code class="name flex">
<span>def <span class="ident">DecodePrecedingInstruction</span></span>(<span>ea)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Decode preceding instruction in the execution flow.</div>
<div class="epy_par">
<strong class="epy_parameter">ea</strong>: address to decode</div>
<div class="epy_par">
<strong class="epy_tag">return</strong>: (None or the decode instruction, farref)<div class="epy_nested">
farref will contain 'true' if followed an xref, false otherwise</div>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def DecodePrecedingInstruction(ea):
    """
    Decode preceding instruction in the execution flow.

    @param ea: address to decode
    @return: (None or the decode instruction, farref)
             farref will contain 'true' if followed an xref, false otherwise
    """
    insn = ida_ua.insn_t()
    prev_addr, farref  = ida_ua.decode_preceding_insn(insn, ea)
    return (insn, farref) if prev_addr != ida_idaapi.BADADDR else (None, False)</code></pre>
</details>
</dd>
<dt id="idautils.DecodePreviousInstruction"><code class="name flex">
<span>def <span class="ident">DecodePreviousInstruction</span></span>(<span>ea)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Decodes the previous instruction and returns an insn_t like class</div>
<div class="epy_par">
<strong class="epy_parameter">ea</strong>: address to decode</div>
<div class="epy_par">
<strong class="epy_tag">return</strong>: None or a new insn_t instance</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def DecodePreviousInstruction(ea):
    """
    Decodes the previous instruction and returns an insn_t like class

    @param ea: address to decode
    @return: None or a new insn_t instance
    """
    insn = ida_ua.insn_t()
    prev_addr = ida_ua.decode_prev_insn(insn, ea)
    return insn if prev_addr != ida_idaapi.BADADDR else None</code></pre>
</details>
</dd>
<dt id="idautils.Entries"><code class="name flex">
<span>def <span class="ident">Entries</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Returns a list of entry points (exports)</div>
<div class="epy_par">
<strong class="epy_tag">return</strong>: List of tuples (index, ordinal, ea, name)</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Entries():
    """
    Returns a list of entry points (exports)

    @return: List of tuples (index, ordinal, ea, name)
    """
    n = ida_entry.get_entry_qty()
    for i in range(0, n):
        ordinal = ida_entry.get_entry_ordinal(i)
        ea      = ida_entry.get_entry(ordinal)
        name    = ida_entry.get_entry_name(ordinal)
        yield (i, ordinal, ea, name)</code></pre>
</details>
</dd>
<dt id="idautils.FuncItems"><code class="name flex">
<span>def <span class="ident">FuncItems</span></span>(<span>start)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get a list of function items (instruction or data items inside function boundaries)</div>
<div class="epy_par">
<strong class="epy_parameter">start</strong>: address of the function</div>
<div class="epy_par">
<strong class="epy_tag">return</strong>: ea of each item in the function</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def FuncItems(start):
    """
    Get a list of function items (instruction or data items inside function boundaries)

    @param start: address of the function

    @return: ea of each item in the function
    """
    func = ida_funcs.get_func(start)
    if not func:
        return
    fii = ida_funcs.func_item_iterator_t()
    ok = fii.set(func)
    while ok:
        yield fii.current()
        ok = fii.next_code()</code></pre>
</details>
</dd>
<dt id="idautils.Functions"><code class="name flex">
<span>def <span class="ident">Functions</span></span>(<span>start=None, end=None)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get a list of functions</div>
<div class="epy_par">
<strong class="epy_parameter">start</strong>: start address (default: inf.min_ea)</div>
<div class="epy_par">
<strong class="epy_parameter">end</strong>:
end address (default: inf.max_ea)</div>
<div class="epy_par">
<strong class="epy_tag">return</strong>: list of function entrypoints between start and end</div>
<div class="epy_par">
<strong class="epy_tag">note</strong>: The last function that starts before 'end' is included even
if it extends beyond 'end'. Any function that has its chunks scattered
in multiple segments will be reported multiple times, once in each segment
as they are listed.</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Functions(start=None, end=None):
    """
    Get a list of functions

    @param start: start address (default: inf.min_ea)
    @param end:   end address (default: inf.max_ea)

    @return: list of function entrypoints between start and end

    @note: The last function that starts before 'end' is included even
    if it extends beyond 'end'. Any function that has its chunks scattered
    in multiple segments will be reported multiple times, once in each segment
    as they are listed.
    """
    if start is None: start = ida_ida.cvar.inf.min_ea
    if end is None:   end = ida_ida.cvar.inf.max_ea

    # find first function head chunk in the range
    chunk = ida_funcs.get_fchunk(start)
    if not chunk:
        chunk = ida_funcs.get_next_fchunk(start)
    while chunk and chunk.start_ea &lt; end and (chunk.flags &amp; ida_funcs.FUNC_TAIL) != 0:
        chunk = ida_funcs.get_next_fchunk(chunk.start_ea)
    func = chunk

    while func and func.start_ea &lt; end:
        startea = func.start_ea
        yield startea
        func = ida_funcs.get_next_func(startea)</code></pre>
</details>
</dd>
<dt id="idautils.GetDataList"><code class="name flex">
<span>def <span class="ident">GetDataList</span></span>(<span>ea, count, itemsize=1)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get data list - INTERNAL USE ONLY</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetDataList(ea, count, itemsize=1):
    """
    Get data list - INTERNAL USE ONLY
    """
    if itemsize == 1:
        getdata = ida_bytes.get_byte
    elif itemsize == 2:
        getdata = ida_bytes.get_word
    elif itemsize == 4:
        getdata = ida_bytes.get_dword
    elif itemsize == 8:
        getdata = ida_bytes.get_qword
    else:
        raise ValueError("Invalid data size! Must be 1, 2, 4 or 8")

    endea = ea + itemsize * count
    curea = ea
    while curea &lt; endea:
        yield getdata(curea)
        curea += itemsize</code></pre>
</details>
</dd>
<dt id="idautils.GetIdbDir"><code class="name flex">
<span>def <span class="ident">GetIdbDir</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get IDB directory</div>
<div class="epy_par">
This function returns directory path of the current IDB database</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetIdbDir():
    """
    Get IDB directory

    This function returns directory path of the current IDB database
    """
    return os.path.dirname(ida_loader.get_path(ida_loader.PATH_TYPE_IDB)) + os.sep</code></pre>
</details>
</dd>
<dt id="idautils.GetInputFileMD5"><code class="name flex">
<span>def <span class="ident">GetInputFileMD5</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Return the MD5 hash of the input binary file</div>
<div class="epy_par">
<strong class="epy_tag">return</strong>: MD5 string or None on error</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetInputFileMD5():
    """
    Return the MD5 hash of the input binary file

    @return: MD5 string or None on error
    """
    return idc.retrieve_input_file_md5()</code></pre>
</details>
</dd>
<dt id="idautils.GetInstructionList"><code class="name flex">
<span>def <span class="ident">GetInstructionList</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Returns the instruction list of the current processor module</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetInstructionList():
    """Returns the instruction list of the current processor module"""
    return [i[0] for i in ida_idp.ph_get_instruc() if i[0]]</code></pre>
</details>
</dd>
<dt id="idautils.GetRegisterList"><code class="name flex">
<span>def <span class="ident">GetRegisterList</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Returns the register list</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetRegisterList():
    """Returns the register list"""
    return ida_idp.ph_get_regnames()</code></pre>
</details>
</dd>
<dt id="idautils.Heads"><code class="name flex">
<span>def <span class="ident">Heads</span></span>(<span>start=None, end=None)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get a list of heads (instructions or data items)</div>
<div class="epy_par">
<strong class="epy_parameter">start</strong>: start address (default: inf.min_ea)</div>
<div class="epy_par">
<strong class="epy_parameter">end</strong>:
end address (default: inf.max_ea)</div>
<div class="epy_par">
<strong class="epy_tag">return</strong>: list of heads between start and end</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Heads(start=None, end=None):
    """
    Get a list of heads (instructions or data items)

    @param start: start address (default: inf.min_ea)
    @param end:   end address (default: inf.max_ea)

    @return: list of heads between start and end
    """
    if start is None: start = ida_ida.cvar.inf.min_ea
    if end is None:   end = ida_ida.cvar.inf.max_ea

    ea = start
    if not idc.is_head(ida_bytes.get_flags(ea)):
        ea = ida_bytes.next_head(ea, end)
    while ea &lt; end and ea != ida_idaapi.BADADDR:
        yield ea
        ea = ida_bytes.next_head(ea, end)</code></pre>
</details>
</dd>
<dt id="idautils.MapDataList"><code class="name flex">
<span>def <span class="ident">MapDataList</span></span>(<span>ea, length, func, wordsize=1)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Map through a list of data words in the database</div>
<div class="epy_par">
<strong class="epy_parameter">ea</strong>:
start address</div>
<div class="epy_par">
<strong class="epy_parameter">length</strong>:
number of words to map</div>
<div class="epy_par">
<strong class="epy_parameter">func</strong>:
mapping function</div>
<div class="epy_par">
<strong class="epy_parameter">wordsize</strong>: size of words to map [default: 1 byte]</div>
<div class="epy_par">
<strong class="epy_tag">return</strong>: None</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def MapDataList(ea, length, func, wordsize=1):
    """
    Map through a list of data words in the database

    @param ea:       start address
    @param length:   number of words to map
    @param func:     mapping function
    @param wordsize: size of words to map [default: 1 byte]

    @return: None
    """
    PutDataList(ea, map(func, GetDataList(ea, length, wordsize)), wordsize)</code></pre>
</details>
</dd>
<dt id="idautils.Modules"><code class="name flex">
<span>def <span class="ident">Modules</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Returns a list of module objects with name,size,base and the rebase_to attributes</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Modules():
    """
    Returns a list of module objects with name,size,base and the rebase_to attributes
    """
    mod = ida_idd.modinfo_t()
    result = ida_dbg.get_first_module(mod)
    while result:
        yield ida_idaapi.object_t(name=mod.name, size=mod.size, base=mod.base, rebase_to=mod.rebase_to)
        result = ida_dbg.get_next_module(mod)</code></pre>
</details>
</dd>
<dt id="idautils.Names"><code class="name flex">
<span>def <span class="ident">Names</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Returns a list of names</div>
<div class="epy_par">
<strong class="epy_tag">return</strong>: List of tuples (ea, name)</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Names():
    """
    Returns a list of names

    @return: List of tuples (ea, name)
    """
    for i in range(ida_name.get_nlist_size()):
        ea   = ida_name.get_nlist_ea(i)
        name = ida_name.get_nlist_name(i)
        yield (ea, name)</code></pre>
</details>
</dd>
<dt id="idautils.ProcessUiActions"><code class="name flex">
<span>def <span class="ident">ProcessUiActions</span></span>(<span>actions, flags=0)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_parameter">actions</strong>: A string containing a list of actions separated by semicolon, a list or a tuple</div>
<div class="epy_par">
<strong class="epy_parameter">flags</strong>: flags to be passed to process_ui_action()</div>
<div class="epy_par">
<strong class="epy_tag">return</strong>: Boolean. Returns False if the action list was empty or execute_ui_requests() failed.</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ProcessUiActions(actions, flags=0):
    """
    @param actions: A string containing a list of actions separated by semicolon, a list or a tuple
    @param flags: flags to be passed to process_ui_action()
    @return: Boolean. Returns False if the action list was empty or execute_ui_requests() failed.
    """

    # Instantiate a helper
    helper = __process_ui_actions_helper(actions, flags)
    return False if len(helper) &lt; 1 else ida_kernwin.execute_ui_requests((helper,))</code></pre>
</details>
</dd>
<dt id="idautils.PutDataList"><code class="name flex">
<span>def <span class="ident">PutDataList</span></span>(<span>ea, datalist, itemsize=1)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Put data list - INTERNAL USE ONLY</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def PutDataList(ea, datalist, itemsize=1):
    """
    Put data list - INTERNAL USE ONLY
    """
    putdata = None

    if itemsize == 1:
        putdata = ida_bytes.patch_byte
    if itemsize == 2:
        putdata = ida_bytes.patch_word
    if itemsize == 4:
        putdata = ida_bytes.patch_dword

    assert putdata, "Invalid data size! Must be 1, 2 or 4"

    for val in datalist:
        putdata(ea, val)
        ea = ea + itemsize</code></pre>
</details>
</dd>
<dt id="idautils.Segments"><code class="name flex">
<span>def <span class="ident">Segments</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get list of segments (sections) in the binary image</div>
<div class="epy_par">
<strong class="epy_tag">return</strong>: List of segment start addresses.</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Segments():
    """
    Get list of segments (sections) in the binary image

    @return: List of segment start addresses.
    """
    for n in range(ida_segment.get_segm_qty()):
        seg = ida_segment.getnseg(n)
        if seg:
            yield seg.start_ea</code></pre>
</details>
</dd>
<dt id="idautils.StructMembers"><code class="name flex">
<span>def <span class="ident">StructMembers</span></span>(<span>sid)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get a list of structure members information (or stack vars if given a frame).</div>
<div class="epy_par">
<strong class="epy_parameter">sid</strong>: ID of the structure.</div>
<div class="epy_par">
<strong class="epy_tag">return</strong>: List of tuples (offset, name, size)</div>
<div class="epy_par">
<strong class="epy_tag">note</strong>: If 'sid' does not refer to a valid structure,<div class="epy_nested">
an exception will be raised.</div>
</div>
<div class="epy_par">
<strong class="epy_tag">note</strong>: This will not return 'holes' in structures/stack frames;<div class="epy_nested">
it only returns defined structure members.</div>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def StructMembers(sid):
    """
    Get a list of structure members information (or stack vars if given a frame).

    @param sid: ID of the structure.

    @return: List of tuples (offset, name, size)

    @note: If 'sid' does not refer to a valid structure,
           an exception will be raised.
    @note: This will not return 'holes' in structures/stack frames;
           it only returns defined structure members.
    """
    sptr = ida_struct.get_struc(sid)
    if sptr is None:
        raise Exception("No structure with ID: 0x%x" % sid)
    for m in sptr.members:
        name = idc.get_member_name(sid, m.soff)
        if name:
            size = ida_struct.get_member_size(m)
            yield (m.soff, name, size)</code></pre>
</details>
</dd>
<dt id="idautils.Structs"><code class="name flex">
<span>def <span class="ident">Structs</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get a list of structures</div>
<div class="epy_par">
<strong class="epy_tag">return</strong>: List of tuples (idx, sid, name)</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Structs():
    """
    Get a list of structures

    @return: List of tuples (idx, sid, name)
    """
    idx  = idc.get_first_struc_idx()
    while idx != ida_idaapi.BADADDR:
        sid = idc.get_struc_by_idx(idx)
        yield (idx, sid, idc.get_struc_name(sid))
        idx = idc.get_next_struc_idx(idx)</code></pre>
</details>
</dd>
<dt id="idautils.Threads"><code class="name flex">
<span>def <span class="ident">Threads</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Returns all thread IDs for the current debugee</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Threads():
    """Returns all thread IDs for the current debugee"""
    for i in range(0, idc.get_thread_qty()):
        yield idc.getn_thread(i)</code></pre>
</details>
</dd>
<dt id="idautils.XrefTypeName"><code class="name flex">
<span>def <span class="ident">XrefTypeName</span></span>(<span>typecode)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Convert cross-reference type codes to readable names</div>
<div class="epy_par">
<strong class="epy_parameter">typecode</strong>: cross-reference type code</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def XrefTypeName(typecode):
    """
    Convert cross-reference type codes to readable names

    @param typecode: cross-reference type code
    """
    assert typecode in _ref_types, "unknown reference type %d" % typecode
    return _ref_types[typecode]</code></pre>
</details>
</dd>
<dt id="idautils.XrefsFrom"><code class="name flex">
<span>def <span class="ident">XrefsFrom</span></span>(<span>ea, flags=0)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Return all references from address 'ea'</div>
<div class="epy_par">
<strong class="epy_parameter">ea</strong>: Reference address</div>
<div class="epy_par">
<strong class="epy_parameter">flags</strong>: one of ida_xref.XREF_ALL (default), ida_xref.XREF_FAR, ida_xref.XREF_DATA</div>
<div class="epy_par">
Example::<div class="epy_nested">
for xref in XrefsFrom(here(), 0):<div class="epy_nested">
print(xref.type, XrefTypeName(xref.type),
'from', hex(xref.frm), 'to', hex(xref.to))</div>
</div>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def XrefsFrom(ea, flags=0):
    """
    Return all references from address 'ea'

    @param ea: Reference address
    @param flags: one of ida_xref.XREF_ALL (default), ida_xref.XREF_FAR, ida_xref.XREF_DATA

    Example::
           for xref in XrefsFrom(here(), 0):
               print(xref.type, XrefTypeName(xref.type), \
                         'from', hex(xref.frm), 'to', hex(xref.to))
    """
    xref = ida_xref.xrefblk_t()
    if xref.first_from(ea, flags):
        yield _copy_xref(xref)
        while xref.next_from():
            yield _copy_xref(xref)</code></pre>
</details>
</dd>
<dt id="idautils.XrefsTo"><code class="name flex">
<span>def <span class="ident">XrefsTo</span></span>(<span>ea, flags=0)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Return all references to address 'ea'</div>
<div class="epy_par">
<strong class="epy_parameter">ea</strong>: Reference address</div>
<div class="epy_par">
<strong class="epy_parameter">flags</strong>: one of ida_xref.XREF_ALL (default), ida_xref.XREF_FAR, ida_xref.XREF_DATA</div>
<div class="epy_par">
Example::<div class="epy_nested">
for xref in XrefsTo(here(), 0):<div class="epy_nested">
print(xref.type, XrefTypeName(xref.type),
'from', hex(xref.frm), 'to', hex(xref.to))</div>
</div>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def XrefsTo(ea, flags=0):
    """
    Return all references to address 'ea'

    @param ea: Reference address
    @param flags: one of ida_xref.XREF_ALL (default), ida_xref.XREF_FAR, ida_xref.XREF_DATA

    Example::
           for xref in XrefsTo(here(), 0):
               print(xref.type, XrefTypeName(xref.type), \
                         'from', hex(xref.frm), 'to', hex(xref.to))
    """
    xref = ida_xref.xrefblk_t()
    if xref.first_to(ea, flags):
        yield _copy_xref(xref)
        while xref.next_to():
            yield _copy_xref(xref)</code></pre>
</details>
</dd>
<dt id="idautils.refs"><code class="name flex">
<span>def <span class="ident">refs</span></span>(<span>ea, funcfirst, funcnext)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Generic reference collector - INTERNAL USE ONLY.</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def refs(ea, funcfirst, funcnext):
    """
    Generic reference collector - INTERNAL USE ONLY.
    """
    ref = funcfirst(ea)
    while ref != ida_idaapi.BADADDR:
        yield ref
        ref = funcnext(ea, ref)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="idautils.Strings"><code class="flex name class">
<span>class <span class="ident">Strings</span></span>
<span>(</span><span>default_setup=False)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Allows iterating over the string list. The set of strings will not be
modified, unless asked explicitly at setup()-time. This string list also
is used by the "String window" so it may be changed when this window is
updated.</div>
<div class="epy_par">
Example:<div class="epy_nested">
s = Strings()</div>
<div class="epy_nested">
for i in s:<div class="epy_nested">
print("%x: len=%d type=%d -&gt; '%s'" % (i.ea, i.length, i.strtype, str(i)))</div>
</div>
</div>
<div class="epy_par">
Initializes the Strings enumeration helper class</div>
<div class="epy_par">
<strong class="epy_parameter">default_setup</strong>: Set to True to use default setup (C strings, min len 5, ...)</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Strings(object):
    """
    Allows iterating over the string list. The set of strings will not be
    modified, unless asked explicitly at setup()-time. This string list also
    is used by the "String window" so it may be changed when this window is
    updated.

    Example:
        s = Strings()

        for i in s:
            print("%x: len=%d type=%d -&gt; '%s'" % (i.ea, i.length, i.strtype, str(i)))

    """
    class StringItem(object):
        """
        Class representing each string item.
        """
        def __init__(self, si):
            self.ea = si.ea
            """String ea"""
            self.strtype = si.type
            """string type (STRTYPE_xxxxx)"""
            self.length = si.length
            """string length"""

        def is_1_byte_encoding(self):
            return ida_nalt.get_strtype_bpu(self.strtype) == 1

        def _toseq(self, as_unicode):
            strbytes = ida_bytes.get_strlit_contents(self.ea, self.length, self.strtype)
            if sys.version_info.major &gt;= 3:
                return strbytes.decode("UTF-8", "replace") if as_unicode else strbytes
            else:
                return unicode(strbytes, "UTF-8", 'replace') if as_unicode else strbytes

        def __str__(self):
            return self._toseq(False if sys.version_info.major &lt; 3 else True)

        def __unicode__(self):
            return self._toseq(True)

    def clear_cache(self):
        """Clears the string list cache"""
        ida_strlist.clear_strlist()

    def __init__(self, default_setup = False):
        """
        Initializes the Strings enumeration helper class

        @param default_setup: Set to True to use default setup (C strings, min len 5, ...)
        """
        self.size = 0
        if default_setup:
            self.setup()
        else:
            # restore saved options
            ida_strlist.get_strlist_options()
        self.refresh()

        self._si = ida_strlist.string_info_t()


    def refresh(self):
        """Refreshes the string list"""
        ida_strlist.build_strlist()
        self.size = ida_strlist.get_strlist_qty()


    def setup(self,
              strtypes = [ida_nalt.STRTYPE_C],
              minlen = 5,
              only_7bit = True,
              ignore_instructions = False,
              display_only_existing_strings = False):

        t = ida_strlist.get_strlist_options()
        t.strtypes = strtypes
        t.minlen = minlen
        t.only_7bit = only_7bit
        t.display_only_existing_strings = display_only_existing_strings
        t.ignore_heads = ignore_instructions
        self.refresh()


    def _get_item(self, index):
        if not ida_strlist.get_strlist_item(self._si, index):
            return None
        return Strings.StringItem(self._si)


    def __iter__(self):
        return (self._get_item(index) for index in range(0, self.size))


    def __getitem__(self, index):
        """Returns a string item or None"""
        if index &gt;= self.size:
            raise KeyError
        else:
            return self._get_item(index)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="idautils.Strings.StringItem"><code class="name">var <span class="ident">StringItem</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Class representing each string item.</div></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="idautils.Strings.clear_cache"><code class="name flex">
<span>def <span class="ident">clear_cache</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Clears the string list cache</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_cache(self):
    """Clears the string list cache"""
    ida_strlist.clear_strlist()</code></pre>
</details>
</dd>
<dt id="idautils.Strings.refresh"><code class="name flex">
<span>def <span class="ident">refresh</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Refreshes the string list</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def refresh(self):
    """Refreshes the string list"""
    ida_strlist.build_strlist()
    self.size = ida_strlist.get_strlist_qty()</code></pre>
</details>
</dd>
<dt id="idautils.Strings.setup"><code class="name flex">
<span>def <span class="ident">setup</span></span>(<span>self, strtypes=[0], minlen=5, only_7bit=True, ignore_instructions=False, display_only_existing_strings=False)</span>
</code></dt>
<dd>
<div class="desc"/>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup(self,
          strtypes = [ida_nalt.STRTYPE_C],
          minlen = 5,
          only_7bit = True,
          ignore_instructions = False,
          display_only_existing_strings = False):

    t = ida_strlist.get_strlist_options()
    t.strtypes = strtypes
    t.minlen = minlen
    t.only_7bit = only_7bit
    t.display_only_existing_strings = display_only_existing_strings
    t.ignore_heads = ignore_instructions
    self.refresh()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="idautils.peutils_t"><code class="flex name class">
<span>class <span class="ident">peutils_t</span></span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
PE utility class. Retrieves PE information from the database.</div>
<div class="epy_par">
Constants from pe.h</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class peutils_t(object):
    """
    PE utility class. Retrieves PE information from the database.

    Constants from pe.h
    """
    PE_NODE = "$ PE header" # netnode name for PE header
    PE_ALT_DBG_FPOS   = ida_idaapi.BADADDR &amp; -1 #  altval() -&gt; translated fpos of debuginfo
    PE_ALT_IMAGEBASE  = ida_idaapi.BADADDR &amp; -2 #  altval() -&gt; loading address (usually pe.imagebase)
    PE_ALT_PEHDR_OFF  = ida_idaapi.BADADDR &amp; -3 #  altval() -&gt; offset of PE header
    PE_ALT_NEFLAGS    = ida_idaapi.BADADDR &amp; -4 #  altval() -&gt; neflags
    PE_ALT_TDS_LOADED = ida_idaapi.BADADDR &amp; -5 #  altval() -&gt; tds already loaded(1) or invalid(-1)
    PE_ALT_PSXDLL     = ida_idaapi.BADADDR &amp; -6 #  altval() -&gt; if POSIX(x86) imports from PSXDLL netnode

    def __init__(self):
        self.__penode = ida_netnode.netnode()
        self.__penode.create(peutils_t.PE_NODE)

    imagebase = property(
        lambda self: self.__penode.altval(peutils_t.PE_ALT_IMAGEBASE)
      )

    header = property(
        lambda self: self.__penode.altval(peutils_t.PE_ALT_PEHDR_OFF)
      )

    def __str__(self):
        return "peutils_t(imagebase=%s, header=%s)" % (hex(self.imagebase), hex(self.header))

    def header(self):
        """
        Returns the complete PE header as an instance of peheader_t (defined in the SDK).
        """
        return self.__penode.valobj()</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="idautils.peutils_t.PE_ALT_DBG_FPOS"><code class="name">var <span class="ident">PE_ALT_DBG_FPOS</span></code></dt>
<dd>
<div class="desc"/>
</dd>
<dt id="idautils.peutils_t.PE_ALT_IMAGEBASE"><code class="name">var <span class="ident">PE_ALT_IMAGEBASE</span></code></dt>
<dd>
<div class="desc"/>
</dd>
<dt id="idautils.peutils_t.PE_ALT_NEFLAGS"><code class="name">var <span class="ident">PE_ALT_NEFLAGS</span></code></dt>
<dd>
<div class="desc"/>
</dd>
<dt id="idautils.peutils_t.PE_ALT_PEHDR_OFF"><code class="name">var <span class="ident">PE_ALT_PEHDR_OFF</span></code></dt>
<dd>
<div class="desc"/>
</dd>
<dt id="idautils.peutils_t.PE_ALT_PSXDLL"><code class="name">var <span class="ident">PE_ALT_PSXDLL</span></code></dt>
<dd>
<div class="desc"/>
</dd>
<dt id="idautils.peutils_t.PE_ALT_TDS_LOADED"><code class="name">var <span class="ident">PE_ALT_TDS_LOADED</span></code></dt>
<dd>
<div class="desc"/>
</dd>
<dt id="idautils.peutils_t.PE_NODE"><code class="name">var <span class="ident">PE_NODE</span></code></dt>
<dd>
<div class="desc"/>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="idautils.peutils_t.imagebase"><code class="name">var <span class="ident">imagebase</span></code></dt>
<dd>
<div class="desc"/>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">lambda self: self.__penode.altval(peutils_t.PE_ALT_IMAGEBASE)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="idautils.peutils_t.header"><code class="name flex">
<span>def <span class="ident">header</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Returns the complete PE header as an instance of peheader_t (defined in the SDK).</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def header(self):
    """
    Returns the complete PE header as an instance of peheader_t (defined in the SDK).
    """
    return self.__penode.valobj()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
</main>
<footer id="footer">
<p>Copyright (c) 2021 Hex-Rays SA. <a href="/terms_of_use.shtml">Terms of use</a> and <a href="/privacy_policy.shtml">privacy policy</a>.</p>
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> ???</a>.</p>
</footer>
</body>
</html>