<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1"/>
<meta name="generator" content="pdoc ???"/>
<title>ida_frame API documentation</title>
<meta name="description" content="IDA Plugin SDK API wrapper: frame"/>
<link rel="preload stylesheet" as="style" href="assets/sanitize.min.css"/>
<link rel="preload stylesheet" as="style" href="assets/typography.min.css"/>
<link rel="stylesheet preload" as="style" href="assets/github.min.css"/>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar &amp;gt; *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl &amp;gt; dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:-webkit-fill-available}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name &amp;gt; span:first-child{white-space:nowrap}.name.class &amp;gt; span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary &amp;gt; *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content: ',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width: 700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content padding:3em 4em;border-left:1px solid #ddd;lid #ddd;}pre code{font-size:1em}.item .name{font-size:1em}main{/* display:flex; *//* flex-direction:row-reverse; *//* justify-content:flex-end; */}.toc ul ul,#index ul{padding-left:1.5em}.toc &gt; ul &gt; li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer="defer" src="assets/highlight.min.js"/>
<script>window.addEventListener('DOMContentLoaded', () =&gt; hljs.initHighlighting())</script>
<style>
#section-intro .epy_par
{
margin-top: 18px;
}
</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ida_frame</code></h1>
</header>
<section id="section-intro">
<div class="epy_par">
IDA Plugin SDK API wrapper: frame</div>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="ida_frame.FPC_ARGS"><code class="name">var <span class="ident">FPC_ARGS</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
FPC_ARGS = 0</div></div>
</dd>
<dt id="ida_frame.FPC_LVARS"><code class="name">var <span class="ident">FPC_LVARS</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
FPC_LVARS = 3</div></div>
</dd>
<dt id="ida_frame.FPC_RETADDR"><code class="name">var <span class="ident">FPC_RETADDR</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
FPC_RETADDR = 1</div></div>
</dd>
<dt id="ida_frame.FPC_SAVREGS"><code class="name">var <span class="ident">FPC_SAVREGS</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
FPC_SAVREGS = 2</div></div>
</dd>
<dt id="ida_frame.REGVAR_ERROR_ARG"><code class="name">var <span class="ident">REGVAR_ERROR_ARG</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
function arguments are bad</div></div>
</dd>
<dt id="ida_frame.REGVAR_ERROR_NAME"><code class="name">var <span class="ident">REGVAR_ERROR_NAME</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
the provided name(s) can't be accepted</div></div>
</dd>
<dt id="ida_frame.REGVAR_ERROR_OK"><code class="name">var <span class="ident">REGVAR_ERROR_OK</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
all ok</div></div>
</dd>
<dt id="ida_frame.REGVAR_ERROR_RANGE"><code class="name">var <span class="ident">REGVAR_ERROR_RANGE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
the definition range is bad</div></div>
</dd>
<dt id="ida_frame.STKVAR_VALID_SIZE"><code class="name">var <span class="ident">STKVAR_VALID_SIZE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
x.dtyp contains correct variable type (for insns like 'lea' this bit
must be off) in general, dr_O references do not allow to determine the
variable size</div></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="ida_frame.add_auto_stkpnt"><code class="name flex">
<span>def <span class="ident">add_auto_stkpnt</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Add automatic SP register change point.</div>
<div class="epy_par">
<strong class="epy_sig">add_auto_stkpnt(pfn, ea, delta) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">pfn</strong>: pointer to function. may be NULL. (C++: func_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">ea</strong>: linear address where SP changes. usually this is the end of<div class="epy_nested">
the instruction which modifies the stack pointer
(\cmd{ea}
+\cmd{size}) (C++: ea_t)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">delta</strong>: difference between old and new values of SP (C++:<div class="epy_nested">
sval_t)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: success</div>
</div></div>
</dd>
<dt id="ida_frame.add_frame"><code class="name flex">
<span>def <span class="ident">add_frame</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Add function frame.</div>
<div class="epy_par">
<strong class="epy_sig">add_frame(pfn, frsize, frregs, argsize) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">pfn</strong>: pointer to function structure (C++: func_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">frsize</strong>: size of function local variables (C++: sval_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">frregs</strong>: size of saved registers (C++: ushort)</div>
<div class="epy_nested">
<strong class="epy_parameter">argsize</strong>: size of function arguments range which will be purged<div class="epy_nested">
upon return. this parameter is used for __stdcall and
__pascal calling conventions. for other calling
conventions please pass 0. (C++: asize_t)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 - ok</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - failed (no function, frame already exists)</div>
</div></div>
</dd>
<dt id="ida_frame.add_regvar"><code class="name flex">
<span>def <span class="ident">add_regvar</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Define a register variable.</div>
<div class="epy_par">
<strong class="epy_sig">add_regvar(pfn, ea1, ea2, canon, user, cmt) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">pfn</strong>: function in which the definition will be created (C++:<div class="epy_nested">
func_t
*)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">ea1</strong>: range of addresses within the function where the<div class="epy_nested">
definition will be used (C++: ea_t)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">ea2</strong>: range of addresses within the function where the<div class="epy_nested">
definition will be used (C++: ea_t)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">canon</strong>: name of a general register (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">user</strong>: user-defined name for the register (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">cmt</strong>: comment for the definition (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: Register variable error codes</div>
</div></div>
</dd>
<dt id="ida_frame.add_user_stkpnt"><code class="name flex">
<span>def <span class="ident">add_user_stkpnt</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Add user-defined SP register change point.</div>
<div class="epy_par">
<strong class="epy_sig">add_user_stkpnt(ea, delta) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong>: linear address where SP changes (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">delta</strong>: difference between old and new values of SP (C++:<div class="epy_nested">
sval_t)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: success</div>
</div></div>
</dd>
<dt id="ida_frame.build_stkvar_name"><code class="name flex">
<span>def <span class="ident">build_stkvar_name</span></span>(<span>*args) &#8209;&gt;&#160;qstring&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Build automatic stack variable name.</div>
<div class="epy_par">
<strong class="epy_sig">build_stkvar_name(pfn, v) -&gt; str</strong><div class="epy_nested">
<strong class="epy_parameter">pfn</strong>: pointer to function (can't be NULL!) (C++: const
func_t<div class="epy_nested">
*)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">v</strong>: value of variable offset (C++: sval_t)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: length of stack variable name or -1</div>
</div></div>
</dd>
<dt id="ida_frame.build_stkvar_xrefs"><code class="name flex">
<span>def <span class="ident">build_stkvar_xrefs</span></span>(<span>*args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Fill 'out' with a list of all the xrefs made from function 'pfn', to
the argument or variable 'mptr' in 'pfn's stack frame.</div>
<div class="epy_par">
<strong class="epy_sig">build_stkvar_xrefs(out, pfn, mptr)</strong><div class="epy_nested">
<strong class="epy_parameter">out</strong>: the list of xrefs to fill. (C++: xreflist_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">pfn</strong>: the function to scan. (C++: func_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">mptr</strong>: the argument/variable in pfn's stack frame. (C++: const<div class="epy_nested">
member_t
*)</div>
</div>
</div></div>
</dd>
<dt id="ida_frame.calc_stkvar_struc_offset"><code class="name flex">
<span>def <span class="ident">calc_stkvar_struc_offset</span></span>(<span>*args) &#8209;&gt;&#160;ea_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Calculate offset of stack variable in the frame structure.</div>
<div class="epy_par">
<strong class="epy_sig">calc_stkvar_struc_offset(pfn, insn, n) -&gt; ea_t</strong><div class="epy_nested">
<strong class="epy_parameter">pfn</strong>: pointer to function (can't be NULL!) (C++: func_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">insn</strong>: the instruction
- an ida_ua.insn_t, or an address (C++:<div class="epy_nested">
const insn_t &amp;)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">n</strong>: number of operand: (0.. UA_MAXOP -1) -1 if error, return<div class="epy_nested">
BADADDR (C++: int)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: BADADDR
if some error (issue a warning if stack frame is<div class="epy_nested">
bad)</div>
</div>
</div></div>
</dd>
<dt id="ida_frame.define_stkvar"><code class="name flex">
<span>def <span class="ident">define_stkvar</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Define/redefine a stack variable.</div>
<div class="epy_par">
<strong class="epy_sig">define_stkvar(pfn, name, off, flags, ti, nbytes) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">pfn</strong>: pointer to function (C++: func_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">name</strong>: variable name, NULL means autogenerate a name (C++: const<div class="epy_nested">
char *)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">off</strong>: offset of the stack variable in the frame. negative values<div class="epy_nested">
denote local variables, positive - function arguments.
(C++: sval_t)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">flags</strong>: variable type flags ( byte_flag()
for a byte variable,<div class="epy_nested">
for example) (C++: flags_t)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">ti</strong>: additional type information (like offsets, structs, etc)<div class="epy_nested">
(C++: const
opinfo_t
*)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">nbytes</strong>: number of bytes occupied by the variable (C++: asize_t)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: success</div>
</div></div>
</dd>
<dt id="ida_frame.del_frame"><code class="name flex">
<span>def <span class="ident">del_frame</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Delete a function frame.</div>
<div class="epy_par">
<strong class="epy_sig">del_frame(pfn) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">pfn</strong>: pointer to function structure (C++: func_t
*)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: success</div>
</div></div>
</dd>
<dt id="ida_frame.del_regvar"><code class="name flex">
<span>def <span class="ident">del_regvar</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Delete a register variable definition.</div>
<div class="epy_par">
<strong class="epy_sig">del_regvar(pfn, ea1, ea2, canon) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">pfn</strong>: function in question (C++: func_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">ea1</strong>: range of addresses within the function where the<div class="epy_nested">
definition holds (C++: ea_t)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">ea2</strong>: range of addresses within the function where the<div class="epy_nested">
definition holds (C++: ea_t)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">canon</strong>: name of a general register (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: Register variable error codes</div>
</div></div>
</dd>
<dt id="ida_frame.del_stkpnt"><code class="name flex">
<span>def <span class="ident">del_stkpnt</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Delete SP register change point.</div>
<div class="epy_par">
<strong class="epy_sig">del_stkpnt(pfn, ea) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">pfn</strong>: pointer to function. may be NULL. (C++: func_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">ea</strong>: linear address (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: success</div>
</div></div>
</dd>
<dt id="ida_frame.delete_unreferenced_stkvars"><code class="name flex">
<span>def <span class="ident">delete_unreferenced_stkvars</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">delete_unreferenced_stkvars(pfn) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">pfn</strong> (C++: func_t
*)</div>
</div></div>
</dd>
<dt id="ida_frame.delete_wrong_stkvar_ops"><code class="name flex">
<span>def <span class="ident">delete_wrong_stkvar_ops</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">delete_wrong_stkvar_ops(pfn) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">pfn</strong> (C++: func_t
*)</div>
</div></div>
</dd>
<dt id="ida_frame.find_regvar"><code class="name flex">
<span>def <span class="ident">find_regvar</span></span>(<span>*args) &#8209;&gt;&#160;<a title="ida_frame.regvar_t" href="#ida_frame.regvar_t">regvar_t</a>&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Find a register variable definition (powerful version). One of 'canon'
and 'user' should be NULL. If both 'canon' and 'user' are NULL it
returns the first regvar definition in the range.</div>
<div class="epy_par">
<strong class="epy_sig">find_regvar(pfn, ea1, ea2, canon, user) -&gt; regvar_t</strong><div class="epy_nested">
<strong class="epy_parameter">pfn</strong>: function in question (C++: func_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">ea1</strong>: range of addresses to search. ea1==BADADDR means the<div class="epy_nested">
entire function (C++: ea_t)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">ea2</strong>: range of addresses to search. ea1==BADADDR means the<div class="epy_nested">
entire function (C++: ea_t)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">canon</strong>: name of a general register (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">user</strong>: user-defined name for the register (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: NULL-not found, otherwise ptr to
regvar_t</div>
</div>
<div class="epy_par">
<strong class="epy_sig">find_regvar(pfn, ea, canon) -&gt; regvar_t</strong><div class="epy_nested">
<strong class="epy_parameter">pfn</strong>: function in question (C++: func_t
*)
ea: ea_t</div>
<div class="epy_nested">
<strong class="epy_parameter">canon</strong>: name of a general register (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: NULL-not found, otherwise ptr to
regvar_t</div>
</div></div>
</dd>
<dt id="ida_frame.frame_off_args"><code class="name flex">
<span>def <span class="ident">frame_off_args</span></span>(<span>*args) &#8209;&gt;&#160;ea_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get starting address of arguments section.</div>
<div class="epy_par">
<strong class="epy_sig">frame_off_args(pfn) -&gt; ea_t</strong><div class="epy_nested">
<strong class="epy_parameter">pfn</strong> (C++: const
func_t
*)</div>
</div></div>
</dd>
<dt id="ida_frame.frame_off_lvars"><code class="name flex">
<span>def <span class="ident">frame_off_lvars</span></span>(<span>*args) &#8209;&gt;&#160;ea_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get start address of local variables section.</div>
<div class="epy_par">
<strong class="epy_sig">frame_off_lvars(pfn) -&gt; ea_t</strong><div class="epy_nested">
<strong class="epy_parameter">pfn</strong> (C++: const
func_t
*)</div>
</div></div>
</dd>
<dt id="ida_frame.frame_off_retaddr"><code class="name flex">
<span>def <span class="ident">frame_off_retaddr</span></span>(<span>*args) &#8209;&gt;&#160;ea_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get starting address of return address section.</div>
<div class="epy_par">
<strong class="epy_sig">frame_off_retaddr(pfn) -&gt; ea_t</strong><div class="epy_nested">
<strong class="epy_parameter">pfn</strong> (C++: const
func_t
*)</div>
</div></div>
</dd>
<dt id="ida_frame.frame_off_savregs"><code class="name flex">
<span>def <span class="ident">frame_off_savregs</span></span>(<span>*args) &#8209;&gt;&#160;ea_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get starting address of saved registers section.</div>
<div class="epy_par">
<strong class="epy_sig">frame_off_savregs(pfn) -&gt; ea_t</strong><div class="epy_nested">
<strong class="epy_parameter">pfn</strong> (C++: const
func_t
*)</div>
</div></div>
</dd>
<dt id="ida_frame.free_regvar"><code class="name flex">
<span>def <span class="ident">free_regvar</span></span>(<span>*args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">free_regvar(v)</strong><div class="epy_nested">
<strong class="epy_parameter">v</strong> (C++: struct
regvar_t
*)</div>
</div></div>
</dd>
<dt id="ida_frame.get_effective_spd"><code class="name flex">
<span>def <span class="ident">get_effective_spd</span></span>(<span>*args) &#8209;&gt;&#160;sval_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get effective difference between the initial and current values of
ESP. This function returns the sp-diff used by the instruction. The
difference between 'get_spd()' and 'get_effective_spd()' is present
only for instructions like "pop [esp+N]": they modify sp and use the
modified value.</div>
<div class="epy_par">
<strong class="epy_sig">get_effective_spd(pfn, ea) -&gt; sval_t</strong><div class="epy_nested">
<strong class="epy_parameter">pfn</strong>: pointer to function. may be NULL. (C++: func_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">ea</strong>: linear address (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: 0 or the difference, usually a negative number</div>
</div></div>
</dd>
<dt id="ida_frame.get_frame"><code class="name flex">
<span>def <span class="ident">get_frame</span></span>(<span>*args) &#8209;&gt;&#160;struc_t&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get pointer to function frame.</div>
<div class="epy_par">
<strong class="epy_sig">get_frame(pfn) -&gt; struc_t</strong><div class="epy_nested">
<strong class="epy_parameter">pfn</strong>: pointer to function structure (C++: const
func_t
*)</div>
</div>
<div class="epy_par">
<strong class="epy_sig">get_frame(ea) -&gt; struc_t *</strong><div class="epy_nested">
ea: ea_t</div>
</div></div>
</dd>
<dt id="ida_frame.get_frame_part"><code class="name flex">
<span>def <span class="ident">get_frame_part</span></span>(<span>*args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get offsets of the frame part in the frame.</div>
<div class="epy_par">
<strong class="epy_sig">get_frame_part(range, pfn, part)</strong><div class="epy_nested">
<strong class="epy_parameter">range</strong>: pointer to the output buffer with the frame part<div class="epy_nested">
start/end(exclusive) offsets, can't be NULL (C++:
range_t
*)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">pfn</strong>: pointer to function structure, can't be NULL (C++: const<div class="epy_nested">
func_t
*)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">part</strong>: frame part (C++: frame_part_t)</div>
</div></div>
</dd>
<dt id="ida_frame.get_frame_retsize"><code class="name flex">
<span>def <span class="ident">get_frame_retsize</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get size of function return address.</div>
<div class="epy_par">
<strong class="epy_sig">get_frame_retsize(pfn) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">pfn</strong>: pointer to function structure, can't be NULL (C++: const<div class="epy_nested">
func_t
*)</div>
</div>
</div></div>
</dd>
<dt id="ida_frame.get_frame_size"><code class="name flex">
<span>def <span class="ident">get_frame_size</span></span>(<span>*args) &#8209;&gt;&#160;asize_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get full size of a function frame. This function takes into account
size of local variables + size of saved registers + size of return
address + number of purged bytes. The purged bytes correspond to the
arguments of the functions with __stdcall and __fastcall calling
conventions.</div>
<div class="epy_par">
<strong class="epy_sig">get_frame_size(pfn) -&gt; asize_t</strong><div class="epy_nested">
<strong class="epy_parameter">pfn</strong>: pointer to function structure, may be NULL (C++: const<div class="epy_nested">
func_t
*)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: size of frame in bytes or zero</div>
</div></div>
</dd>
<dt id="ida_frame.get_func_by_frame"><code class="name flex">
<span>def <span class="ident">get_func_by_frame</span></span>(<span>*args) &#8209;&gt;&#160;ea_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get function by its frame id.this function works only with databases
created by IDA &gt; 5.6</div>
<div class="epy_par">
<strong class="epy_sig">get_func_by_frame(frame_id) -&gt; ea_t</strong><div class="epy_nested">
<strong class="epy_parameter">frame_id</strong>: id of the function frame (C++: tid_t)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: start address of the function or
BADADDR</div>
</div></div>
</dd>
<dt id="ida_frame.get_min_spd_ea"><code class="name flex">
<span>def <span class="ident">get_min_spd_ea</span></span>(<span>*args) &#8209;&gt;&#160;ea_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">get_min_spd_ea(pfn) -&gt; ea_t</strong><div class="epy_nested">
<strong class="epy_parameter">pfn</strong> (C++: func_t
*)</div>
</div></div>
</dd>
<dt id="ida_frame.get_sp_delta"><code class="name flex">
<span>def <span class="ident">get_sp_delta</span></span>(<span>*args) &#8209;&gt;&#160;sval_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get modification of SP made at the specified location</div>
<div class="epy_par">
<strong class="epy_sig">get_sp_delta(pfn, ea) -&gt; sval_t</strong><div class="epy_nested">
<strong class="epy_parameter">pfn</strong>: pointer to function. may be NULL. (C++: func_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">ea</strong>: linear address (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: 0 if the specified location doesn't contain a SP change<div class="epy_nested">
point. otherwise return delta of SP modification.</div>
</div>
</div></div>
</dd>
<dt id="ida_frame.get_spd"><code class="name flex">
<span>def <span class="ident">get_spd</span></span>(<span>*args) &#8209;&gt;&#160;sval_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get difference between the initial and current values of ESP.</div>
<div class="epy_par">
<strong class="epy_sig">get_spd(pfn, ea) -&gt; sval_t</strong><div class="epy_nested">
<strong class="epy_parameter">pfn</strong>: pointer to function. may be NULL. (C++: func_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">ea</strong>: linear address of an instruction (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: 0 or the difference, usually a negative number. returns the<div class="epy_nested">
sp-diff before executing the instruction.</div>
</div>
</div></div>
</dd>
<dt id="ida_frame.get_stkvar"><code class="name flex">
<span>def <span class="ident">get_stkvar</span></span>(<span>*args) &#8209;&gt;&#160;PyObject&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">get_stkvar(insn, op, v) -&gt; PyObject *</strong><div class="epy_nested">
Get pointer to stack variable</div>
<div class="epy_nested">
<strong class="epy_parameter">op</strong>: reference to instruction operand</div>
<div class="epy_nested">
<strong class="epy_parameter">v</strong>: immediate value in the operand (usually op.addr)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>:<ul class="epy_ul">
<li class="epy_li"><span class="epy_nested">
None on failure</span>
</li>
<li class="epy_li"><span class="epy_nested">
tuple(member_t, actval)<div class="epy_nested">
where actval: actual value used to fetch stack variable</div>
</span>
</li>
</ul>
</div>
</div></div>
</dd>
<dt id="ida_frame.has_regvar"><code class="name flex">
<span>def <span class="ident">has_regvar</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is there a register variable definition?</div>
<div class="epy_par">
<strong class="epy_sig">has_regvar(pfn, ea) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">pfn</strong>: function in question (C++: func_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">ea</strong>: current address (C++: ea_t)</div>
</div></div>
</dd>
<dt id="ida_frame.is_funcarg_off"><code class="name flex">
<span>def <span class="ident">is_funcarg_off</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">is_funcarg_off(pfn, frameoff) -&gt; bool</strong><div class="epy_nested">
pfn: func_t const *
frameoff: uval_t</div>
</div></div>
</dd>
<dt id="ida_frame.lvar_off"><code class="name flex">
<span>def <span class="ident">lvar_off</span></span>(<span>*args) &#8209;&gt;&#160;sval_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">lvar_off(pfn, frameoff) -&gt; sval_t</strong><div class="epy_nested">
pfn: func_t const *
frameoff: uval_t</div>
</div></div>
</dd>
<dt id="ida_frame.recalc_spd"><code class="name flex">
<span>def <span class="ident">recalc_spd</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Recalculate SP delta for an instruction that stops execution. The next
instruction is not reached from the current instruction. We need to
recalculate SP for the next instruction.This function will create a
new automatic SP register change point if necessary. It should be
called from the emulator (emu.cpp) when auto_state == 'AU_USED' if the
current instruction doesn't pass the execution flow to the next
instruction.</div>
<div class="epy_par">
<strong class="epy_sig">recalc_spd(cur_ea) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">cur_ea</strong>: linear address of the current instruction (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 - new stkpnt is added</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - nothing is changed</div>
</div></div>
</dd>
<dt id="ida_frame.rename_regvar"><code class="name flex">
<span>def <span class="ident">rename_regvar</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Rename a register variable.</div>
<div class="epy_par">
<strong class="epy_sig">rename_regvar(pfn, v, user) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">pfn</strong>: function in question (C++: func_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">v</strong>: variable to rename (C++: regvar_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">user</strong>: new user-defined name for the register (C++: const char<div class="epy_nested">
*)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: Register variable error codes</div>
</div></div>
</dd>
<dt id="ida_frame.set_frame_size"><code class="name flex">
<span>def <span class="ident">set_frame_size</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Set size of function frame. Note: The returned size may not include
all stack arguments. It does so only for __stdcall and __fastcall
calling conventions. To get the entire frame size for all cases use
get_struc_size(get_frame(pfn)).</div>
<div class="epy_par">
<strong class="epy_sig">set_frame_size(pfn, frsize, frregs, argsize) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">pfn</strong>: pointer to function structure (C++: func_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">frsize</strong>: size of function local variables (C++: asize_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">frregs</strong>: size of saved registers (C++: ushort)</div>
<div class="epy_nested">
<strong class="epy_parameter">argsize</strong>: size of function arguments that will be purged from<div class="epy_nested">
the stack upon return (C++: asize_t)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: success</div>
</div></div>
</dd>
<dt id="ida_frame.set_purged"><code class="name flex">
<span>def <span class="ident">set_purged</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Set the number of purged bytes for a function or data item (funcptr).
This function will update the database and plan to reanalyze items
referencing the specified address. It works only for processors with
'PR_PURGING' bit in 16 and 32 bit modes.</div>
<div class="epy_par">
<strong class="epy_sig">set_purged(ea, nbytes, override_old_value) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong>: address of the function of item (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">nbytes</strong>: number of purged bytes (C++: int)</div>
<div class="epy_nested">
<strong class="epy_parameter">override_old_value</strong>: may overwrite old information about purged<div class="epy_nested">
bytes (C++: bool)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: success</div>
</div></div>
</dd>
<dt id="ida_frame.set_regvar_cmt"><code class="name flex">
<span>def <span class="ident">set_regvar_cmt</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Set comment for a register variable.</div>
<div class="epy_par">
<strong class="epy_sig">set_regvar_cmt(pfn, v, cmt) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">pfn</strong>: function in question (C++: func_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">v</strong>: variable to rename (C++: regvar_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">cmt</strong>: new comment (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: Register variable error codes</div>
</div></div>
</dd>
<dt id="ida_frame.soff_to_fpoff"><code class="name flex">
<span>def <span class="ident">soff_to_fpoff</span></span>(<span>*args) &#8209;&gt;&#160;sval_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Convert struct offsets into fp-relative offsets. This function
converts the offsets inside the 'struc_t' object into the frame
pointer offsets (for example, EBP-relative).</div>
<div class="epy_par">
<strong class="epy_sig">soff_to_fpoff(pfn, soff) -&gt; sval_t</strong><div class="epy_nested">
<strong class="epy_parameter">pfn</strong> (C++: func_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">soff</strong> (C++: uval_t)</div>
</div></div>
</dd>
<dt id="ida_frame.update_fpd"><code class="name flex">
<span>def <span class="ident">update_fpd</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Update frame pointer delta.</div>
<div class="epy_par">
<strong class="epy_sig">update_fpd(pfn, fpd) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">pfn</strong>: pointer to function structure (C++: func_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">fpd</strong>: new fpd value. cannot be bigger than the local variable<div class="epy_nested">
range size. (C++: asize_t)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: success</div>
</div></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ida_frame.regvar_t"><code class="flex name class">
<span>class <span class="ident">regvar_t</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ regvar_t class.</div>
<div class="epy_par">
<strong class="epy_sig">__init__(self) -&gt; regvar_t</strong><div class="epy_nested">
r: regvar_t const &amp;</div>
</div></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="ida_range.range_t" href="ida_range.html#ida_range.range_t">range_t</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="ida_frame.regvar_t.canon"><code class="name">var <span class="ident">canon</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">regvar_t_canon_get(self) -&gt; char *</strong></div></div>
</dd>
<dt id="ida_frame.regvar_t.cmt"><code class="name">var <span class="ident">cmt</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">regvar_t_cmt_get(self) -&gt; char *</strong></div></div>
</dd>
<dt id="ida_frame.regvar_t.user"><code class="name">var <span class="ident">user</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">regvar_t_user_get(self) -&gt; char *</strong></div></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ida_frame.regvar_t.swap"><code class="name flex">
<span>def <span class="ident">swap</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">swap(self, r)</strong><div class="epy_nested">
<strong class="epy_parameter">r</strong> (C++: regvar_t
&amp;)</div>
</div></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="ida_range.range_t" href="ida_range.html#ida_range.range_t">range_t</a></b></code>:
<ul class="hlist">
<li><code><a title="ida_range.range_t.clear" href="ida_range.html#ida_range.range_t.clear">clear</a></code></li>
<li><code><a title="ida_range.range_t.compare" href="ida_range.html#ida_range.range_t.compare">compare</a></code></li>
<li><code><a title="ida_range.range_t.contains" href="ida_range.html#ida_range.range_t.contains">contains</a></code></li>
<li><code><a title="ida_range.range_t.empty" href="ida_range.html#ida_range.range_t.empty">empty</a></code></li>
<li><code><a title="ida_range.range_t.end_ea" href="ida_range.html#ida_range.range_t.end_ea">end_ea</a></code></li>
<li><code><a title="ida_range.range_t.extend" href="ida_range.html#ida_range.range_t.extend">extend</a></code></li>
<li><code><a title="ida_range.range_t.intersect" href="ida_range.html#ida_range.range_t.intersect">intersect</a></code></li>
<li><code><a title="ida_range.range_t.overlaps" href="ida_range.html#ida_range.range_t.overlaps">overlaps</a></code></li>
<li><code><a title="ida_range.range_t.size" href="ida_range.html#ida_range.range_t.size">size</a></code></li>
<li><code><a title="ida_range.range_t.start_ea" href="ida_range.html#ida_range.range_t.start_ea">start_ea</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="ida_frame.stkpnt_t"><code class="flex name class">
<span>class <span class="ident">stkpnt_t</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ stkpnt_t class.</div>
<div class="epy_par">
<strong class="epy_sig">__init__(self) -&gt; stkpnt_t</strong></div></div>
<h3>Instance variables</h3>
<dl>
<dt id="ida_frame.stkpnt_t.ea"><code class="name">var <span class="ident">ea</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">stkpnt_t_ea_get(self) -&gt; ea_t</strong></div></div>
</dd>
<dt id="ida_frame.stkpnt_t.spd"><code class="name">var <span class="ident">spd</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">stkpnt_t_spd_get(self) -&gt; sval_t</strong></div></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ida_frame.stkpnt_t.compare"><code class="name flex">
<span>def <span class="ident">compare</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">compare(self, r) -&gt; int</strong><div class="epy_nested">
r: stkpnt_t const &amp;</div>
</div></div>
</dd>
</dl>
</dd>
<dt id="ida_frame.stkpnts_t"><code class="flex name class">
<span>class <span class="ident">stkpnts_t</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ stkpnts_t class.</div>
<div class="epy_par">
<strong class="epy_sig">__init__(self) -&gt; stkpnts_t</strong></div></div>
<h3>Methods</h3>
<dl>
<dt id="ida_frame.stkpnts_t.compare"><code class="name flex">
<span>def <span class="ident">compare</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">compare(self, r) -&gt; int</strong><div class="epy_nested">
r: stkpnts_t const &amp;</div>
</div></div>
</dd>
</dl>
</dd>
<dt id="ida_frame.xreflist_entry_t"><code class="flex name class">
<span>class <span class="ident">xreflist_entry_t</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ xreflist_entry_t class.</div>
<div class="epy_par">
<strong class="epy_sig">__init__(self) -&gt; xreflist_entry_t</strong></div></div>
<h3>Instance variables</h3>
<dl>
<dt id="ida_frame.xreflist_entry_t.ea"><code class="name">var <span class="ident">ea</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">xreflist_entry_t_ea_get(self) -&gt; ea_t</strong></div></div>
</dd>
<dt id="ida_frame.xreflist_entry_t.opnum"><code class="name">var <span class="ident">opnum</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">xreflist_entry_t_opnum_get(self) -&gt; uchar</strong></div></div>
</dd>
<dt id="ida_frame.xreflist_entry_t.type"><code class="name">var <span class="ident">type</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">xreflist_entry_t_type_get(self) -&gt; uchar</strong></div></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ida_frame.xreflist_entry_t.compare"><code class="name flex">
<span>def <span class="ident">compare</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">compare(self, r) -&gt; int</strong><div class="epy_nested">
r: xreflist_entry_t const &amp;</div>
</div></div>
</dd>
</dl>
</dd>
<dt id="ida_frame.xreflist_t"><code class="flex name class">
<span>class <span class="ident">xreflist_t</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ qvector&lt; xreflist_entry_t &gt; class.</div>
<div class="epy_par">
<strong class="epy_sig">__init__(self) -&gt; xreflist_t</strong><div class="epy_nested">
x: qvector&lt; xreflist_entry_t &gt; const &amp;</div>
</div></div>
<h3>Methods</h3>
<dl>
<dt id="ida_frame.xreflist_t.add_unique"><code class="name flex">
<span>def <span class="ident">add_unique</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">add_unique(self, x) -&gt; bool</strong><div class="epy_nested">
x: xreflist_entry_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_frame.xreflist_t.at"><code class="name flex">
<span>def <span class="ident">at</span></span>(<span>self, *args) &#8209;&gt;&#160;<a title="ida_frame.xreflist_entry_t" href="#ida_frame.xreflist_entry_t">xreflist_entry_t</a>&#160;const&#160;&amp;</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">at(self, _idx) -&gt; xreflist_entry_t</strong><div class="epy_nested">
_idx: size_t</div>
</div></div>
</dd>
<dt id="ida_frame.xreflist_t.back"><code class="name flex">
<span>def <span class="ident">back</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"/>
</dd>
<dt id="ida_frame.xreflist_t.begin"><code class="name flex">
<span>def <span class="ident">begin</span></span>(<span>self, *args) &#8209;&gt;&#160;qvectorxreflist_entry_t&#160;&gt;::const_iterator</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">begin(self) -&gt; xreflist_entry_t</strong></div>
<div class="epy_par">
<strong class="epy_sig">begin(self) -&gt; xreflist_entry_t</strong></div></div>
</dd>
<dt id="ida_frame.xreflist_t.capacity"><code class="name flex">
<span>def <span class="ident">capacity</span></span>(<span>self, *args) &#8209;&gt;&#160;size_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">capacity(self) -&gt; size_t</strong></div></div>
</dd>
<dt id="ida_frame.xreflist_t.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">clear(self)</strong></div></div>
</dd>
<dt id="ida_frame.xreflist_t.empty"><code class="name flex">
<span>def <span class="ident">empty</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">empty(self) -&gt; bool</strong></div></div>
</dd>
<dt id="ida_frame.xreflist_t.end"><code class="name flex">
<span>def <span class="ident">end</span></span>(<span>self, *args) &#8209;&gt;&#160;qvectorxreflist_entry_t&#160;&gt;::const_iterator</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">end(self) -&gt; xreflist_entry_t</strong></div>
<div class="epy_par">
<strong class="epy_sig">end(self) -&gt; xreflist_entry_t</strong></div></div>
</dd>
<dt id="ida_frame.xreflist_t.erase"><code class="name flex">
<span>def <span class="ident">erase</span></span>(<span>self, *args) &#8209;&gt;&#160;qvectorxreflist_entry_t&#160;&gt;::iterator</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">erase(self, it) -&gt; xreflist_entry_t</strong><div class="epy_nested">
it: qvector&lt; xreflist_entry_t &gt;::iterator</div>
</div>
<div class="epy_par">
<strong class="epy_sig">erase(self, first, last) -&gt; xreflist_entry_t</strong><div class="epy_nested">
first: qvector&lt; xreflist_entry_t &gt;::iterator
last: qvector&lt; xreflist_entry_t &gt;::iterator</div>
</div></div>
</dd>
<dt id="ida_frame.xreflist_t.extract"><code class="name flex">
<span>def <span class="ident">extract</span></span>(<span>self, *args) &#8209;&gt;&#160;<a title="ida_frame.xreflist_entry_t" href="#ida_frame.xreflist_entry_t">xreflist_entry_t</a>&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">extract(self) -&gt; xreflist_entry_t</strong></div></div>
</dd>
<dt id="ida_frame.xreflist_t.find"><code class="name flex">
<span>def <span class="ident">find</span></span>(<span>self, *args) &#8209;&gt;&#160;qvectorxreflist_entry_t&#160;&gt;::const_iterator</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">find(self, x) -&gt; xreflist_entry_t</strong><div class="epy_nested">
x: xreflist_entry_t const &amp;</div>
</div>
<div class="epy_par">
<strong class="epy_sig">find(self, x) -&gt; xreflist_entry_t</strong><div class="epy_nested">
x: xreflist_entry_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_frame.xreflist_t.front"><code class="name flex">
<span>def <span class="ident">front</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"/>
</dd>
<dt id="ida_frame.xreflist_t.grow"><code class="name flex">
<span>def <span class="ident">grow</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
grow(self, x=xreflist_entry_t())<div class="epy_nested">
x: xreflist_entry_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_frame.xreflist_t.has"><code class="name flex">
<span>def <span class="ident">has</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">has(self, x) -&gt; bool</strong><div class="epy_nested">
x: xreflist_entry_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_frame.xreflist_t.inject"><code class="name flex">
<span>def <span class="ident">inject</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">inject(self, s, len)</strong><div class="epy_nested">
s: xreflist_entry_t *
len: size_t</div>
</div></div>
</dd>
<dt id="ida_frame.xreflist_t.insert"><code class="name flex">
<span>def <span class="ident">insert</span></span>(<span>self, *args) &#8209;&gt;&#160;qvectorxreflist_entry_t&#160;&gt;::iterator</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">insert(self, it, x) -&gt; xreflist_entry_t</strong><div class="epy_nested">
it: qvector&lt; xreflist_entry_t &gt;::iterator
x: xreflist_entry_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_frame.xreflist_t.pop_back"><code class="name flex">
<span>def <span class="ident">pop_back</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">pop_back(self)</strong></div></div>
</dd>
<dt id="ida_frame.xreflist_t.push_back"><code class="name flex">
<span>def <span class="ident">push_back</span></span>(<span>self, *args) &#8209;&gt;&#160;<a title="ida_frame.xreflist_entry_t" href="#ida_frame.xreflist_entry_t">xreflist_entry_t</a>&#160;&amp;</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">push_back(self, x)</strong><div class="epy_nested">
x: xreflist_entry_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_frame.xreflist_t.qclear"><code class="name flex">
<span>def <span class="ident">qclear</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">qclear(self)</strong></div></div>
</dd>
<dt id="ida_frame.xreflist_t.reserve"><code class="name flex">
<span>def <span class="ident">reserve</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">reserve(self, cnt)</strong><div class="epy_nested">
cnt: size_t</div>
</div></div>
</dd>
<dt id="ida_frame.xreflist_t.resize"><code class="name flex">
<span>def <span class="ident">resize</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">resize(self, _newsize, x)</strong><div class="epy_nested">
_newsize: size_t
x: xreflist_entry_t const &amp;</div>
</div>
<div class="epy_par">
<strong class="epy_sig">resize(self, _newsize)</strong><div class="epy_nested">
_newsize: size_t</div>
</div></div>
</dd>
<dt id="ida_frame.xreflist_t.size"><code class="name flex">
<span>def <span class="ident">size</span></span>(<span>self, *args) &#8209;&gt;&#160;size_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">size(self) -&gt; size_t</strong></div></div>
</dd>
<dt id="ida_frame.xreflist_t.swap"><code class="name flex">
<span>def <span class="ident">swap</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">swap(self, r)</strong><div class="epy_nested">
r: qvector&lt; xreflist_entry_t &gt; &amp;</div>
</div></div>
</dd>
<dt id="ida_frame.xreflist_t.truncate"><code class="name flex">
<span>def <span class="ident">truncate</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">truncate(self)</strong></div></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
</main>
<footer id="footer">
<p>Copyright (c) 2021 Hex-Rays SA. <a href="/terms_of_use.shtml">Terms of use</a> and <a href="/privacy_policy.shtml">privacy policy</a>.</p>
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> ???</a>.</p>
</footer>
</body>
</html>