<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1"/>
<meta name="generator" content="pdoc ???"/>
<title>ida_idp API documentation</title>
<meta name="description" content="IDA Plugin SDK API wrapper: idp"/>
<link rel="preload stylesheet" as="style" href="assets/sanitize.min.css"/>
<link rel="preload stylesheet" as="style" href="assets/typography.min.css"/>
<link rel="stylesheet preload" as="style" href="assets/github.min.css"/>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar &amp;gt; *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl &amp;gt; dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:-webkit-fill-available}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name &amp;gt; span:first-child{white-space:nowrap}.name.class &amp;gt; span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary &amp;gt; *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content: ',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width: 700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content padding:3em 4em;border-left:1px solid #ddd;lid #ddd;}pre code{font-size:1em}.item .name{font-size:1em}main{/* display:flex; *//* flex-direction:row-reverse; *//* justify-content:flex-end; */}.toc ul ul,#index ul{padding-left:1.5em}.toc &gt; ul &gt; li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer="defer" src="assets/highlight.min.js"/>
<script>window.addEventListener('DOMContentLoaded', () =&gt; hljs.initHighlighting())</script>
<style>
#section-intro .epy_par
{
margin-top: 18px;
}
</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ida_idp</code></h1>
</header>
<section id="section-intro">
<div class="epy_par">
IDA Plugin SDK API wrapper: idp</div>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="ida_idp.AS2_BRACE"><code class="name">var <span class="ident">AS2_BRACE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Use braces for all expressions.</div></div>
</dd>
<dt id="ida_idp.AS2_BYTE1CHAR"><code class="name">var <span class="ident">AS2_BYTE1CHAR</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
One symbol per processor byte Meaningful only for wide byte processors</div></div>
</dd>
<dt id="ida_idp.AS2_COLONSUF"><code class="name">var <span class="ident">AS2_COLONSUF</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
addresses may have ":xx" suffix this suffix must be ignored when
extracting the address under the cursor</div></div>
</dd>
<dt id="ida_idp.AS2_IDEALDSCR"><code class="name">var <span class="ident">AS2_IDEALDSCR</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Description of struc/union is in the 'reverse' form (keyword before
name) the same as in borland tasm ideal</div></div>
</dd>
<dt id="ida_idp.AS2_STRINV"><code class="name">var <span class="ident">AS2_STRINV</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Invert meaning of \inf{wide_high_byte_first}
for text strings (For
processors with bytes bigger than 8 bits)</div></div>
</dd>
<dt id="ida_idp.AS2_TERSESTR"><code class="name">var <span class="ident">AS2_TERSESTR</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
'terse' structure initialization form NAME<fld> is supported</fld></div></div>
</dd>
<dt id="ida_idp.AS2_YWORD"><code class="name">var <span class="ident">AS2_YWORD</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
a_yword field is present and valid</div></div>
</dd>
<dt id="ida_idp.ASB_BINF0"><code class="name">var <span class="ident">ASB_BINF0</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
010101b</div></div>
</dd>
<dt id="ida_idp.ASB_BINF1"><code class="name">var <span class="ident">ASB_BINF1</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
^B010101</div></div>
</dd>
<dt id="ida_idp.ASB_BINF2"><code class="name">var <span class="ident">ASB_BINF2</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
%010101</div></div>
</dd>
<dt id="ida_idp.ASB_BINF3"><code class="name">var <span class="ident">ASB_BINF3</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
0b1010101</div></div>
</dd>
<dt id="ida_idp.ASB_BINF4"><code class="name">var <span class="ident">ASB_BINF4</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
b'1010101</div></div>
</dd>
<dt id="ida_idp.ASB_BINF5"><code class="name">var <span class="ident">ASB_BINF5</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
b'1010101'</div></div>
</dd>
<dt id="ida_idp.ASD_DECF0"><code class="name">var <span class="ident">ASD_DECF0</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
34</div></div>
</dd>
<dt id="ida_idp.ASD_DECF1"><code class="name">var <span class="ident">ASD_DECF1</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
#34</div></div>
</dd>
<dt id="ida_idp.ASD_DECF2"><code class="name">var <span class="ident">ASD_DECF2</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
ASD_DECF2 = 8192</div></div>
</dd>
<dt id="ida_idp.ASD_DECF3"><code class="name">var <span class="ident">ASD_DECF3</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
.34</div></div>
</dd>
<dt id="ida_idp.ASH_HEXF0"><code class="name">var <span class="ident">ASH_HEXF0</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
34h</div></div>
</dd>
<dt id="ida_idp.ASH_HEXF1"><code class="name">var <span class="ident">ASH_HEXF1</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
h'34</div></div>
</dd>
<dt id="ida_idp.ASH_HEXF2"><code class="name">var <span class="ident">ASH_HEXF2</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
34</div></div>
</dd>
<dt id="ida_idp.ASH_HEXF3"><code class="name">var <span class="ident">ASH_HEXF3</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
0x34</div></div>
</dd>
<dt id="ida_idp.ASH_HEXF4"><code class="name">var <span class="ident">ASH_HEXF4</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
$34</div></div>
</dd>
<dt id="ida_idp.ASH_HEXF5"><code class="name">var <span class="ident">ASH_HEXF5</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
 (radix)</div></div>
</dd>
<dt id="ida_idp.ASO_OCTF0"><code class="name">var <span class="ident">ASO_OCTF0</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
123o</div></div>
</dd>
<dt id="ida_idp.ASO_OCTF1"><code class="name">var <span class="ident">ASO_OCTF1</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
0123</div></div>
</dd>
<dt id="ida_idp.ASO_OCTF2"><code class="name">var <span class="ident">ASO_OCTF2</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
123</div></div>
</dd>
<dt id="ida_idp.ASO_OCTF3"><code class="name">var <span class="ident">ASO_OCTF3</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
@123</div></div>
</dd>
<dt id="ida_idp.ASO_OCTF4"><code class="name">var <span class="ident">ASO_OCTF4</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
o'123</div></div>
</dd>
<dt id="ida_idp.ASO_OCTF5"><code class="name">var <span class="ident">ASO_OCTF5</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
123q</div></div>
</dd>
<dt id="ida_idp.ASO_OCTF6"><code class="name">var <span class="ident">ASO_OCTF6</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
~123</div></div>
</dd>
<dt id="ida_idp.ASO_OCTF7"><code class="name">var <span class="ident">ASO_OCTF7</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
q'123</div></div>
</dd>
<dt id="ida_idp.AS_1TEXT"><code class="name">var <span class="ident">AS_1TEXT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
1 text per line, no bytes</div></div>
</dd>
<dt id="ida_idp.AS_2CHRE"><code class="name">var <span class="ident">AS_2CHRE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
double char constants are: "xy</div></div>
</dd>
<dt id="ida_idp.AS_ALIGN2"><code class="name">var <span class="ident">AS_ALIGN2</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
.align directive expects an exponent rather than a power of 2 (.align
5 means to align at 32byte boundary)</div></div>
</dd>
<dt id="ida_idp.AS_ASCIIC"><code class="name">var <span class="ident">AS_ASCIIC</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
ascii directive accepts C-like escape sequences (\n,\x01 and similar)</div></div>
</dd>
<dt id="ida_idp.AS_ASCIIZ"><code class="name">var <span class="ident">AS_ASCIIZ</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
ascii directive inserts implicit zero byte at the end</div></div>
</dd>
<dt id="ida_idp.AS_BINFM"><code class="name">var <span class="ident">AS_BINFM</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
mask - binary number format</div></div>
</dd>
<dt id="ida_idp.AS_COLON"><code class="name">var <span class="ident">AS_COLON</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
create colons after data names ?</div></div>
</dd>
<dt id="ida_idp.AS_DECFM"><code class="name">var <span class="ident">AS_DECFM</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
mask - decimal number format</div></div>
</dd>
<dt id="ida_idp.AS_HEXFM"><code class="name">var <span class="ident">AS_HEXFM</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
mask - hex number format</div></div>
</dd>
<dt id="ida_idp.AS_LALIGN"><code class="name">var <span class="ident">AS_LALIGN</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Labels at "align" keyword are supported.</div></div>
</dd>
<dt id="ida_idp.AS_N2CHR"><code class="name">var <span class="ident">AS_N2CHR</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
can't have 2 byte char consts</div></div>
</dd>
<dt id="ida_idp.AS_NCHRE"><code class="name">var <span class="ident">AS_NCHRE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
char constants are: 'x</div></div>
</dd>
<dt id="ida_idp.AS_NCMAS"><code class="name">var <span class="ident">AS_NCMAS</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
no commas in ascii directives</div></div>
</dd>
<dt id="ida_idp.AS_NHIAS"><code class="name">var <span class="ident">AS_NHIAS</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
no characters with high bit</div></div>
</dd>
<dt id="ida_idp.AS_NOCODECLN"><code class="name">var <span class="ident">AS_NOCODECLN</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
don't create colons after code names</div></div>
</dd>
<dt id="ida_idp.AS_NOSPACE"><code class="name">var <span class="ident">AS_NOSPACE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
No spaces in expressions.</div></div>
</dd>
<dt id="ida_idp.AS_NOXRF"><code class="name">var <span class="ident">AS_NOXRF</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Disable xrefs during the output file generation.</div></div>
</dd>
<dt id="ida_idp.AS_OCTFM"><code class="name">var <span class="ident">AS_OCTFM</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
mask - octal number format</div></div>
</dd>
<dt id="ida_idp.AS_OFFST"><code class="name">var <span class="ident">AS_OFFST</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
offsets are 'offset xxx' ?</div></div>
</dd>
<dt id="ida_idp.AS_ONEDUP"><code class="name">var <span class="ident">AS_ONEDUP</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
One array definition per line.</div></div>
</dd>
<dt id="ida_idp.AS_RELSUP"><code class="name">var <span class="ident">AS_RELSUP</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Checkarg: 'and','or','xor' operations with addresses are possible.</div></div>
</dd>
<dt id="ida_idp.AS_UDATA"><code class="name">var <span class="ident">AS_UDATA</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
can use '?' in data directives</div></div>
</dd>
<dt id="ida_idp.AS_UNEQU"><code class="name">var <span class="ident">AS_UNEQU</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
replace undefined data items with EQU (for ANTA's A80)</div></div>
</dd>
<dt id="ida_idp.AS_XTRNTYPE"><code class="name">var <span class="ident">AS_XTRNTYPE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Assembler understands type of extern symbols as ":type" suffix.</div></div>
</dd>
<dt id="ida_idp.CF_CALL"><code class="name">var <span class="ident">CF_CALL</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
CALL instruction (should make a procedure here)</div></div>
</dd>
<dt id="ida_idp.CF_CHG1"><code class="name">var <span class="ident">CF_CHG1</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
The instruction modifies the first operand.</div></div>
</dd>
<dt id="ida_idp.CF_CHG2"><code class="name">var <span class="ident">CF_CHG2</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
The instruction modifies the second operand.</div></div>
</dd>
<dt id="ida_idp.CF_CHG3"><code class="name">var <span class="ident">CF_CHG3</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
The instruction modifies the third operand.</div></div>
</dd>
<dt id="ida_idp.CF_CHG4"><code class="name">var <span class="ident">CF_CHG4</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
The instruction modifies 4 operand.</div></div>
</dd>
<dt id="ida_idp.CF_CHG5"><code class="name">var <span class="ident">CF_CHG5</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
The instruction modifies 5 operand.</div></div>
</dd>
<dt id="ida_idp.CF_CHG6"><code class="name">var <span class="ident">CF_CHG6</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
The instruction modifies 6 operand.</div></div>
</dd>
<dt id="ida_idp.CF_CHG7"><code class="name">var <span class="ident">CF_CHG7</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
The instruction modifies the 7th operand.</div></div>
</dd>
<dt id="ida_idp.CF_CHG8"><code class="name">var <span class="ident">CF_CHG8</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
The instruction modifies the 8th operand.</div></div>
</dd>
<dt id="ida_idp.CF_HLL"><code class="name">var <span class="ident">CF_HLL</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Instruction may be present in a high level language function.</div></div>
</dd>
<dt id="ida_idp.CF_JUMP"><code class="name">var <span class="ident">CF_JUMP</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
The instruction passes execution using indirect jump or call (thus
needs additional analysis)</div></div>
</dd>
<dt id="ida_idp.CF_SHFT"><code class="name">var <span class="ident">CF_SHFT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Bit-shift instruction (shl,shr...)</div></div>
</dd>
<dt id="ida_idp.CF_STOP"><code class="name">var <span class="ident">CF_STOP</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Instruction doesn't pass execution to the next instruction</div></div>
</dd>
<dt id="ida_idp.CF_USE1"><code class="name">var <span class="ident">CF_USE1</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
The instruction uses value of the first operand.</div></div>
</dd>
<dt id="ida_idp.CF_USE2"><code class="name">var <span class="ident">CF_USE2</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
The instruction uses value of the second operand.</div></div>
</dd>
<dt id="ida_idp.CF_USE3"><code class="name">var <span class="ident">CF_USE3</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
The instruction uses value of the third operand.</div></div>
</dd>
<dt id="ida_idp.CF_USE4"><code class="name">var <span class="ident">CF_USE4</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
The instruction uses value of the 4 operand.</div></div>
</dd>
<dt id="ida_idp.CF_USE5"><code class="name">var <span class="ident">CF_USE5</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
The instruction uses value of the 5 operand.</div></div>
</dd>
<dt id="ida_idp.CF_USE6"><code class="name">var <span class="ident">CF_USE6</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
The instruction uses value of the 6 operand.</div></div>
</dd>
<dt id="ida_idp.CF_USE7"><code class="name">var <span class="ident">CF_USE7</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
The instruction uses value of the 7th operand.</div></div>
</dd>
<dt id="ida_idp.CF_USE8"><code class="name">var <span class="ident">CF_USE8</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
The instruction uses value of the 8th operand.</div></div>
</dd>
<dt id="ida_idp.CUSTOM_INSN_ITYPE"><code class="name">var <span class="ident">CUSTOM_INSN_ITYPE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Custom instruction codes defined by processor extension plugins must
be greater than or equal to this</div></div>
</dd>
<dt id="ida_idp.HKCB_GLOBAL"><code class="name">var <span class="ident">HKCB_GLOBAL</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
is global event listener? if true, the listener will survive database
closing and opening. it will stay in the memory until explicitly
unhooked. otherwise the kernel will delete it as soon as the owner is
unloaded. should be used only with PLUGIN_FIX plugins.</div></div>
</dd>
<dt id="ida_idp.IDPOPT_BADKEY"><code class="name">var <span class="ident">IDPOPT_BADKEY</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
IDPOPT_BADKEY = 1</div></div>
</dd>
<dt id="ida_idp.IDPOPT_BADTYPE"><code class="name">var <span class="ident">IDPOPT_BADTYPE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
IDPOPT_BADTYPE = 2</div></div>
</dd>
<dt id="ida_idp.IDPOPT_BADVALUE"><code class="name">var <span class="ident">IDPOPT_BADVALUE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
IDPOPT_BADVALUE = 3</div></div>
</dd>
<dt id="ida_idp.IDPOPT_BIT"><code class="name">var <span class="ident">IDPOPT_BIT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
IDPOPT_BIT = 3</div></div>
</dd>
<dt id="ida_idp.IDPOPT_BIT_BOOL"><code class="name">var <span class="ident">IDPOPT_BIT_BOOL</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
IDPOPT_BIT_BOOL = 50331648</div></div>
</dd>
<dt id="ida_idp.IDPOPT_BIT_UCHAR"><code class="name">var <span class="ident">IDPOPT_BIT_UCHAR</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
IDPOPT_BIT_UCHAR = 16777216</div></div>
</dd>
<dt id="ida_idp.IDPOPT_BIT_UINT"><code class="name">var <span class="ident">IDPOPT_BIT_UINT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
IDPOPT_BIT_UINT = 0</div></div>
</dd>
<dt id="ida_idp.IDPOPT_BIT_USHORT"><code class="name">var <span class="ident">IDPOPT_BIT_USHORT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
IDPOPT_BIT_USHORT = 33554432</div></div>
</dd>
<dt id="ida_idp.IDPOPT_CST"><code class="name">var <span class="ident">IDPOPT_CST</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
IDPOPT_CST = 6</div></div>
</dd>
<dt id="ida_idp.IDPOPT_CST_PARAMS"><code class="name">var <span class="ident">IDPOPT_CST_PARAMS</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
IDPOPT_CST_PARAMS = 16777216</div></div>
</dd>
<dt id="ida_idp.IDPOPT_FLT"><code class="name">var <span class="ident">IDPOPT_FLT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
IDPOPT_FLT = 4</div></div>
</dd>
<dt id="ida_idp.IDPOPT_I64"><code class="name">var <span class="ident">IDPOPT_I64</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
IDPOPT_I64 = 5</div></div>
</dd>
<dt id="ida_idp.IDPOPT_I64_RANGES"><code class="name">var <span class="ident">IDPOPT_I64_RANGES</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
IDPOPT_I64_RANGES = 16777216</div></div>
</dd>
<dt id="ida_idp.IDPOPT_I64_UNS"><code class="name">var <span class="ident">IDPOPT_I64_UNS</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
IDPOPT_I64_UNS = 33554432</div></div>
</dd>
<dt id="ida_idp.IDPOPT_MBROFF"><code class="name">var <span class="ident">IDPOPT_MBROFF</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
IDPOPT_MBROFF = 262144</div></div>
</dd>
<dt id="ida_idp.IDPOPT_NUM"><code class="name">var <span class="ident">IDPOPT_NUM</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
IDPOPT_NUM = 2</div></div>
</dd>
<dt id="ida_idp.IDPOPT_NUM_CHAR"><code class="name">var <span class="ident">IDPOPT_NUM_CHAR</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
IDPOPT_NUM_CHAR = 16777216</div></div>
</dd>
<dt id="ida_idp.IDPOPT_NUM_INT"><code class="name">var <span class="ident">IDPOPT_NUM_INT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
IDPOPT_NUM_INT = 0</div></div>
</dd>
<dt id="ida_idp.IDPOPT_NUM_RANGE"><code class="name">var <span class="ident">IDPOPT_NUM_RANGE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
IDPOPT_NUM_RANGE = 67108864</div></div>
</dd>
<dt id="ida_idp.IDPOPT_NUM_SHORT"><code class="name">var <span class="ident">IDPOPT_NUM_SHORT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
IDPOPT_NUM_SHORT = 33554432</div></div>
</dd>
<dt id="ida_idp.IDPOPT_NUM_UNS"><code class="name">var <span class="ident">IDPOPT_NUM_UNS</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
IDPOPT_NUM_UNS = 134217728</div></div>
</dd>
<dt id="ida_idp.IDPOPT_OK"><code class="name">var <span class="ident">IDPOPT_OK</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
IDPOPT_OK = 0</div></div>
</dd>
<dt id="ida_idp.IDPOPT_PRI_DEFAULT"><code class="name">var <span class="ident">IDPOPT_PRI_DEFAULT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
IDPOPT_PRI_DEFAULT = 1</div></div>
</dd>
<dt id="ida_idp.IDPOPT_PRI_HIGH"><code class="name">var <span class="ident">IDPOPT_PRI_HIGH</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
IDPOPT_PRI_HIGH = 2</div></div>
</dd>
<dt id="ida_idp.IDPOPT_STR"><code class="name">var <span class="ident">IDPOPT_STR</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
IDPOPT_STR = 1</div></div>
</dd>
<dt id="ida_idp.IDPOPT_STR_LONG"><code class="name">var <span class="ident">IDPOPT_STR_LONG</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
IDPOPT_STR_LONG = 33554432</div></div>
</dd>
<dt id="ida_idp.IDPOPT_STR_QSTRING"><code class="name">var <span class="ident">IDPOPT_STR_QSTRING</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
IDPOPT_STR_QSTRING = 16777216</div></div>
</dd>
<dt id="ida_idp.IDP_INTERFACE_VERSION"><code class="name">var <span class="ident">IDP_INTERFACE_VERSION</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
The interface version number.see also 'IDA_SDK_VERSION' from 'pro.h'</div></div>
</dd>
<dt id="ida_idp.NO_ACCESS"><code class="name">var <span class="ident">NO_ACCESS</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
NO_ACCESS = 0</div></div>
</dd>
<dt id="ida_idp.OP_FP_BASED"><code class="name">var <span class="ident">OP_FP_BASED</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
operand is FP based</div></div>
</dd>
<dt id="ida_idp.OP_SP_ADD"><code class="name">var <span class="ident">OP_SP_ADD</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
operand value is added to the pointer</div></div>
</dd>
<dt id="ida_idp.OP_SP_BASED"><code class="name">var <span class="ident">OP_SP_BASED</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
operand is SP based</div></div>
</dd>
<dt id="ida_idp.OP_SP_SUB"><code class="name">var <span class="ident">OP_SP_SUB</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
operand value is subtracted from the pointer</div></div>
</dd>
<dt id="ida_idp.PLFM_386"><code class="name">var <span class="ident">PLFM_386</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Intel 80x86.</div></div>
</dd>
<dt id="ida_idp.PLFM_6502"><code class="name">var <span class="ident">PLFM_6502</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
6502</div></div>
</dd>
<dt id="ida_idp.PLFM_65C816"><code class="name">var <span class="ident">PLFM_65C816</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
65802/65816</div></div>
</dd>
<dt id="ida_idp.PLFM_6800"><code class="name">var <span class="ident">PLFM_6800</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Motorola 68xx.</div></div>
</dd>
<dt id="ida_idp.PLFM_68K"><code class="name">var <span class="ident">PLFM_68K</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Motorola 680x0.</div></div>
</dd>
<dt id="ida_idp.PLFM_80196"><code class="name">var <span class="ident">PLFM_80196</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Intel 80196.</div></div>
</dd>
<dt id="ida_idp.PLFM_8051"><code class="name">var <span class="ident">PLFM_8051</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
8051</div></div>
</dd>
<dt id="ida_idp.PLFM_AD2106X"><code class="name">var <span class="ident">PLFM_AD2106X</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Analog Devices ADSP 2106X.</div></div>
</dd>
<dt id="ida_idp.PLFM_AD218X"><code class="name">var <span class="ident">PLFM_AD218X</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Analog Devices ADSP 218X.</div></div>
</dd>
<dt id="ida_idp.PLFM_ALPHA"><code class="name">var <span class="ident">PLFM_ALPHA</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
DEC Alpha.</div></div>
</dd>
<dt id="ida_idp.PLFM_ARC"><code class="name">var <span class="ident">PLFM_ARC</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Argonaut RISC Core.</div></div>
</dd>
<dt id="ida_idp.PLFM_ARM"><code class="name">var <span class="ident">PLFM_ARM</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Advanced RISC Machines.</div></div>
</dd>
<dt id="ida_idp.PLFM_AVR"><code class="name">var <span class="ident">PLFM_AVR</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Atmel 8-bit RISC processor(s)</div></div>
</dd>
<dt id="ida_idp.PLFM_C166"><code class="name">var <span class="ident">PLFM_C166</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Siemens C166 family.</div></div>
</dd>
<dt id="ida_idp.PLFM_C39"><code class="name">var <span class="ident">PLFM_C39</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Rockwell C39.</div></div>
</dd>
<dt id="ida_idp.PLFM_CR16"><code class="name">var <span class="ident">PLFM_CR16</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
NSC CR16.</div></div>
</dd>
<dt id="ida_idp.PLFM_DALVIK"><code class="name">var <span class="ident">PLFM_DALVIK</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Android Dalvik Virtual Machine.</div></div>
</dd>
<dt id="ida_idp.PLFM_DSP56K"><code class="name">var <span class="ident">PLFM_DSP56K</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Motorola DSP5600x.</div></div>
</dd>
<dt id="ida_idp.PLFM_DSP96K"><code class="name">var <span class="ident">PLFM_DSP96K</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Motorola DSP96000.</div></div>
</dd>
<dt id="ida_idp.PLFM_EBC"><code class="name">var <span class="ident">PLFM_EBC</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
EFI Bytecode.</div></div>
</dd>
<dt id="ida_idp.PLFM_F2MC"><code class="name">var <span class="ident">PLFM_F2MC</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Fujistu F2MC-16.</div></div>
</dd>
<dt id="ida_idp.PLFM_FR"><code class="name">var <span class="ident">PLFM_FR</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Fujitsu FR Family.</div></div>
</dd>
<dt id="ida_idp.PLFM_H8"><code class="name">var <span class="ident">PLFM_H8</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Hitachi H8/300, H8/2000.</div></div>
</dd>
<dt id="ida_idp.PLFM_H8500"><code class="name">var <span class="ident">PLFM_H8500</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Hitachi H8/500.</div></div>
</dd>
<dt id="ida_idp.PLFM_HPPA"><code class="name">var <span class="ident">PLFM_HPPA</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Hewlett-Packard PA-RISC.</div></div>
</dd>
<dt id="ida_idp.PLFM_I860"><code class="name">var <span class="ident">PLFM_I860</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Intel 860.</div></div>
</dd>
<dt id="ida_idp.PLFM_I960"><code class="name">var <span class="ident">PLFM_I960</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Intel 960.</div></div>
</dd>
<dt id="ida_idp.PLFM_IA64"><code class="name">var <span class="ident">PLFM_IA64</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Intel Itanium IA64.</div></div>
</dd>
<dt id="ida_idp.PLFM_JAVA"><code class="name">var <span class="ident">PLFM_JAVA</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Java.</div></div>
</dd>
<dt id="ida_idp.PLFM_KR1878"><code class="name">var <span class="ident">PLFM_KR1878</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Angstrem KR1878.</div></div>
</dd>
<dt id="ida_idp.PLFM_M16C"><code class="name">var <span class="ident">PLFM_M16C</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Renesas M16C.</div></div>
</dd>
<dt id="ida_idp.PLFM_M32R"><code class="name">var <span class="ident">PLFM_M32R</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Mitsubishi 32bit RISC.</div></div>
</dd>
<dt id="ida_idp.PLFM_M740"><code class="name">var <span class="ident">PLFM_M740</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Mitsubishi 8bit.</div></div>
</dd>
<dt id="ida_idp.PLFM_M7700"><code class="name">var <span class="ident">PLFM_M7700</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Mitsubishi 16bit.</div></div>
</dd>
<dt id="ida_idp.PLFM_M7900"><code class="name">var <span class="ident">PLFM_M7900</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Mitsubishi 7900.</div></div>
</dd>
<dt id="ida_idp.PLFM_MC6812"><code class="name">var <span class="ident">PLFM_MC6812</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Motorola 68HC12.</div></div>
</dd>
<dt id="ida_idp.PLFM_MC6816"><code class="name">var <span class="ident">PLFM_MC6816</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Motorola 68HC16.</div></div>
</dd>
<dt id="ida_idp.PLFM_MIPS"><code class="name">var <span class="ident">PLFM_MIPS</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
MIPS.</div></div>
</dd>
<dt id="ida_idp.PLFM_MN102L00"><code class="name">var <span class="ident">PLFM_MN102L00</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Panasonic MN10200.</div></div>
</dd>
<dt id="ida_idp.PLFM_MSP430"><code class="name">var <span class="ident">PLFM_MSP430</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Texas Instruments MSP430.</div></div>
</dd>
<dt id="ida_idp.PLFM_NEC_78K0"><code class="name">var <span class="ident">PLFM_NEC_78K0</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
NEC 78K0.</div></div>
</dd>
<dt id="ida_idp.PLFM_NEC_78K0S"><code class="name">var <span class="ident">PLFM_NEC_78K0S</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
NEC 78K0S.</div></div>
</dd>
<dt id="ida_idp.PLFM_NEC_V850X"><code class="name">var <span class="ident">PLFM_NEC_V850X</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
NEC V850 and V850ES/E1/E2.</div></div>
</dd>
<dt id="ida_idp.PLFM_NET"><code class="name">var <span class="ident">PLFM_NET</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Microsoft Visual Studio.Net.</div></div>
</dd>
<dt id="ida_idp.PLFM_OAKDSP"><code class="name">var <span class="ident">PLFM_OAKDSP</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Atmel OAK DSP.</div></div>
</dd>
<dt id="ida_idp.PLFM_PDP"><code class="name">var <span class="ident">PLFM_PDP</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
PDP11.</div></div>
</dd>
<dt id="ida_idp.PLFM_PIC"><code class="name">var <span class="ident">PLFM_PIC</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Microchip's PIC.</div></div>
</dd>
<dt id="ida_idp.PLFM_PIC16"><code class="name">var <span class="ident">PLFM_PIC16</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Microchip's 16-bit PIC.</div></div>
</dd>
<dt id="ida_idp.PLFM_PPC"><code class="name">var <span class="ident">PLFM_PPC</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
PowerPC.</div></div>
</dd>
<dt id="ida_idp.PLFM_RISCV"><code class="name">var <span class="ident">PLFM_RISCV</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
RISC-V.</div></div>
</dd>
<dt id="ida_idp.PLFM_RL78"><code class="name">var <span class="ident">PLFM_RL78</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Renesas RL78.</div></div>
</dd>
<dt id="ida_idp.PLFM_S390"><code class="name">var <span class="ident">PLFM_S390</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
IBM's S390.</div></div>
</dd>
<dt id="ida_idp.PLFM_SCR_ADPT"><code class="name">var <span class="ident">PLFM_SCR_ADPT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Processor module adapter for processor modules written in scripting
languages.</div></div>
</dd>
<dt id="ida_idp.PLFM_SH"><code class="name">var <span class="ident">PLFM_SH</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Renesas (formerly Hitachi) SuperH.</div></div>
</dd>
<dt id="ida_idp.PLFM_SPARC"><code class="name">var <span class="ident">PLFM_SPARC</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
SPARC.</div></div>
</dd>
<dt id="ida_idp.PLFM_SPC700"><code class="name">var <span class="ident">PLFM_SPC700</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Sony SPC700.</div></div>
</dd>
<dt id="ida_idp.PLFM_SPU"><code class="name">var <span class="ident">PLFM_SPU</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Cell Broadband Engine Synergistic Processor Unit.</div></div>
</dd>
<dt id="ida_idp.PLFM_ST20"><code class="name">var <span class="ident">PLFM_ST20</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
SGS-Thomson ST20.</div></div>
</dd>
<dt id="ida_idp.PLFM_ST7"><code class="name">var <span class="ident">PLFM_ST7</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
SGS-Thomson ST7.</div></div>
</dd>
<dt id="ida_idp.PLFM_ST9"><code class="name">var <span class="ident">PLFM_ST9</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
ST9+.</div></div>
</dd>
<dt id="ida_idp.PLFM_TLCS900"><code class="name">var <span class="ident">PLFM_TLCS900</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Toshiba TLCS-900.</div></div>
</dd>
<dt id="ida_idp.PLFM_TMS"><code class="name">var <span class="ident">PLFM_TMS</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Texas Instruments TMS320C5x.</div></div>
</dd>
<dt id="ida_idp.PLFM_TMS320C1X"><code class="name">var <span class="ident">PLFM_TMS320C1X</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Texas Instruments TMS320C1x.</div></div>
</dd>
<dt id="ida_idp.PLFM_TMS320C28"><code class="name">var <span class="ident">PLFM_TMS320C28</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Texas Instruments TMS320C28x.</div></div>
</dd>
<dt id="ida_idp.PLFM_TMS320C3"><code class="name">var <span class="ident">PLFM_TMS320C3</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Texas Instruments TMS320C3.</div></div>
</dd>
<dt id="ida_idp.PLFM_TMS320C54"><code class="name">var <span class="ident">PLFM_TMS320C54</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Texas Instruments TMS320C54xx.</div></div>
</dd>
<dt id="ida_idp.PLFM_TMS320C55"><code class="name">var <span class="ident">PLFM_TMS320C55</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Texas Instruments TMS320C55xx.</div></div>
</dd>
<dt id="ida_idp.PLFM_TMSC6"><code class="name">var <span class="ident">PLFM_TMSC6</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Texas Instruments TMS320C6x.</div></div>
</dd>
<dt id="ida_idp.PLFM_TRICORE"><code class="name">var <span class="ident">PLFM_TRICORE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Tasking Tricore.</div></div>
</dd>
<dt id="ida_idp.PLFM_TRIMEDIA"><code class="name">var <span class="ident">PLFM_TRIMEDIA</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Trimedia.</div></div>
</dd>
<dt id="ida_idp.PLFM_UNSP"><code class="name">var <span class="ident">PLFM_UNSP</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
SunPlus unSP.</div></div>
</dd>
<dt id="ida_idp.PLFM_XTENSA"><code class="name">var <span class="ident">PLFM_XTENSA</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Tensilica Xtensa.</div></div>
</dd>
<dt id="ida_idp.PLFM_Z8"><code class="name">var <span class="ident">PLFM_Z8</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Z8.</div></div>
</dd>
<dt id="ida_idp.PLFM_Z80"><code class="name">var <span class="ident">PLFM_Z80</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
8085, Z80</div></div>
</dd>
<dt id="ida_idp.PR2_CODE16_BIT"><code class="name">var <span class="ident">PR2_CODE16_BIT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
low bit of code addresses has special meaning e.g. ARM Thumb, MIPS16</div></div>
</dd>
<dt id="ida_idp.PR2_IDP_OPTS"><code class="name">var <span class="ident">PR2_IDP_OPTS</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
the module has processor-specific configuration options</div></div>
</dd>
<dt id="ida_idp.PR2_MACRO"><code class="name">var <span class="ident">PR2_MACRO</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
processor supports macro instructions</div></div>
</dd>
<dt id="ida_idp.PR2_MAPPINGS"><code class="name">var <span class="ident">PR2_MAPPINGS</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
the processor module uses memory mapping</div></div>
</dd>
<dt id="ida_idp.PR2_REALCVT"><code class="name">var <span class="ident">PR2_REALCVT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
the module has a custom 'ev_realcvt' implementation (otherwise
IEEE-754 format is assumed)</div></div>
</dd>
<dt id="ida_idp.PR2_REL_BITS"><code class="name">var <span class="ident">PR2_REL_BITS</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
(Lumina) calcrel info has bits granularity, not bytes - construction
flag only</div></div>
</dd>
<dt id="ida_idp.PR2_USE_CALCREL"><code class="name">var <span class="ident">PR2_USE_CALCREL</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
(Lumina) the module supports calcrel info</div></div>
</dd>
<dt id="ida_idp.PRN_BIN"><code class="name">var <span class="ident">PRN_BIN</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
binary</div></div>
</dd>
<dt id="ida_idp.PRN_DEC"><code class="name">var <span class="ident">PRN_DEC</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
decimal</div></div>
</dd>
<dt id="ida_idp.PRN_HEX"><code class="name">var <span class="ident">PRN_HEX</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
hex</div></div>
</dd>
<dt id="ida_idp.PRN_OCT"><code class="name">var <span class="ident">PRN_OCT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
octal</div></div>
</dd>
<dt id="ida_idp.PR_ADJSEGS"><code class="name">var <span class="ident">PR_ADJSEGS</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
IDA may adjust segments' starting/ending addresses.</div></div>
</dd>
<dt id="ida_idp.PR_ALIGN"><code class="name">var <span class="ident">PR_ALIGN</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
All data items should be aligned properly.</div></div>
</dd>
<dt id="ida_idp.PR_ALIGN_INSN"><code class="name">var <span class="ident">PR_ALIGN_INSN</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
allow ida to create alignment instructions arbitrarily. Since these
instructions might lead to other wrong instructions and spoil the
listing, IDA does not create them by default anymore</div></div>
</dd>
<dt id="ida_idp.PR_ASSEMBLE"><code class="name">var <span class="ident">PR_ASSEMBLE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Module has a built-in assembler and will react to ev_assemble.</div></div>
</dd>
<dt id="ida_idp.PR_BINMEM"><code class="name">var <span class="ident">PR_BINMEM</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
the processor module provides correct segmentation for binary files
(i.e. it creates additional segments) The kernel will not ask the user
to specify the RAM/ROM sizes</div></div>
</dd>
<dt id="ida_idp.PR_CHK_XREF"><code class="name">var <span class="ident">PR_CHK_XREF</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
don't allow near xrefs between segments with different bases</div></div>
</dd>
<dt id="ida_idp.PR_CNDINSNS"><code class="name">var <span class="ident">PR_CNDINSNS</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
has conditional instructions</div></div>
</dd>
<dt id="ida_idp.PR_DEFNUM"><code class="name">var <span class="ident">PR_DEFNUM</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
mask - default number representation</div></div>
</dd>
<dt id="ida_idp.PR_DEFSEG32"><code class="name">var <span class="ident">PR_DEFSEG32</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
segments are 32-bit by default</div></div>
</dd>
<dt id="ida_idp.PR_DEFSEG64"><code class="name">var <span class="ident">PR_DEFSEG64</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
segments are 64-bit by default</div></div>
</dd>
<dt id="ida_idp.PR_DELAYED"><code class="name">var <span class="ident">PR_DELAYED</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
has delayed jumps and calls if this flag is set,</div>
<div class="epy_par">
\ph{is_basic_block_end}<div class="epy_nested">
, \ph{has_delay_slot} should be implemented</div>
</div></div>
</dd>
<dt id="ida_idp.PR_NOCHANGE"><code class="name">var <span class="ident">PR_NOCHANGE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
The user can't change segments and code/data attributes (display only)</div></div>
</dd>
<dt id="ida_idp.PR_NO_SEGMOVE"><code class="name">var <span class="ident">PR_NO_SEGMOVE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
the processor module doesn't support 'move_segm()' (i.e. the user
can't move segments)</div></div>
</dd>
<dt id="ida_idp.PR_OUTER"><code class="name">var <span class="ident">PR_OUTER</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
has outer operands (currently only mc68k)</div></div>
</dd>
<dt id="ida_idp.PR_PURGING"><code class="name">var <span class="ident">PR_PURGING</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
there are calling conventions which may purge bytes from the stack</div></div>
</dd>
<dt id="ida_idp.PR_RNAMESOK"><code class="name">var <span class="ident">PR_RNAMESOK</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
allow user register names for location names</div></div>
</dd>
<dt id="ida_idp.PR_SCALE_STKVARS"><code class="name">var <span class="ident">PR_SCALE_STKVARS</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
use \ph{get_stkvar_scale}
callback</div></div>
</dd>
<dt id="ida_idp.PR_SEGS"><code class="name">var <span class="ident">PR_SEGS</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
has segment registers?</div></div>
</dd>
<dt id="ida_idp.PR_SEGTRANS"><code class="name">var <span class="ident">PR_SEGTRANS</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
the processor module supports the segment translation feature (meaning
it calculates the code addresses using the 'map_code_ea()' function)</div></div>
</dd>
<dt id="ida_idp.PR_SGROTHER"><code class="name">var <span class="ident">PR_SGROTHER</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
the segment registers don't contain the segment selectors.</div></div>
</dd>
<dt id="ida_idp.PR_STACK_UP"><code class="name">var <span class="ident">PR_STACK_UP</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
the stack grows up</div></div>
</dd>
<dt id="ida_idp.PR_TYPEINFO"><code class="name">var <span class="ident">PR_TYPEINFO</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
the processor module supports type information callbacks ALL OF THEM
SHOULD BE IMPLEMENTED!</div></div>
</dd>
<dt id="ida_idp.PR_USE32"><code class="name">var <span class="ident">PR_USE32</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
supports 32-bit addressing?</div></div>
</dd>
<dt id="ida_idp.PR_USE64"><code class="name">var <span class="ident">PR_USE64</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
supports 64-bit addressing?</div></div>
</dd>
<dt id="ida_idp.PR_USE_ARG_TYPES"><code class="name">var <span class="ident">PR_USE_ARG_TYPES</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
use \ph{use_arg_types}
callback</div></div>
</dd>
<dt id="ida_idp.PR_USE_TBYTE"><code class="name">var <span class="ident">PR_USE_TBYTE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
'BTMT_SPECFLT' means _TBYTE type</div></div>
</dd>
<dt id="ida_idp.PR_WORD_INS"><code class="name">var <span class="ident">PR_WORD_INS</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
instruction codes are grouped 2bytes in binary line prefix</div></div>
</dd>
<dt id="ida_idp.READ_ACCESS"><code class="name">var <span class="ident">READ_ACCESS</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
READ_ACCESS = 2</div></div>
</dd>
<dt id="ida_idp.REAL_ERROR_BADDATA"><code class="name">var <span class="ident">REAL_ERROR_BADDATA</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
REAL_ERROR_BADDATA = -3</div></div>
</dd>
<dt id="ida_idp.REAL_ERROR_FORMAT"><code class="name">var <span class="ident">REAL_ERROR_FORMAT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
REAL_ERROR_FORMAT = -1</div></div>
</dd>
<dt id="ida_idp.REAL_ERROR_RANGE"><code class="name">var <span class="ident">REAL_ERROR_RANGE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
REAL_ERROR_RANGE = -2</div></div>
</dd>
<dt id="ida_idp.REG_SPOIL"><code class="name">var <span class="ident">REG_SPOIL</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
processor_t::use_regarg_type uses this bit in the return value to
indicate that the register value has been spoiled</div></div>
</dd>
<dt id="ida_idp.RW_ACCESS"><code class="name">var <span class="ident">RW_ACCESS</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
RW_ACCESS = 3</div></div>
</dd>
<dt id="ida_idp.SETPROC_IDB"><code class="name">var <span class="ident">SETPROC_IDB</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
SETPROC_IDB = 0</div></div>
</dd>
<dt id="ida_idp.SETPROC_LOADER"><code class="name">var <span class="ident">SETPROC_LOADER</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
SETPROC_LOADER = 1</div></div>
</dd>
<dt id="ida_idp.SETPROC_LOADER_NON_FATAL"><code class="name">var <span class="ident">SETPROC_LOADER_NON_FATAL</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
SETPROC_LOADER_NON_FATAL = 2</div></div>
</dd>
<dt id="ida_idp.SETPROC_USER"><code class="name">var <span class="ident">SETPROC_USER</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
SETPROC_USER = 3</div></div>
</dd>
<dt id="ida_idp.WRITE_ACCESS"><code class="name">var <span class="ident">WRITE_ACCESS</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
WRITE_ACCESS = 1</div></div>
</dd>
<dt id="ida_idp.adding_segm"><code class="name">var <span class="ident">adding_segm</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
adding_segm = 94</div></div>
</dd>
<dt id="ida_idp.allsegs_moved"><code class="name">var <span class="ident">allsegs_moved</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
allsegs_moved = 62</div></div>
</dd>
<dt id="ida_idp.auto_empty"><code class="name">var <span class="ident">auto_empty</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
auto_empty = 3</div></div>
</dd>
<dt id="ida_idp.auto_empty_finally"><code class="name">var <span class="ident">auto_empty_finally</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
auto_empty_finally = 4</div></div>
</dd>
<dt id="ida_idp.bookmark_changed"><code class="name">var <span class="ident">bookmark_changed</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
bookmark_changed = 92</div></div>
</dd>
<dt id="ida_idp.byte_patched"><code class="name">var <span class="ident">byte_patched</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
byte_patched = 84</div></div>
</dd>
<dt id="ida_idp.callee_addr_changed"><code class="name">var <span class="ident">callee_addr_changed</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
callee_addr_changed = 91</div></div>
</dd>
<dt id="ida_idp.changing_cmt"><code class="name">var <span class="ident">changing_cmt</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
changing_cmt = 85</div></div>
</dd>
<dt id="ida_idp.changing_enum_bf"><code class="name">var <span class="ident">changing_enum_bf</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
changing_enum_bf = 24</div></div>
</dd>
<dt id="ida_idp.changing_enum_cmt"><code class="name">var <span class="ident">changing_enum_cmt</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
changing_enum_cmt = 26</div></div>
</dd>
<dt id="ida_idp.changing_op_ti"><code class="name">var <span class="ident">changing_op_ti</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
changing_op_ti = 15</div></div>
</dd>
<dt id="ida_idp.changing_op_type"><code class="name">var <span class="ident">changing_op_type</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
changing_op_type = 17</div></div>
</dd>
<dt id="ida_idp.changing_range_cmt"><code class="name">var <span class="ident">changing_range_cmt</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
changing_range_cmt = 87</div></div>
</dd>
<dt id="ida_idp.changing_segm_class"><code class="name">var <span class="ident">changing_segm_class</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
changing_segm_class = 58</div></div>
</dd>
<dt id="ida_idp.changing_segm_end"><code class="name">var <span class="ident">changing_segm_end</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
changing_segm_end = 54</div></div>
</dd>
<dt id="ida_idp.changing_segm_name"><code class="name">var <span class="ident">changing_segm_name</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
changing_segm_name = 56</div></div>
</dd>
<dt id="ida_idp.changing_segm_start"><code class="name">var <span class="ident">changing_segm_start</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
changing_segm_start = 52</div></div>
</dd>
<dt id="ida_idp.changing_struc_align"><code class="name">var <span class="ident">changing_struc_align</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
changing_struc_align = 34</div></div>
</dd>
<dt id="ida_idp.changing_struc_cmt"><code class="name">var <span class="ident">changing_struc_cmt</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
changing_struc_cmt = 47</div></div>
</dd>
<dt id="ida_idp.changing_struc_member"><code class="name">var <span class="ident">changing_struc_member</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
changing_struc_member = 45</div></div>
</dd>
<dt id="ida_idp.changing_ti"><code class="name">var <span class="ident">changing_ti</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
changing_ti = 13</div></div>
</dd>
<dt id="ida_idp.closebase"><code class="name">var <span class="ident">closebase</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
closebase = 0</div></div>
</dd>
<dt id="ida_idp.cmt_changed"><code class="name">var <span class="ident">cmt_changed</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
cmt_changed = 86</div></div>
</dd>
<dt id="ida_idp.compiler_changed"><code class="name">var <span class="ident">compiler_changed</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
compiler_changed = 12</div></div>
</dd>
<dt id="ida_idp.deleting_enum"><code class="name">var <span class="ident">deleting_enum</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
deleting_enum = 20</div></div>
</dd>
<dt id="ida_idp.deleting_enum_member"><code class="name">var <span class="ident">deleting_enum_member</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
deleting_enum_member = 29</div></div>
</dd>
<dt id="ida_idp.deleting_func"><code class="name">var <span class="ident">deleting_func</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
deleting_func = 67</div></div>
</dd>
<dt id="ida_idp.deleting_func_tail"><code class="name">var <span class="ident">deleting_func_tail</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
deleting_func_tail = 71</div></div>
</dd>
<dt id="ida_idp.deleting_segm"><code class="name">var <span class="ident">deleting_segm</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
deleting_segm = 50</div></div>
</dd>
<dt id="ida_idp.deleting_struc"><code class="name">var <span class="ident">deleting_struc</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
deleting_struc = 32</div></div>
</dd>
<dt id="ida_idp.deleting_struc_member"><code class="name">var <span class="ident">deleting_struc_member</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
deleting_struc_member = 41</div></div>
</dd>
<dt id="ida_idp.deleting_tryblks"><code class="name">var <span class="ident">deleting_tryblks</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
deleting_tryblks = 78</div></div>
</dd>
<dt id="ida_idp.destroyed_items"><code class="name">var <span class="ident">destroyed_items</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
destroyed_items = 82</div></div>
</dd>
<dt id="ida_idp.determined_main"><code class="name">var <span class="ident">determined_main</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
determined_main = 5</div></div>
</dd>
<dt id="ida_idp.dirtree_link"><code class="name">var <span class="ident">dirtree_link</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
dirtree_link = 98</div></div>
</dd>
<dt id="ida_idp.dirtree_mkdir"><code class="name">var <span class="ident">dirtree_mkdir</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
dirtree_mkdir = 96</div></div>
</dd>
<dt id="ida_idp.dirtree_move"><code class="name">var <span class="ident">dirtree_move</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
dirtree_move = 99</div></div>
</dd>
<dt id="ida_idp.dirtree_rank"><code class="name">var <span class="ident">dirtree_rank</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
dirtree_rank = 100</div></div>
</dd>
<dt id="ida_idp.dirtree_rmdir"><code class="name">var <span class="ident">dirtree_rmdir</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
dirtree_rmdir = 97</div></div>
</dd>
<dt id="ida_idp.dirtree_rminode"><code class="name">var <span class="ident">dirtree_rminode</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
dirtree_rminode = 101</div></div>
</dd>
<dt id="ida_idp.dirtree_segm_moved"><code class="name">var <span class="ident">dirtree_segm_moved</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
dirtree_segm_moved = 102</div></div>
</dd>
<dt id="ida_idp.enum_bf_changed"><code class="name">var <span class="ident">enum_bf_changed</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
enum_bf_changed = 25</div></div>
</dd>
<dt id="ida_idp.enum_cmt_changed"><code class="name">var <span class="ident">enum_cmt_changed</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
enum_cmt_changed = 27</div></div>
</dd>
<dt id="ida_idp.enum_created"><code class="name">var <span class="ident">enum_created</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
enum_created = 19</div></div>
</dd>
<dt id="ida_idp.enum_deleted"><code class="name">var <span class="ident">enum_deleted</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
enum_deleted = 21</div></div>
</dd>
<dt id="ida_idp.enum_member_created"><code class="name">var <span class="ident">enum_member_created</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
enum_member_created = 28</div></div>
</dd>
<dt id="ida_idp.enum_member_deleted"><code class="name">var <span class="ident">enum_member_deleted</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
enum_member_deleted = 30</div></div>
</dd>
<dt id="ida_idp.enum_renamed"><code class="name">var <span class="ident">enum_renamed</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
enum_renamed = 23</div></div>
</dd>
<dt id="ida_idp.expanding_struc"><code class="name">var <span class="ident">expanding_struc</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
expanding_struc = 38</div></div>
</dd>
<dt id="ida_idp.extlang_changed"><code class="name">var <span class="ident">extlang_changed</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
extlang_changed = 7</div></div>
</dd>
<dt id="ida_idp.extra_cmt_changed"><code class="name">var <span class="ident">extra_cmt_changed</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
extra_cmt_changed = 89</div></div>
</dd>
<dt id="ida_idp.flow_chart_created"><code class="name">var <span class="ident">flow_chart_created</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
flow_chart_created = 11</div></div>
</dd>
<dt id="ida_idp.frame_deleted"><code class="name">var <span class="ident">frame_deleted</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
frame_deleted = 68</div></div>
</dd>
<dt id="ida_idp.func_added"><code class="name">var <span class="ident">func_added</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
func_added = 63</div></div>
</dd>
<dt id="ida_idp.func_deleted"><code class="name">var <span class="ident">func_deleted</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
func_deleted = 95</div></div>
</dd>
<dt id="ida_idp.func_noret_changed"><code class="name">var <span class="ident">func_noret_changed</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
func_noret_changed = 74</div></div>
</dd>
<dt id="ida_idp.func_tail_appended"><code class="name">var <span class="ident">func_tail_appended</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
func_tail_appended = 70</div></div>
</dd>
<dt id="ida_idp.func_tail_deleted"><code class="name">var <span class="ident">func_tail_deleted</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
func_tail_deleted = 72</div></div>
</dd>
<dt id="ida_idp.func_updated"><code class="name">var <span class="ident">func_updated</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
func_updated = 64</div></div>
</dd>
<dt id="ida_idp.idasgn_loaded"><code class="name">var <span class="ident">idasgn_loaded</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
idasgn_loaded = 8</div></div>
</dd>
<dt id="ida_idp.item_color_changed"><code class="name">var <span class="ident">item_color_changed</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
item_color_changed = 90</div></div>
</dd>
<dt id="ida_idp.kernel_config_loaded"><code class="name">var <span class="ident">kernel_config_loaded</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
kernel_config_loaded = 9</div></div>
</dd>
<dt id="ida_idp.loader_finished"><code class="name">var <span class="ident">loader_finished</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
loader_finished = 10</div></div>
</dd>
<dt id="ida_idp.local_types_changed"><code class="name">var <span class="ident">local_types_changed</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
local_types_changed = 6</div></div>
</dd>
<dt id="ida_idp.make_code"><code class="name">var <span class="ident">make_code</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
make_code = 80</div></div>
</dd>
<dt id="ida_idp.make_data"><code class="name">var <span class="ident">make_data</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
make_data = 81</div></div>
</dd>
<dt id="ida_idp.op_ti_changed"><code class="name">var <span class="ident">op_ti_changed</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
op_ti_changed = 16</div></div>
</dd>
<dt id="ida_idp.op_type_changed"><code class="name">var <span class="ident">op_type_changed</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
op_type_changed = 18</div></div>
</dd>
<dt id="ida_idp.range_cmt_changed"><code class="name">var <span class="ident">range_cmt_changed</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
range_cmt_changed = 88</div></div>
</dd>
<dt id="ida_idp.renamed"><code class="name">var <span class="ident">renamed</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
renamed = 83</div></div>
</dd>
<dt id="ida_idp.renaming_enum"><code class="name">var <span class="ident">renaming_enum</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
renaming_enum = 22</div></div>
</dd>
<dt id="ida_idp.renaming_struc"><code class="name">var <span class="ident">renaming_struc</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
renaming_struc = 36</div></div>
</dd>
<dt id="ida_idp.renaming_struc_member"><code class="name">var <span class="ident">renaming_struc_member</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
renaming_struc_member = 43</div></div>
</dd>
<dt id="ida_idp.savebase"><code class="name">var <span class="ident">savebase</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
savebase = 1</div></div>
</dd>
<dt id="ida_idp.segm_added"><code class="name">var <span class="ident">segm_added</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
segm_added = 49</div></div>
</dd>
<dt id="ida_idp.segm_attrs_updated"><code class="name">var <span class="ident">segm_attrs_updated</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
segm_attrs_updated = 60</div></div>
</dd>
<dt id="ida_idp.segm_class_changed"><code class="name">var <span class="ident">segm_class_changed</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
segm_class_changed = 59</div></div>
</dd>
<dt id="ida_idp.segm_deleted"><code class="name">var <span class="ident">segm_deleted</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
segm_deleted = 51</div></div>
</dd>
<dt id="ida_idp.segm_end_changed"><code class="name">var <span class="ident">segm_end_changed</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
segm_end_changed = 55</div></div>
</dd>
<dt id="ida_idp.segm_moved"><code class="name">var <span class="ident">segm_moved</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
segm_moved = 61</div></div>
</dd>
<dt id="ida_idp.segm_name_changed"><code class="name">var <span class="ident">segm_name_changed</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
segm_name_changed = 57</div></div>
</dd>
<dt id="ida_idp.segm_start_changed"><code class="name">var <span class="ident">segm_start_changed</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
segm_start_changed = 53</div></div>
</dd>
<dt id="ida_idp.set_func_end"><code class="name">var <span class="ident">set_func_end</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
set_func_end = 66</div></div>
</dd>
<dt id="ida_idp.set_func_start"><code class="name">var <span class="ident">set_func_start</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
set_func_start = 65</div></div>
</dd>
<dt id="ida_idp.sgr_changed"><code class="name">var <span class="ident">sgr_changed</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
sgr_changed = 79</div></div>
</dd>
<dt id="ida_idp.sgr_deleted"><code class="name">var <span class="ident">sgr_deleted</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
sgr_deleted = 93</div></div>
</dd>
<dt id="ida_idp.stkpnts_changed"><code class="name">var <span class="ident">stkpnts_changed</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
stkpnts_changed = 75</div></div>
</dd>
<dt id="ida_idp.struc_align_changed"><code class="name">var <span class="ident">struc_align_changed</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
struc_align_changed = 35</div></div>
</dd>
<dt id="ida_idp.struc_cmt_changed"><code class="name">var <span class="ident">struc_cmt_changed</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
struc_cmt_changed = 48</div></div>
</dd>
<dt id="ida_idp.struc_created"><code class="name">var <span class="ident">struc_created</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
struc_created = 31</div></div>
</dd>
<dt id="ida_idp.struc_deleted"><code class="name">var <span class="ident">struc_deleted</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
struc_deleted = 33</div></div>
</dd>
<dt id="ida_idp.struc_expanded"><code class="name">var <span class="ident">struc_expanded</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
struc_expanded = 39</div></div>
</dd>
<dt id="ida_idp.struc_member_changed"><code class="name">var <span class="ident">struc_member_changed</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
struc_member_changed = 46</div></div>
</dd>
<dt id="ida_idp.struc_member_created"><code class="name">var <span class="ident">struc_member_created</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
struc_member_created = 40</div></div>
</dd>
<dt id="ida_idp.struc_member_deleted"><code class="name">var <span class="ident">struc_member_deleted</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
struc_member_deleted = 42</div></div>
</dd>
<dt id="ida_idp.struc_member_renamed"><code class="name">var <span class="ident">struc_member_renamed</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
struc_member_renamed = 44</div></div>
</dd>
<dt id="ida_idp.struc_renamed"><code class="name">var <span class="ident">struc_renamed</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
struc_renamed = 37</div></div>
</dd>
<dt id="ida_idp.tail_owner_changed"><code class="name">var <span class="ident">tail_owner_changed</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
tail_owner_changed = 73</div></div>
</dd>
<dt id="ida_idp.thunk_func_created"><code class="name">var <span class="ident">thunk_func_created</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
thunk_func_created = 69</div></div>
</dd>
<dt id="ida_idp.ti_changed"><code class="name">var <span class="ident">ti_changed</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
ti_changed = 14</div></div>
</dd>
<dt id="ida_idp.tryblks_updated"><code class="name">var <span class="ident">tryblks_updated</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
tryblks_updated = 77</div></div>
</dd>
<dt id="ida_idp.updating_tryblks"><code class="name">var <span class="ident">updating_tryblks</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
updating_tryblks = 76</div></div>
</dd>
<dt id="ida_idp.upgraded"><code class="name">var <span class="ident">upgraded</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
upgraded = 2</div></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="ida_idp.AssembleLine"><code class="name flex">
<span>def <span class="ident">AssembleLine</span></span>(<span>*args) &#8209;&gt;&#160;PyObject&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">AssembleLine(ea, cs, ip, use32, nonnul_line) -&gt; PyObject *</strong><div class="epy_nested">
Assemble an instruction to a string (display a warning if an error is found)</div>
<div class="epy_nested">
<strong class="epy_parameter">ea</strong>: linear address of instruction</div>
<div class="epy_nested">
<strong class="epy_parameter">cs</strong>:
cs of instruction</div>
<div class="epy_nested">
<strong class="epy_parameter">ip</strong>:
ip of instruction</div>
<div class="epy_nested">
<strong class="epy_parameter">use32</strong>: is 32bit segment</div>
<div class="epy_nested">
<strong class="epy_parameter">line</strong>: line to assemble</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>:<ul class="epy_ul">
<li class="epy_li"><span class="epy_nested">
None on failure</span>
</li>
<li class="epy_li"><span class="epy_nested">
or a string containing the assembled instruction</span>
</li>
</ul>
</div>
</div></div>
</dd>
<dt id="ida_idp.assemble"><code class="name flex">
<span>def <span class="ident">assemble</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">assemble(ea, cs, ip, use32, line) -&gt; bool</strong><div class="epy_nested">
Assemble an instruction into the database (display a warning if an error is found)</div>
<div class="epy_nested">
<strong class="epy_parameter">ea</strong>: linear address of instruction</div>
<div class="epy_nested">
<strong class="epy_parameter">cs</strong>: cs of instruction</div>
<div class="epy_nested">
<strong class="epy_parameter">ip</strong>: ip of instruction</div>
<div class="epy_nested">
<strong class="epy_parameter">use32</strong>: is 32bit segment?</div>
<div class="epy_nested">
<strong class="epy_parameter">line</strong>: line to assemble</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: Boolean. True on success.</div>
</div></div>
</dd>
<dt id="ida_idp.cfg_get_cc_header_path"><code class="name flex">
<span>def <span class="ident">cfg_get_cc_header_path</span></span>(<span>*args) &#8209;&gt;&#160;char&#160;const&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">cfg_get_cc_header_path(compid) -&gt; char const *</strong><div class="epy_nested">
compid: comp_t</div>
</div></div>
</dd>
<dt id="ida_idp.cfg_get_cc_parm"><code class="name flex">
<span>def <span class="ident">cfg_get_cc_parm</span></span>(<span>*args) &#8209;&gt;&#160;char&#160;const&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">cfg_get_cc_parm(compid, name) -&gt; char const *</strong><div class="epy_nested">
compid: comp_t
name: char const *</div>
</div></div>
</dd>
<dt id="ida_idp.cfg_get_cc_predefined_macros"><code class="name flex">
<span>def <span class="ident">cfg_get_cc_predefined_macros</span></span>(<span>*args) &#8209;&gt;&#160;char&#160;const&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">cfg_get_cc_predefined_macros(compid) -&gt; char const *</strong><div class="epy_nested">
compid: comp_t</div>
</div></div>
</dd>
<dt id="ida_idp.clr_module_data"><code class="name flex">
<span>def <span class="ident">clr_module_data</span></span>(<span>*args) &#8209;&gt;&#160;void&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Unregister pointer to database specific module data.</div>
<div class="epy_par">
<strong class="epy_sig">clr_module_data(data_id) -&gt; void *</strong><div class="epy_nested">
<strong class="epy_parameter">data_id</strong>: an data_id that was assigned by
set_module_data()<div class="epy_nested">
(C++: int)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: previously registered pointer for the current database. it<div class="epy_nested">
can be deallocated now. Multiple calls to this function with
the same id are forbidden.</div>
</div>
</div></div>
</dd>
<dt id="ida_idp.delay_slot_insn"><code class="name flex">
<span>def <span class="ident">delay_slot_insn</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">delay_slot_insn(ea, bexec, fexec) -&gt; bool</strong><div class="epy_nested">
ea: ea_t *
bexec: bool *
fexec: bool *</div>
</div></div>
</dd>
<dt id="ida_idp.gen_idb_event"><code class="name flex">
<span>def <span class="ident">gen_idb_event</span></span>(<span>*args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
the kernel will use this function to generate idb_events</div>
<div class="epy_par">
<strong class="epy_sig">gen_idb_event(code)</strong><div class="epy_nested">
<strong class="epy_parameter">code</strong> (C++: idb_event::event_code_t)</div>
</div></div>
</dd>
<dt id="ida_idp.get_ash"><code class="name flex">
<span>def <span class="ident">get_ash</span></span>(<span>*args) &#8209;&gt;&#160;<a title="ida_idp.asm_t" href="#ida_idp.asm_t">asm_t</a>&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">get_ash() -&gt; asm_t</strong></div></div>
</dd>
<dt id="ida_idp.get_idb_notifier_addr"><code class="name flex">
<span>def <span class="ident">get_idb_notifier_addr</span></span>(<span>*args) &#8209;&gt;&#160;PyObject&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">get_idb_notifier_addr(arg1) -&gt; PyObject *</strong><div class="epy_nested">
arg1: PyObject *</div>
</div></div>
</dd>
<dt id="ida_idp.get_idb_notifier_ud_addr"><code class="name flex">
<span>def <span class="ident">get_idb_notifier_ud_addr</span></span>(<span>*args) &#8209;&gt;&#160;PyObject&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">get_idb_notifier_ud_addr(hooks) -&gt; PyObject *</strong><div class="epy_nested">
hooks: IDB_Hooks *</div>
</div></div>
</dd>
<dt id="ida_idp.get_idp_name"><code class="name flex">
<span>def <span class="ident">get_idp_name</span></span>(<span>*args) &#8209;&gt;&#160;size_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get name of the current processor module. The name is derived from the
file name. For example, for IBM PC the module is named "pc.w32"
(windows version), then the module name is "PC" (uppercase). If no
processor module is loaded, this function will return NULL</div></div>
</dd>
<dt id="ida_idp.get_idp_notifier_addr"><code class="name flex">
<span>def <span class="ident">get_idp_notifier_addr</span></span>(<span>*args) &#8209;&gt;&#160;PyObject&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">get_idp_notifier_addr(arg1) -&gt; PyObject *</strong><div class="epy_nested">
arg1: PyObject *</div>
</div></div>
</dd>
<dt id="ida_idp.get_idp_notifier_ud_addr"><code class="name flex">
<span>def <span class="ident">get_idp_notifier_ud_addr</span></span>(<span>*args) &#8209;&gt;&#160;PyObject&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">get_idp_notifier_ud_addr(hooks) -&gt; PyObject *</strong><div class="epy_nested">
hooks: IDP_Hooks *</div>
</div></div>
</dd>
<dt id="ida_idp.get_module_data"><code class="name flex">
<span>def <span class="ident">get_module_data</span></span>(<span>*args) &#8209;&gt;&#160;void&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get pointer to the database specific module data.</div>
<div class="epy_par">
<strong class="epy_sig">get_module_data(data_id) -&gt; void *</strong><div class="epy_nested">
<strong class="epy_parameter">data_id</strong>: data id that was initialized by
set_module_data()<div class="epy_nested">
(C++: int)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: previously registered pointer for the current database</div>
</div></div>
</dd>
<dt id="ida_idp.get_ph"><code class="name flex">
<span>def <span class="ident">get_ph</span></span>(<span>*args) &#8209;&gt;&#160;<a title="ida_idp.processor_t" href="#ida_idp.processor_t">processor_t</a>&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">get_ph() -&gt; processor_t *</strong></div></div>
</dd>
<dt id="ida_idp.get_reg_info"><code class="name flex">
<span>def <span class="ident">get_reg_info</span></span>(<span>*args) &#8209;&gt;&#160;char&#160;const&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">get_reg_info(regname, bitrange) -&gt; char const *</strong><div class="epy_nested">
regname: char const *
bitrange: bitrange_t *</div>
</div></div>
</dd>
<dt id="ida_idp.get_reg_name"><code class="name flex">
<span>def <span class="ident">get_reg_name</span></span>(<span>*args) &#8209;&gt;&#160;qstring&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get text representation of a register. For most processors this
function will just return \ph{reg_names}
[reg]. If the processor module
has implemented processor_t::get_reg_name, it will be used instead</div>
<div class="epy_par">
<strong class="epy_sig">get_reg_name(reg, width, reghi=-1) -&gt; str</strong><div class="epy_nested">
<strong class="epy_parameter">reg</strong>: internal register number as defined in the processor<div class="epy_nested">
module (C++: int)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">width</strong>: register width in bytes (C++: size_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">reghi</strong>: if specified, then this function will return the<div class="epy_nested">
register pair (C++: int)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: length of register name in bytes or -1 if failure</div>
</div></div>
</dd>
<dt id="ida_idp.has_cf_chg"><code class="name flex">
<span>def <span class="ident">has_cf_chg</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Does an instruction with the specified feature modify the i-th
operand?</div>
<div class="epy_par">
<strong class="epy_sig">has_cf_chg(feature, opnum) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">feature</strong> (C++: uint32)</div>
<div class="epy_nested">
<strong class="epy_parameter">opnum</strong> (C++: uint)</div>
</div></div>
</dd>
<dt id="ida_idp.has_cf_use"><code class="name flex">
<span>def <span class="ident">has_cf_use</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Does an instruction with the specified feature use a value of the i-th
operand?</div>
<div class="epy_par">
<strong class="epy_sig">has_cf_use(feature, opnum) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">feature</strong> (C++: uint32)</div>
<div class="epy_nested">
<strong class="epy_parameter">opnum</strong> (C++: uint)</div>
</div></div>
</dd>
<dt id="ida_idp.has_insn_feature"><code class="name flex">
<span>def <span class="ident">has_insn_feature</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Does the specified instruction have the specified feature?</div>
<div class="epy_par">
<strong class="epy_sig">has_insn_feature(icode, bit) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">icode</strong> (C++: int)</div>
<div class="epy_nested">
<strong class="epy_parameter">bit</strong> (C++: uint32)</div>
</div></div>
</dd>
<dt id="ida_idp.is_align_insn"><code class="name flex">
<span>def <span class="ident">is_align_insn</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
If the instruction at 'ea' looks like an alignment instruction, return
its length in bytes. Otherwise return 0.</div>
<div class="epy_par">
<strong class="epy_sig">is_align_insn(ea) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
</div></div>
</dd>
<dt id="ida_idp.is_basic_block_end"><code class="name flex">
<span>def <span class="ident">is_basic_block_end</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is the instruction the end of a basic block?</div>
<div class="epy_par">
<strong class="epy_sig">is_basic_block_end(insn, call_insn_stops_block) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">insn</strong>
- an ida_ua.insn_t, or an address (C++: const insn_t &amp;)</div>
<div class="epy_nested">
<strong class="epy_parameter">call_insn_stops_block</strong> (C++: bool)</div>
</div></div>
</dd>
<dt id="ida_idp.is_call_insn"><code class="name flex">
<span>def <span class="ident">is_call_insn</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is the instruction a "call"?</div>
<div class="epy_par">
<strong class="epy_sig">is_call_insn(insn) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">insn</strong>
- an ida_ua.insn_t, or an address (C++: const insn_t &amp;)</div>
</div></div>
</dd>
<dt id="ida_idp.is_indirect_jump_insn"><code class="name flex">
<span>def <span class="ident">is_indirect_jump_insn</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is the instruction an indirect jump?</div>
<div class="epy_par">
<strong class="epy_sig">is_indirect_jump_insn(insn) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">insn</strong>
- an ida_ua.insn_t, or an address (C++: const insn_t &amp;)</div>
</div></div>
</dd>
<dt id="ida_idp.is_ret_insn"><code class="name flex">
<span>def <span class="ident">is_ret_insn</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is the instruction a "return"?</div>
<div class="epy_par">
<strong class="epy_sig">is_ret_insn(insn, strict=True) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">insn</strong>
- an ida_ua.insn_t, or an address (C++: const insn_t &amp;)</div>
<div class="epy_nested">
<strong class="epy_parameter">strict</strong> (C++: bool)</div>
</div></div>
</dd>
<dt id="ida_idp.parse_reg_name"><code class="name flex">
<span>def <span class="ident">parse_reg_name</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get register info by name.</div>
<div class="epy_par">
<strong class="epy_sig">parse_reg_name(ri, regname) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ri</strong>: result (C++: reg_info_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">regname</strong>: name of register (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: success</div>
</div></div>
</dd>
<dt id="ida_idp.ph_calcrel"><code class="name flex">
<span>def <span class="ident">ph_calcrel</span></span>(<span>*args) &#8209;&gt;&#160;bytevec_t&#160;*,&#160;size_t&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">ph_calcrel(ea)</strong><div class="epy_nested">
ea: ea_t</div>
</div></div>
</dd>
<dt id="ida_idp.ph_find_op_value"><code class="name flex">
<span>def <span class="ident">ph_find_op_value</span></span>(<span>*args) &#8209;&gt;&#160;uint32&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">ph_find_op_value(insn, op) -&gt; ssize_t</strong><div class="epy_nested">
insn: an ida_ua.insn_t, or an address (C++: const insn_t &amp;)
op: int</div>
</div></div>
</dd>
<dt id="ida_idp.ph_find_reg_value"><code class="name flex">
<span>def <span class="ident">ph_find_reg_value</span></span>(<span>*args) &#8209;&gt;&#160;uint32&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">ph_find_reg_value(insn, reg) -&gt; ssize_t</strong><div class="epy_nested">
insn: an ida_ua.insn_t, or an address (C++: const insn_t &amp;)
reg: int</div>
</div></div>
</dd>
<dt id="ida_idp.ph_get_cnbits"><code class="name flex">
<span>def <span class="ident">ph_get_cnbits</span></span>(<span>*args) &#8209;&gt;&#160;size_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">ph_get_cnbits() -&gt; size_t</strong><div class="epy_nested">
Returns the 'ph.cnbits'</div>
</div></div>
</dd>
<dt id="ida_idp.ph_get_dnbits"><code class="name flex">
<span>def <span class="ident">ph_get_dnbits</span></span>(<span>*args) &#8209;&gt;&#160;size_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">ph_get_dnbits() -&gt; size_t</strong><div class="epy_nested">
Returns the 'ph.dnbits'</div>
</div></div>
</dd>
<dt id="ida_idp.ph_get_flag"><code class="name flex">
<span>def <span class="ident">ph_get_flag</span></span>(<span>*args) &#8209;&gt;&#160;size_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">ph_get_flag() -&gt; size_t</strong><div class="epy_nested">
Returns the 'ph.flag'</div>
</div></div>
</dd>
<dt id="ida_idp.ph_get_icode_return"><code class="name flex">
<span>def <span class="ident">ph_get_icode_return</span></span>(<span>*args) &#8209;&gt;&#160;size_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">ph_get_icode_return() -&gt; size_t</strong><div class="epy_nested">
Returns the 'ph.icode_return'</div>
</div></div>
</dd>
<dt id="ida_idp.ph_get_id"><code class="name flex">
<span>def <span class="ident">ph_get_id</span></span>(<span>*args) &#8209;&gt;&#160;size_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">ph_get_id() -&gt; size_t</strong><div class="epy_nested">
Returns the 'ph.id' field</div>
</div></div>
</dd>
<dt id="ida_idp.ph_get_instruc"><code class="name flex">
<span>def <span class="ident">ph_get_instruc</span></span>(<span>*args) &#8209;&gt;&#160;PyObject&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">ph_get_instruc() -&gt; PyObject *</strong><div class="epy_nested">
Returns a list of tuples (instruction_name, instruction_feature) containing the
instructions list as defined in he processor module</div>
</div></div>
</dd>
<dt id="ida_idp.ph_get_instruc_end"><code class="name flex">
<span>def <span class="ident">ph_get_instruc_end</span></span>(<span>*args) &#8209;&gt;&#160;size_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">ph_get_instruc_end() -&gt; size_t</strong><div class="epy_nested">
Returns the 'ph.instruc_end'</div>
</div></div>
</dd>
<dt id="ida_idp.ph_get_instruc_start"><code class="name flex">
<span>def <span class="ident">ph_get_instruc_start</span></span>(<span>*args) &#8209;&gt;&#160;size_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">ph_get_instruc_start() -&gt; size_t</strong><div class="epy_nested">
Returns the 'ph.instruc_start'</div>
</div></div>
</dd>
<dt id="ida_idp.ph_get_operand_info"><code class="name flex">
<span>def <span class="ident">ph_get_operand_info</span></span>(<span>*args) &#8209;&gt;&#160;PyObject&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">ph_get_operand_info(ea, n) -&gt; PyObject *</strong><div class="epy_nested">
Returns the operand information given an ea and operand number.</div>
<div class="epy_nested">
<strong class="epy_parameter">ea</strong>: address</div>
<div class="epy_nested">
<strong class="epy_parameter">n</strong>: operand number</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: Returns an idd_opinfo_t as a tuple: (modified, ea, reg_ival, regidx, value_size).<div class="epy_nested">
Please refer to idd_opinfo_t structure in the SDK.</div>
</div>
</div></div>
</dd>
<dt id="ida_idp.ph_get_reg_accesses"><code class="name flex">
<span>def <span class="ident">ph_get_reg_accesses</span></span>(<span>*args) &#8209;&gt;&#160;ssize_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">ph_get_reg_accesses(accvec, insn, flags) -&gt; ssize_t</strong><div class="epy_nested">
accvec: reg_accesses_t *
insn: an ida_ua.insn_t, or an address (C++: const insn_t &amp;)
flags: int</div>
</div></div>
</dd>
<dt id="ida_idp.ph_get_reg_code_sreg"><code class="name flex">
<span>def <span class="ident">ph_get_reg_code_sreg</span></span>(<span>*args) &#8209;&gt;&#160;size_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">ph_get_reg_code_sreg() -&gt; size_t</strong><div class="epy_nested">
Returns the 'ph.reg_code_sreg'</div>
</div></div>
</dd>
<dt id="ida_idp.ph_get_reg_data_sreg"><code class="name flex">
<span>def <span class="ident">ph_get_reg_data_sreg</span></span>(<span>*args) &#8209;&gt;&#160;size_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">ph_get_reg_data_sreg() -&gt; size_t</strong><div class="epy_nested">
Returns the 'ph.reg_data_sreg'</div>
</div></div>
</dd>
<dt id="ida_idp.ph_get_reg_first_sreg"><code class="name flex">
<span>def <span class="ident">ph_get_reg_first_sreg</span></span>(<span>*args) &#8209;&gt;&#160;size_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">ph_get_reg_first_sreg() -&gt; size_t</strong><div class="epy_nested">
Returns the 'ph.reg_first_sreg'</div>
</div></div>
</dd>
<dt id="ida_idp.ph_get_reg_last_sreg"><code class="name flex">
<span>def <span class="ident">ph_get_reg_last_sreg</span></span>(<span>*args) &#8209;&gt;&#160;size_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">ph_get_reg_last_sreg() -&gt; size_t</strong><div class="epy_nested">
Returns the 'ph.reg_last_sreg'</div>
</div></div>
</dd>
<dt id="ida_idp.ph_get_regnames"><code class="name flex">
<span>def <span class="ident">ph_get_regnames</span></span>(<span>*args) &#8209;&gt;&#160;PyObject&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">ph_get_regnames() -&gt; PyObject *</strong><div class="epy_nested">
Returns the list of register names as defined in the processor module</div>
</div></div>
</dd>
<dt id="ida_idp.ph_get_segreg_size"><code class="name flex">
<span>def <span class="ident">ph_get_segreg_size</span></span>(<span>*args) &#8209;&gt;&#160;size_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">ph_get_segreg_size() -&gt; size_t</strong><div class="epy_nested">
Returns the 'ph.segreg_size'</div>
</div></div>
</dd>
<dt id="ida_idp.ph_get_tbyte_size"><code class="name flex">
<span>def <span class="ident">ph_get_tbyte_size</span></span>(<span>*args) &#8209;&gt;&#160;size_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">ph_get_tbyte_size() -&gt; size_t</strong><div class="epy_nested">
Returns the 'ph.tbyte_size' field as defined in he processor module</div>
</div></div>
</dd>
<dt id="ida_idp.ph_get_version"><code class="name flex">
<span>def <span class="ident">ph_get_version</span></span>(<span>*args) &#8209;&gt;&#160;size_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">ph_get_version() -&gt; size_t</strong><div class="epy_nested">
Returns the 'ph.version'</div>
</div></div>
</dd>
<dt id="ida_idp.process_config_directive"><code class="name flex">
<span>def <span class="ident">process_config_directive</span></span>(<span>*args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">process_config_directive(directive, priority=2)</strong><div class="epy_nested">
directive: char const *
priority: int</div>
</div></div>
</dd>
<dt id="ida_idp.register_cfgopts"><code class="name flex">
<span>def <span class="ident">register_cfgopts</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">register_cfgopts(opts, nopts, cb=None, obj=None) -&gt; bool</strong><div class="epy_nested">
opts: cfgopt_t const []
nopts: size_t
cb: config_changed_cb_t *
obj: void *</div>
</div></div>
</dd>
<dt id="ida_idp.set_module_data"><code class="name flex">
<span>def <span class="ident">set_module_data</span></span>(<span>*args) &#8209;&gt;&#160;void&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Starting from IDA v7.5 all modules should use the following 3
functions to handle idb specific static data because now the kernel
supports opening and working with multiple idbs files simultaneously.
See the source code of the processor modules in the SDK for the usage
examples. Register pointer to database specific module data.</div>
<div class="epy_par">
<strong class="epy_sig">set_module_data(data_id, data_ptr) -&gt; void *</strong><div class="epy_nested">
<strong class="epy_parameter">data_id</strong>: initially the pointed-to value must be 0, the kernel<div class="epy_nested">
will fill it with a unique id. once assigned, the
data_id does not change. (C++: int *)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">data_ptr</strong>: pointer to the data to register (C++: void *)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: data_ptr. The registered pointer can later be retrieved using</div>
</div>
<div class="epy_par">
<strong class="epy_sig">get_module_data()</strong></div></div>
</dd>
<dt id="ida_idp.set_processor_type"><code class="name flex">
<span>def <span class="ident">set_processor_type</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Set target processor type. Once a processor module is loaded, it
cannot be replaced until we close the idb.</div>
<div class="epy_par">
<strong class="epy_sig">set_processor_type(procname, level) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">procname</strong>: name of processor type (one of names present in</div>
</div>
<div class="epy_par">
\ph{psnames}<div class="epy_nested">
) (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">level</strong>: SETPROC_ (C++: setproc_level_t)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: success</div>
</div></div>
</dd>
<dt id="ida_idp.set_target_assembler"><code class="name flex">
<span>def <span class="ident">set_target_assembler</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Set target assembler.</div>
<div class="epy_par">
<strong class="epy_sig">set_target_assembler(asmnum) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">asmnum</strong>: number of assembler in the current processor module<div class="epy_nested">
(C++: int)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: success</div>
</div></div>
</dd>
<dt id="ida_idp.sizeof_ldbl"><code class="name flex">
<span>def <span class="ident">sizeof_ldbl</span></span>(<span>*args) &#8209;&gt;&#160;size_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">sizeof_ldbl() -&gt; size_t</strong></div></div>
</dd>
<dt id="ida_idp.str2reg"><code class="name flex">
<span>def <span class="ident">str2reg</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get any reg number (-1 on error)</div>
<div class="epy_par">
<strong class="epy_sig">str2reg(p) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">p</strong> (C++: const char *)</div>
</div></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ida_idp.IDB_Hooks"><code class="flex name class">
<span>class <span class="ident">IDB_Hooks</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ IDB_Hooks class.</div>
<div class="epy_par">
<strong class="epy_sig">__init__(self, _flags=0) -&gt; IDB_Hooks</strong><div class="epy_nested">
_flags: uint32</div>
</div></div>
<h3>Subclasses</h3>
<ul class="hlist">
<li>ida_idp._notify_when_dispatcher_t._IDB_Hooks</li>
<li>ida_idp._processor_t_Trampoline_IDB_Hooks</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="ida_idp.IDB_Hooks.adding_segm"><code class="name flex">
<span>def <span class="ident">adding_segm</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
A segment is being created.</div>
<div class="epy_par">
<strong class="epy_sig">adding_segm(self, s)</strong><div class="epy_nested">
<strong class="epy_parameter">s</strong> (C++: segment_t *)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.allsegs_moved"><code class="name flex">
<span>def <span class="ident">allsegs_moved</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Program rebasing is complete. This event is generated after series of
segm_moved events</div>
<div class="epy_par">
<strong class="epy_sig">allsegs_moved(self, info)</strong><div class="epy_nested">
<strong class="epy_parameter">info</strong> (C++: segm_move_infos_t *)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.auto_empty"><code class="name flex">
<span>def <span class="ident">auto_empty</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Info: all analysis queues are empty. This callback is called once when
the initial analysis is finished. If the queue is not empty upon the
return from this callback, it will be called later again.</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.auto_empty_finally"><code class="name flex">
<span>def <span class="ident">auto_empty_finally</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Info: all analysis queues are empty definitively. This callback is
called only once.</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.bookmark_changed"><code class="name flex">
<span>def <span class="ident">bookmark_changed</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Boomarked position changed.</div>
<div class="epy_par">
<strong class="epy_sig">bookmark_changed(self, index, pos, desc, operation)</strong><div class="epy_nested">
<strong class="epy_parameter">index</strong> (C++: uint32)</div>
<div class="epy_nested">
<strong class="epy_parameter">pos</strong> (C++: const lochist_entry_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">desc</strong> (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">operation</strong>: 0-added, 1-updated, 2-deleted if desc==NULL, then<div class="epy_nested">
the bookmark was deleted.
(C++: int)</div>
</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.byte_patched"><code class="name flex">
<span>def <span class="ident">byte_patched</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
A byte has been patched.</div>
<div class="epy_par">
<strong class="epy_sig">byte_patched(self, ea, old_value)</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">old_value</strong> (C++: uint32)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.callee_addr_changed"><code class="name flex">
<span>def <span class="ident">callee_addr_changed</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Callee address has been updated by the user.</div>
<div class="epy_par">
<strong class="epy_sig">callee_addr_changed(self, ea, callee)</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">callee</strong> (C++: ea_t)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.changing_cmt"><code class="name flex">
<span>def <span class="ident">changing_cmt</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
An item comment is to be changed.</div>
<div class="epy_par">
<strong class="epy_sig">changing_cmt(self, ea, repeatable_cmt, newcmt)</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">repeatable_cmt</strong> (C++: bool)</div>
<div class="epy_nested">
<strong class="epy_parameter">newcmt</strong> (C++: const char *)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.changing_enum_bf"><code class="name flex">
<span>def <span class="ident">changing_enum_bf</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
An enum type 'bitfield' attribute is to be changed.</div>
<div class="epy_par">
<strong class="epy_sig">changing_enum_bf(self, id, new_bf)</strong><div class="epy_nested">
<strong class="epy_parameter">id</strong> (C++: enum_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">new_bf</strong> (C++: bool)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.changing_enum_cmt"><code class="name flex">
<span>def <span class="ident">changing_enum_cmt</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
An enum or member type comment is to be changed.</div>
<div class="epy_par">
<strong class="epy_sig">changing_enum_cmt(self, id, repeatable, newcmt)</strong><div class="epy_nested">
<strong class="epy_parameter">id</strong> (C++: tid_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">repeatable</strong> (C++: bool)</div>
<div class="epy_nested">
<strong class="epy_parameter">newcmt</strong> (C++: const char *)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.changing_op_ti"><code class="name flex">
<span>def <span class="ident">changing_op_ti</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
An operand typestring (c/c++ prototype) is to be changed.</div>
<div class="epy_par">
<strong class="epy_sig">changing_op_ti(self, ea, n, new_type, new_fnames)</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">n</strong> (C++: int)</div>
<div class="epy_nested">
<strong class="epy_parameter">new_type</strong> (C++: const type_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">new_fnames</strong> (C++: const p_list *)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.changing_op_type"><code class="name flex">
<span>def <span class="ident">changing_op_type</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
An operand type (offset, hex, etc...) is to be changed.</div>
<div class="epy_par">
<strong class="epy_sig">changing_op_type(self, ea, n, opinfo)</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">n</strong>: eventually or'ed with OPND_OUTER or OPND_ALL
(C++: int)</div>
<div class="epy_nested">
<strong class="epy_parameter">opinfo</strong>: additional operand info
(C++: const opinfo_t *)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.changing_range_cmt"><code class="name flex">
<span>def <span class="ident">changing_range_cmt</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Range comment is to be changed.</div>
<div class="epy_par">
<strong class="epy_sig">changing_range_cmt(self, kind, a, cmt, repeatable)</strong><div class="epy_nested">
<strong class="epy_parameter">kind</strong> (C++: range_kind_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">a</strong> (C++: const range_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">cmt</strong> (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">repeatable</strong> (C++: bool)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.changing_segm_class"><code class="name flex">
<span>def <span class="ident">changing_segm_class</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Segment class is being changed.</div>
<div class="epy_par">
<strong class="epy_sig">changing_segm_class(self, s)</strong><div class="epy_nested">
<strong class="epy_parameter">s</strong> (C++: segment_t *)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.changing_segm_end"><code class="name flex">
<span>def <span class="ident">changing_segm_end</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Segment end address is to be changed.</div>
<div class="epy_par">
<strong class="epy_sig">changing_segm_end(self, s, new_end, segmod_flags)</strong><div class="epy_nested">
<strong class="epy_parameter">s</strong> (C++: segment_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">new_end</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">segmod_flags</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.changing_segm_name"><code class="name flex">
<span>def <span class="ident">changing_segm_name</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Segment name is being changed.</div>
<div class="epy_par">
<strong class="epy_sig">changing_segm_name(self, s, oldname)</strong><div class="epy_nested">
<strong class="epy_parameter">s</strong> (C++: segment_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">oldname</strong> (C++: const char *)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.changing_segm_start"><code class="name flex">
<span>def <span class="ident">changing_segm_start</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Segment start address is to be changed.</div>
<div class="epy_par">
<strong class="epy_sig">changing_segm_start(self, s, new_start, segmod_flags)</strong><div class="epy_nested">
<strong class="epy_parameter">s</strong> (C++: segment_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">new_start</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">segmod_flags</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.changing_struc_align"><code class="name flex">
<span>def <span class="ident">changing_struc_align</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
A structure type is being changed (the struct alignment).</div>
<div class="epy_par">
<strong class="epy_sig">changing_struc_align(self, sptr)</strong><div class="epy_nested">
<strong class="epy_parameter">sptr</strong> (C++: struc_t *)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.changing_struc_cmt"><code class="name flex">
<span>def <span class="ident">changing_struc_cmt</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
A structure type comment is to be changed.</div>
<div class="epy_par">
<strong class="epy_sig">changing_struc_cmt(self, struc_id, repeatable, newcmt)</strong><div class="epy_nested">
<strong class="epy_parameter">struc_id</strong> (C++: tid_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">repeatable</strong> (C++: bool)</div>
<div class="epy_nested">
<strong class="epy_parameter">newcmt</strong> (C++: const char *)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.changing_struc_member"><code class="name flex">
<span>def <span class="ident">changing_struc_member</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
A structure member is to be changed.</div>
<div class="epy_par">
<strong class="epy_sig">changing_struc_member(self, sptr, mptr, flag, ti, nbytes)</strong><div class="epy_nested">
<strong class="epy_parameter">sptr</strong> (C++: struc_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">mptr</strong> (C++: member_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">flag</strong> (C++: flags_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">ti</strong> (C++: const opinfo_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">nbytes</strong> (C++: asize_t)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.changing_ti"><code class="name flex">
<span>def <span class="ident">changing_ti</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
An item typestring (c/c++ prototype) is to be changed.</div>
<div class="epy_par">
<strong class="epy_sig">changing_ti(self, ea, new_type, new_fnames)</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">new_type</strong> (C++: const type_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">new_fnames</strong> (C++: const p_list *)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.closebase"><code class="name flex">
<span>def <span class="ident">closebase</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
The database will be closed now.</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.cmt_changed"><code class="name flex">
<span>def <span class="ident">cmt_changed</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
An item comment has been changed.</div>
<div class="epy_par">
<strong class="epy_sig">cmt_changed(self, ea, repeatable_cmt)</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">repeatable_cmt</strong> (C++: bool)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.compiler_changed"><code class="name flex">
<span>def <span class="ident">compiler_changed</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
The kernel has changed the compiler information. (\inf{cc}
structure;
'get_abi_name' )</div>
<div class="epy_par">
<strong class="epy_sig">compiler_changed(self, adjust_inf_fields)</strong><div class="epy_nested">
<strong class="epy_parameter">adjust_inf_fields</strong>: may change inf fields?
(C++: bool)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.deleting_enum"><code class="name flex">
<span>def <span class="ident">deleting_enum</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
An enum type is to be deleted.</div>
<div class="epy_par">
<strong class="epy_sig">deleting_enum(self, id)</strong><div class="epy_nested">
<strong class="epy_parameter">id</strong> (C++: enum_t)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.deleting_enum_member"><code class="name flex">
<span>def <span class="ident">deleting_enum_member</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
An enum member is to be deleted.</div>
<div class="epy_par">
<strong class="epy_sig">deleting_enum_member(self, id, cid)</strong><div class="epy_nested">
<strong class="epy_parameter">id</strong> (C++: enum_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">cid</strong> (C++: const_t)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.deleting_func"><code class="name flex">
<span>def <span class="ident">deleting_func</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
The kernel is about to delete a function.</div>
<div class="epy_par">
<strong class="epy_sig">deleting_func(self, pfn)</strong><div class="epy_nested">
<strong class="epy_parameter">pfn</strong> (C++: func_t *)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.deleting_func_tail"><code class="name flex">
<span>def <span class="ident">deleting_func_tail</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
A function tail chunk is to be removed.</div>
<div class="epy_par">
<strong class="epy_sig">deleting_func_tail(self, pfn, tail)</strong><div class="epy_nested">
<strong class="epy_parameter">pfn</strong> (C++: func_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">tail</strong> (C++: const range_t *)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.deleting_segm"><code class="name flex">
<span>def <span class="ident">deleting_segm</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
A segment is to be deleted.</div>
<div class="epy_par">
<strong class="epy_sig">deleting_segm(self, start_ea)</strong><div class="epy_nested">
<strong class="epy_parameter">start_ea</strong> (C++: ea_t)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.deleting_struc"><code class="name flex">
<span>def <span class="ident">deleting_struc</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
A structure type is to be deleted.</div>
<div class="epy_par">
<strong class="epy_sig">deleting_struc(self, sptr)</strong><div class="epy_nested">
<strong class="epy_parameter">sptr</strong> (C++: struc_t *)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.deleting_struc_member"><code class="name flex">
<span>def <span class="ident">deleting_struc_member</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
A structure member is to be deleted.</div>
<div class="epy_par">
<strong class="epy_sig">deleting_struc_member(self, sptr, mptr)</strong><div class="epy_nested">
<strong class="epy_parameter">sptr</strong> (C++: struc_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">mptr</strong> (C++: member_t *)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.deleting_tryblks"><code class="name flex">
<span>def <span class="ident">deleting_tryblks</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
About to delete tryblk information in given range</div>
<div class="epy_par">
<strong class="epy_sig">deleting_tryblks(self, range)</strong><div class="epy_nested">
<strong class="epy_parameter">range</strong> (C++: const range_t *)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.destroyed_items"><code class="name flex">
<span>def <span class="ident">destroyed_items</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Instructions/data have been destroyed in [ea1,ea2).</div>
<div class="epy_par">
<strong class="epy_sig">destroyed_items(self, ea1, ea2, will_disable_range)</strong><div class="epy_nested">
<strong class="epy_parameter">ea1</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">ea2</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">will_disable_range</strong> (C++: bool)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.determined_main"><code class="name flex">
<span>def <span class="ident">determined_main</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
The main() function has been determined.</div>
<div class="epy_par">
<strong class="epy_sig">determined_main(self, main)</strong><div class="epy_nested">
<strong class="epy_parameter">main</strong>: address of the main() function
(C++: ea_t)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.dirtree_link"><code class="name flex">
<span>def <span class="ident">dirtree_link</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Dirtree: an item has been linked/unlinked.</div>
<div class="epy_par">
<strong class="epy_sig">dirtree_link(self, dt, path, link)</strong><div class="epy_nested">
<strong class="epy_parameter">dt</strong> (C++: dirtree_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">path</strong> (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">link</strong> (C++: bool)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.dirtree_mkdir"><code class="name flex">
<span>def <span class="ident">dirtree_mkdir</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Dirtree: a directory has been created.</div>
<div class="epy_par">
<strong class="epy_sig">dirtree_mkdir(self, dt, path)</strong><div class="epy_nested">
<strong class="epy_parameter">dt</strong> (C++: dirtree_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">path</strong> (C++: const char *)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.dirtree_move"><code class="name flex">
<span>def <span class="ident">dirtree_move</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Dirtree: a directory or item has been moved.</div>
<div class="epy_par">
<strong class="epy_sig">dirtree_move(self, dt, _from, to)</strong><div class="epy_nested">
<strong class="epy_parameter">dt</strong> (C++: dirtree_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">_from</strong> (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">to</strong> (C++: const char *)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.dirtree_rank"><code class="name flex">
<span>def <span class="ident">dirtree_rank</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Dirtree: a directory or item rank has been changed.</div>
<div class="epy_par">
<strong class="epy_sig">dirtree_rank(self, dt, path, rank)</strong><div class="epy_nested">
<strong class="epy_parameter">dt</strong> (C++: dirtree_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">path</strong> (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">rank</strong> (C++: size_t)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.dirtree_rmdir"><code class="name flex">
<span>def <span class="ident">dirtree_rmdir</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Dirtree: a directory has been deleted.</div>
<div class="epy_par">
<strong class="epy_sig">dirtree_rmdir(self, dt, path)</strong><div class="epy_nested">
<strong class="epy_parameter">dt</strong> (C++: dirtree_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">path</strong> (C++: const char *)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.dirtree_rminode"><code class="name flex">
<span>def <span class="ident">dirtree_rminode</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Dirtree: an inode became unavailable.</div>
<div class="epy_par">
<strong class="epy_sig">dirtree_rminode(self, dt, inode)</strong><div class="epy_nested">
<strong class="epy_parameter">dt</strong> (C++: dirtree_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">inode</strong> (C++: inode_t)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.dirtree_segm_moved"><code class="name flex">
<span>def <span class="ident">dirtree_segm_moved</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Dirtree: inodes were changed due to a segment movement or a program
rebasing</div>
<div class="epy_par">
<strong class="epy_sig">dirtree_segm_moved(self, dt)</strong><div class="epy_nested">
<strong class="epy_parameter">dt</strong> (C++: dirtree_t *)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.enum_bf_changed"><code class="name flex">
<span>def <span class="ident">enum_bf_changed</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
An enum type 'bitfield' attribute has been changed.</div>
<div class="epy_par">
<strong class="epy_sig">enum_bf_changed(self, id)</strong><div class="epy_nested">
<strong class="epy_parameter">id</strong> (C++: enum_t)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.enum_cmt_changed"><code class="name flex">
<span>def <span class="ident">enum_cmt_changed</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
An enum or member type comment has been changed.</div>
<div class="epy_par">
<strong class="epy_sig">enum_cmt_changed(self, id, repeatable)</strong><div class="epy_nested">
<strong class="epy_parameter">id</strong> (C++: tid_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">repeatable</strong> (C++: bool)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.enum_created"><code class="name flex">
<span>def <span class="ident">enum_created</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
An enum type has been created.</div>
<div class="epy_par">
<strong class="epy_sig">enum_created(self, id)</strong><div class="epy_nested">
<strong class="epy_parameter">id</strong> (C++: enum_t)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.enum_deleted"><code class="name flex">
<span>def <span class="ident">enum_deleted</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
An enum type has been deleted.</div>
<div class="epy_par">
<strong class="epy_sig">enum_deleted(self, id)</strong><div class="epy_nested">
<strong class="epy_parameter">id</strong> (C++: enum_t)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.enum_member_created"><code class="name flex">
<span>def <span class="ident">enum_member_created</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
An enum member has been created.</div>
<div class="epy_par">
<strong class="epy_sig">enum_member_created(self, id, cid)</strong><div class="epy_nested">
<strong class="epy_parameter">id</strong> (C++: enum_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">cid</strong> (C++: const_t)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.enum_member_deleted"><code class="name flex">
<span>def <span class="ident">enum_member_deleted</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
An enum member has been deleted.</div>
<div class="epy_par">
<strong class="epy_sig">enum_member_deleted(self, id, cid)</strong><div class="epy_nested">
<strong class="epy_parameter">id</strong> (C++: enum_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">cid</strong> (C++: const_t)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.enum_renamed"><code class="name flex">
<span>def <span class="ident">enum_renamed</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
An enum or member has been renamed.</div>
<div class="epy_par">
<strong class="epy_sig">enum_renamed(self, id)</strong><div class="epy_nested">
<strong class="epy_parameter">id</strong> (C++: tid_t)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.expanding_struc"><code class="name flex">
<span>def <span class="ident">expanding_struc</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
A structure type is to be expanded/shrunk.</div>
<div class="epy_par">
<strong class="epy_sig">expanding_struc(self, sptr, offset, delta)</strong><div class="epy_nested">
<strong class="epy_parameter">sptr</strong> (C++: struc_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">offset</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">delta</strong> (C++: adiff_t)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.extlang_changed"><code class="name flex">
<span>def <span class="ident">extlang_changed</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
The list of extlangs or the default extlang was changed.</div>
<div class="epy_par">
<strong class="epy_sig">extlang_changed(self, kind, el, idx)</strong><div class="epy_nested">
<strong class="epy_parameter">kind</strong>: 0: extlang installed 1: extlang removed 2: default<div class="epy_nested">
extlang changed
(C++: int)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">el</strong>: pointer to the extlang affected
(C++: extlang_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">idx</strong>: extlang index
(C++: int)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.extra_cmt_changed"><code class="name flex">
<span>def <span class="ident">extra_cmt_changed</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
An extra comment has been changed.</div>
<div class="epy_par">
<strong class="epy_sig">extra_cmt_changed(self, ea, line_idx, cmt)</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">line_idx</strong> (C++: int)</div>
<div class="epy_nested">
<strong class="epy_parameter">cmt</strong> (C++: const char *)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.flow_chart_created"><code class="name flex">
<span>def <span class="ident">flow_chart_created</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Gui has retrieved a function flow chart. Plugins may modify the flow
chart in this callback.</div>
<div class="epy_par">
<strong class="epy_sig">flow_chart_created(self, fc)</strong><div class="epy_nested">
<strong class="epy_parameter">fc</strong> (C++: qflow_chart_t *)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.frame_deleted"><code class="name flex">
<span>def <span class="ident">frame_deleted</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
The kernel has deleted a function frame.</div>
<div class="epy_par">
<strong class="epy_sig">frame_deleted(self, pfn)</strong><div class="epy_nested">
<strong class="epy_parameter">pfn</strong> (C++: func_t *)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.func_added"><code class="name flex">
<span>def <span class="ident">func_added</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
The kernel has added a function.</div>
<div class="epy_par">
<strong class="epy_sig">func_added(self, pfn)</strong><div class="epy_nested">
<strong class="epy_parameter">pfn</strong> (C++: func_t *)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.func_deleted"><code class="name flex">
<span>def <span class="ident">func_deleted</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
A function has been deleted.</div>
<div class="epy_par">
<strong class="epy_sig">func_deleted(self, func_ea)</strong><div class="epy_nested">
<strong class="epy_parameter">func_ea</strong> (C++: ea_t)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.func_noret_changed"><code class="name flex">
<span>def <span class="ident">func_noret_changed</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
'FUNC_NORET' bit has been changed.</div>
<div class="epy_par">
<strong class="epy_sig">func_noret_changed(self, pfn)</strong><div class="epy_nested">
<strong class="epy_parameter">pfn</strong> (C++: func_t *)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.func_tail_appended"><code class="name flex">
<span>def <span class="ident">func_tail_appended</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
A function tail chunk has been appended.</div>
<div class="epy_par">
<strong class="epy_sig">func_tail_appended(self, pfn, tail)</strong><div class="epy_nested">
<strong class="epy_parameter">pfn</strong> (C++: func_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">tail</strong> (C++: func_t *)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.func_tail_deleted"><code class="name flex">
<span>def <span class="ident">func_tail_deleted</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
A function tail chunk has been removed.</div>
<div class="epy_par">
<strong class="epy_sig">func_tail_deleted(self, pfn, tail_ea)</strong><div class="epy_nested">
<strong class="epy_parameter">pfn</strong> (C++: func_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">tail_ea</strong> (C++: ea_t)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.func_updated"><code class="name flex">
<span>def <span class="ident">func_updated</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
The kernel has updated a function.</div>
<div class="epy_par">
<strong class="epy_sig">func_updated(self, pfn)</strong><div class="epy_nested">
<strong class="epy_parameter">pfn</strong> (C++: func_t *)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.hook"><code class="name flex">
<span>def <span class="ident">hook</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">hook(self) -&gt; bool</strong></div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.idasgn_loaded"><code class="name flex">
<span>def <span class="ident">idasgn_loaded</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
FLIRT signature has been loaded for normal processing (not for
recognition of startup sequences).</div>
<div class="epy_par">
<strong class="epy_sig">idasgn_loaded(self, short_sig_name)</strong><div class="epy_nested">
<strong class="epy_parameter">short_sig_name</strong> (C++: const char *)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.item_color_changed"><code class="name flex">
<span>def <span class="ident">item_color_changed</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
An item color has been changed.</div>
<div class="epy_par">
<strong class="epy_sig">item_color_changed(self, ea, color)</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">color</strong>: if color==DEFCOLOR, the the color is deleted.
(C++:<div class="epy_nested">
bgcolor_t)</div>
</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.kernel_config_loaded"><code class="name flex">
<span>def <span class="ident">kernel_config_loaded</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
This event is issued when ida.cfg is parsed.</div>
<div class="epy_par">
<strong class="epy_sig">kernel_config_loaded(self, pass_number)</strong><div class="epy_nested">
<strong class="epy_parameter">pass_number</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.loader_finished"><code class="name flex">
<span>def <span class="ident">loader_finished</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
External file loader finished its work. Use this event to augment the
existing loader functionality.</div>
<div class="epy_par">
<strong class="epy_sig">loader_finished(self, li, neflags, filetypename)</strong><div class="epy_nested">
<strong class="epy_parameter">li</strong> (C++: linput_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">neflags</strong>: Load file flags
(C++: uint16)</div>
<div class="epy_nested">
<strong class="epy_parameter">filetypename</strong> (C++: const char *)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.local_types_changed"><code class="name flex">
<span>def <span class="ident">local_types_changed</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Local types have been changed.</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.make_code"><code class="name flex">
<span>def <span class="ident">make_code</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
An instruction is being created.</div>
<div class="epy_par">
<strong class="epy_sig">make_code(self, insn)</strong><div class="epy_nested">
<strong class="epy_parameter">insn</strong> (C++: const insn_t*)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.make_data"><code class="name flex">
<span>def <span class="ident">make_data</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
A data item is being created.</div>
<div class="epy_par">
<strong class="epy_sig">make_data(self, ea, flags, tid, len)</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">flags</strong> (C++: flags_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">tid</strong> (C++: tid_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">len</strong> (C++: asize_t)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.op_ti_changed"><code class="name flex">
<span>def <span class="ident">op_ti_changed</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
An operand typestring (c/c++ prototype) has been changed.</div>
<div class="epy_par">
<strong class="epy_sig">op_ti_changed(self, ea, n, type, fnames)</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">n</strong> (C++: int)</div>
<div class="epy_nested">
<strong class="epy_parameter">type</strong> (C++: const type_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">fnames</strong> (C++: const p_list *)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.op_type_changed"><code class="name flex">
<span>def <span class="ident">op_type_changed</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
An operand type (offset, hex, etc...) has been set or deleted.</div>
<div class="epy_par">
<strong class="epy_sig">op_type_changed(self, ea, n)</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">n</strong>: eventually or'ed with OPND_OUTER or OPND_ALL
(C++: int)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.range_cmt_changed"><code class="name flex">
<span>def <span class="ident">range_cmt_changed</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Range comment has been changed.</div>
<div class="epy_par">
<strong class="epy_sig">range_cmt_changed(self, kind, a, cmt, repeatable)</strong><div class="epy_nested">
<strong class="epy_parameter">kind</strong> (C++: range_kind_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">a</strong> (C++: const range_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">cmt</strong> (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">repeatable</strong> (C++: bool)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.renamed"><code class="name flex">
<span>def <span class="ident">renamed</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
The kernel has renamed a byte. See also the \idpcode{rename}
event</div>
<div class="epy_par">
<strong class="epy_sig">renamed(self, ea, new_name, local_name, old_name)</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">new_name</strong>: can be nullptr
(C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">local_name</strong> (C++: bool)</div>
<div class="epy_nested">
<strong class="epy_parameter">old_name</strong>: can be nullptr
(C++: const char *)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.renaming_enum"><code class="name flex">
<span>def <span class="ident">renaming_enum</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
An enum or enum member is to be renamed.</div>
<div class="epy_par">
<strong class="epy_sig">renaming_enum(self, id, is_enum, newname)</strong><div class="epy_nested">
<strong class="epy_parameter">id</strong> (C++: tid_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">is_enum</strong> (C++: bool)</div>
<div class="epy_nested">
<strong class="epy_parameter">newname</strong> (C++: const char *)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.renaming_struc"><code class="name flex">
<span>def <span class="ident">renaming_struc</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
A structure type is to be renamed.</div>
<div class="epy_par">
<strong class="epy_sig">renaming_struc(self, id, oldname, newname)</strong><div class="epy_nested">
<strong class="epy_parameter">id</strong> (C++: tid_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">oldname</strong> (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">newname</strong> (C++: const char *)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.renaming_struc_member"><code class="name flex">
<span>def <span class="ident">renaming_struc_member</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
A structure member is to be renamed.</div>
<div class="epy_par">
<strong class="epy_sig">renaming_struc_member(self, sptr, mptr, newname)</strong><div class="epy_nested">
<strong class="epy_parameter">sptr</strong> (C++: struc_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">mptr</strong> (C++: member_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">newname</strong> (C++: const char *)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.savebase"><code class="name flex">
<span>def <span class="ident">savebase</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
The database is being saved.</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.segm_added"><code class="name flex">
<span>def <span class="ident">segm_added</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
A new segment has been created.</div>
<div class="epy_par">
<strong class="epy_sig">segm_added(self, s)</strong><div class="epy_nested">
<strong class="epy_parameter">s</strong>: See also adding_segm
(C++: segment_t *)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.segm_attrs_updated"><code class="name flex">
<span>def <span class="ident">segm_attrs_updated</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Segment attributes has been changed.</div>
<div class="epy_par">
<strong class="epy_sig">segm_attrs_updated(self, s)</strong><div class="epy_nested">
<strong class="epy_parameter">s</strong>: This event is generated for secondary segment attributes<div class="epy_nested">
(examples: color, permissions, etc)
(C++: segment_t *)</div>
</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.segm_class_changed"><code class="name flex">
<span>def <span class="ident">segm_class_changed</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Segment class has been changed.</div>
<div class="epy_par">
<strong class="epy_sig">segm_class_changed(self, s, sclass)</strong><div class="epy_nested">
<strong class="epy_parameter">s</strong> (C++: segment_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">sclass</strong> (C++: const char *)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.segm_deleted"><code class="name flex">
<span>def <span class="ident">segm_deleted</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
A segment has been deleted.</div>
<div class="epy_par">
<strong class="epy_sig">segm_deleted(self, start_ea, end_ea)</strong><div class="epy_nested">
<strong class="epy_parameter">start_ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">end_ea</strong> (C++: ea_t)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.segm_end_changed"><code class="name flex">
<span>def <span class="ident">segm_end_changed</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Segment end address has been changed.</div>
<div class="epy_par">
<strong class="epy_sig">segm_end_changed(self, s, oldend)</strong><div class="epy_nested">
<strong class="epy_parameter">s</strong> (C++: segment_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">oldend</strong> (C++: ea_t)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.segm_moved"><code class="name flex">
<span>def <span class="ident">segm_moved</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Segment has been moved.</div>
<div class="epy_par">
<strong class="epy_sig">segm_moved(self, _from, to, size, changed_netmap)</strong><div class="epy_nested">
<strong class="epy_parameter">_from</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">to</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">size</strong> (C++: asize_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">changed_netmap</strong>: See also idb_event::allsegs_moved
(C++: bool)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.segm_name_changed"><code class="name flex">
<span>def <span class="ident">segm_name_changed</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Segment name has been changed.</div>
<div class="epy_par">
<strong class="epy_sig">segm_name_changed(self, s, name)</strong><div class="epy_nested">
<strong class="epy_parameter">s</strong> (C++: segment_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">name</strong> (C++: const char *)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.segm_start_changed"><code class="name flex">
<span>def <span class="ident">segm_start_changed</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Segment start address has been changed.</div>
<div class="epy_par">
<strong class="epy_sig">segm_start_changed(self, s, oldstart)</strong><div class="epy_nested">
<strong class="epy_parameter">s</strong> (C++: segment_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">oldstart</strong> (C++: ea_t)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.set_func_end"><code class="name flex">
<span>def <span class="ident">set_func_end</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Function chunk end address will be changed.</div>
<div class="epy_par">
<strong class="epy_sig">set_func_end(self, pfn, new_end)</strong><div class="epy_nested">
<strong class="epy_parameter">pfn</strong> (C++: func_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">new_end</strong> (C++: ea_t)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.set_func_start"><code class="name flex">
<span>def <span class="ident">set_func_start</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Function chunk start address will be changed.</div>
<div class="epy_par">
<strong class="epy_sig">set_func_start(self, pfn, new_start)</strong><div class="epy_nested">
<strong class="epy_parameter">pfn</strong> (C++: func_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">new_start</strong> (C++: ea_t)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.sgr_changed"><code class="name flex">
<span>def <span class="ident">sgr_changed</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
The kernel has changed a segment register value.</div>
<div class="epy_par">
<strong class="epy_sig">sgr_changed(self, start_ea, end_ea, regnum, value, old_value, tag)</strong><div class="epy_nested">
<strong class="epy_parameter">start_ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">end_ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">regnum</strong> (C++: int)</div>
<div class="epy_nested">
<strong class="epy_parameter">value</strong> (C++: sel_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">old_value</strong> (C++: sel_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">tag</strong>: Segment register range tags
(C++: uchar)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.sgr_deleted"><code class="name flex">
<span>def <span class="ident">sgr_deleted</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
The kernel has deleted a segment register value.</div>
<div class="epy_par">
<strong class="epy_sig">sgr_deleted(self, start_ea, end_ea, regnum)</strong><div class="epy_nested">
<strong class="epy_parameter">start_ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">end_ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">regnum</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.stkpnts_changed"><code class="name flex">
<span>def <span class="ident">stkpnts_changed</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Stack change points have been modified.</div>
<div class="epy_par">
<strong class="epy_sig">stkpnts_changed(self, pfn)</strong><div class="epy_nested">
<strong class="epy_parameter">pfn</strong> (C++: func_t *)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.struc_align_changed"><code class="name flex">
<span>def <span class="ident">struc_align_changed</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
A structure type has been changed (the struct alignment).</div>
<div class="epy_par">
<strong class="epy_sig">struc_align_changed(self, sptr)</strong><div class="epy_nested">
<strong class="epy_parameter">sptr</strong> (C++: struc_t *)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.struc_cmt_changed"><code class="name flex">
<span>def <span class="ident">struc_cmt_changed</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
A structure type comment has been changed.</div>
<div class="epy_par">
<strong class="epy_sig">struc_cmt_changed(self, struc_id, repeatable_cmt)</strong><div class="epy_nested">
<strong class="epy_parameter">struc_id</strong> (C++: tid_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">repeatable_cmt</strong> (C++: bool)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.struc_created"><code class="name flex">
<span>def <span class="ident">struc_created</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
A new structure type has been created.</div>
<div class="epy_par">
<strong class="epy_sig">struc_created(self, struc_id)</strong><div class="epy_nested">
<strong class="epy_parameter">struc_id</strong> (C++: tid_t)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.struc_deleted"><code class="name flex">
<span>def <span class="ident">struc_deleted</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
A structure type has been deleted.</div>
<div class="epy_par">
<strong class="epy_sig">struc_deleted(self, struc_id)</strong><div class="epy_nested">
<strong class="epy_parameter">struc_id</strong> (C++: tid_t)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.struc_expanded"><code class="name flex">
<span>def <span class="ident">struc_expanded</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
A structure type has been expanded/shrank.</div>
<div class="epy_par">
<strong class="epy_sig">struc_expanded(self, sptr)</strong><div class="epy_nested">
<strong class="epy_parameter">sptr</strong> (C++: struc_t *)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.struc_member_changed"><code class="name flex">
<span>def <span class="ident">struc_member_changed</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
A structure member has been changed.</div>
<div class="epy_par">
<strong class="epy_sig">struc_member_changed(self, sptr, mptr)</strong><div class="epy_nested">
<strong class="epy_parameter">sptr</strong> (C++: struc_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">mptr</strong> (C++: member_t *)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.struc_member_created"><code class="name flex">
<span>def <span class="ident">struc_member_created</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
A structure member has been created.</div>
<div class="epy_par">
<strong class="epy_sig">struc_member_created(self, sptr, mptr)</strong><div class="epy_nested">
<strong class="epy_parameter">sptr</strong> (C++: struc_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">mptr</strong> (C++: member_t *)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.struc_member_deleted"><code class="name flex">
<span>def <span class="ident">struc_member_deleted</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
A structure member has been deleted.</div>
<div class="epy_par">
<strong class="epy_sig">struc_member_deleted(self, sptr, member_id, offset)</strong><div class="epy_nested">
<strong class="epy_parameter">sptr</strong> (C++: struc_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">member_id</strong> (C++: tid_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">offset</strong> (C++: ea_t)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.struc_member_renamed"><code class="name flex">
<span>def <span class="ident">struc_member_renamed</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
A structure member has been renamed.</div>
<div class="epy_par">
<strong class="epy_sig">struc_member_renamed(self, sptr, mptr)</strong><div class="epy_nested">
<strong class="epy_parameter">sptr</strong> (C++: struc_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">mptr</strong> (C++: member_t *)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.struc_renamed"><code class="name flex">
<span>def <span class="ident">struc_renamed</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
A structure type has been renamed.</div>
<div class="epy_par">
<strong class="epy_sig">struc_renamed(self, sptr)</strong><div class="epy_nested">
<strong class="epy_parameter">sptr</strong> (C++: struc_t *)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.tail_owner_changed"><code class="name flex">
<span>def <span class="ident">tail_owner_changed</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
A tail chunk owner has been changed.</div>
<div class="epy_par">
<strong class="epy_sig">tail_owner_changed(self, tail, owner_func, old_owner)</strong><div class="epy_nested">
<strong class="epy_parameter">tail</strong> (C++: func_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">owner_func</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">old_owner</strong> (C++: ea_t)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.thunk_func_created"><code class="name flex">
<span>def <span class="ident">thunk_func_created</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
A thunk bit has been set for a function.</div>
<div class="epy_par">
<strong class="epy_sig">thunk_func_created(self, pfn)</strong><div class="epy_nested">
<strong class="epy_parameter">pfn</strong> (C++: func_t *)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.ti_changed"><code class="name flex">
<span>def <span class="ident">ti_changed</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
An item typestring (c/c++ prototype) has been changed.</div>
<div class="epy_par">
<strong class="epy_sig">ti_changed(self, ea, type, fnames)</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">type</strong> (C++: const type_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">fnames</strong> (C++: const p_list *)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.tryblks_updated"><code class="name flex">
<span>def <span class="ident">tryblks_updated</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Updated tryblk information</div>
<div class="epy_par">
<strong class="epy_sig">tryblks_updated(self, tbv)</strong><div class="epy_nested">
<strong class="epy_parameter">tbv</strong> (C++: const tryblks_t *)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.unhook"><code class="name flex">
<span>def <span class="ident">unhook</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">unhook(self) -&gt; bool</strong></div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.updating_tryblks"><code class="name flex">
<span>def <span class="ident">updating_tryblks</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
About to update tryblk information</div>
<div class="epy_par">
<strong class="epy_sig">updating_tryblks(self, tbv)</strong><div class="epy_nested">
<strong class="epy_parameter">tbv</strong> (C++: const tryblks_t *)</div>
</div></div>
</dd>
<dt id="ida_idp.IDB_Hooks.upgraded"><code class="name flex">
<span>def <span class="ident">upgraded</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
The database has been upgraded and the receiver can upgrade its info
as well</div>
<div class="epy_par">
<strong class="epy_sig">upgraded(self, _from)</strong><div class="epy_nested">
<strong class="epy_parameter">_from</strong>: - old IDB version
(C++: int)</div>
</div></div>
</dd>
</dl>
</dd>
<dt id="ida_idp.IDP_Hooks"><code class="flex name class">
<span>class <span class="ident">IDP_Hooks</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ IDP_Hooks class.</div>
<div class="epy_par">
<strong class="epy_sig">__init__(self, _flags=0) -&gt; IDP_Hooks</strong><div class="epy_nested">
_flags: uint32</div>
</div></div>
<h3>Subclasses</h3>
<ul class="hlist">
<li>ida_idp._notify_when_dispatcher_t._IDP_Hooks</li>
<li><a title="ida_idp.processor_t" href="#ida_idp.processor_t">processor_t</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="ida_idp.IDP_Hooks.ev_add_cref"><code class="name flex">
<span>def <span class="ident">ev_add_cref</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
A code reference is being created.</div>
<div class="epy_par">
<strong class="epy_sig">ev_add_cref(self, _from, to, type) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">_from</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">to</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">type</strong> (C++: cref_t)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: &lt;0 - cancel cref creation</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - not implemented or continue</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_add_dref"><code class="name flex">
<span>def <span class="ident">ev_add_dref</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
A data reference is being created.</div>
<div class="epy_par">
<strong class="epy_sig">ev_add_dref(self, _from, to, type) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">_from</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">to</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">type</strong> (C++: dref_t)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: &lt;0 - cancel dref creation</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - not implemented or continue</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_adjust_argloc"><code class="name flex">
<span>def <span class="ident">ev_adjust_argloc</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Adjust argloc according to its type/size and platform endianess</div>
<div class="epy_par">
<strong class="epy_sig">ev_adjust_argloc(self, argloc, optional_type, size) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">argloc</strong>: , inout
(C++: argloc_t *)
optional_type: tinfo_t const *</div>
<div class="epy_nested">
<strong class="epy_parameter">size</strong>: 'size' makes no sense if type != NULL (type-&gt;get_size()<div class="epy_nested">
should be used instead)
(C++: int)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - not implemented</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 - ok</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: -1 - error</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_adjust_libfunc_ea"><code class="name flex">
<span>def <span class="ident">ev_adjust_libfunc_ea</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Called when a signature module has been matched against bytes in the
database. This is used to compute the offset at which a particular
module's libfunc should be applied.'ea' initially contains the ea_t of
the start of the pattern match</div>
<div class="epy_par">
<strong class="epy_sig">ev_adjust_libfunc_ea(self, sig, libfun, ea) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">sig</strong> (C++: const idasgn_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">libfun</strong> (C++: const libfunc_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t *)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 - the ea_t pointed to by the third argument was modified.</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: &lt;=0 - not modified. use default algorithm.</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_adjust_refinfo"><code class="name flex">
<span>def <span class="ident">ev_adjust_refinfo</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Called from apply_fixup before converting operand to reference. Can be
used for changing the reference info. (e.g. the PPC module adds
REFINFO_NOBASE for some references)</div>
<div class="epy_par">
<strong class="epy_sig">ev_adjust_refinfo(self, ri, ea, n, fd) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">ri</strong> (C++: refinfo_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">ea</strong>: instruction address
(C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">n</strong>: operand number
(C++: int)</div>
<div class="epy_nested">
<strong class="epy_parameter">fd</strong> (C++: const fixup_data_t *)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: &lt;0 - do not create an offset</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - not implemented or refinfo adjusted</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_ana_insn"><code class="name flex">
<span>def <span class="ident">ev_ana_insn</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Analyze one instruction and fill 'out' structure. This function
shouldn't change the database, flags or anything else. All these
actions should be performed only by emu_insn() function. \insn_t{ea}</div>
<div class="epy_par">
contains address of instruction to analyze.</div>
<div class="epy_par">
<strong class="epy_sig">ev_ana_insn(self, out) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">out</strong> (C++: insn_t *)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - if instruction can't be decoded.</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_analyze_prolog"><code class="name flex">
<span>def <span class="ident">ev_analyze_prolog</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Analyzes function prolog, epilog, and updates purge, and function
attributes</div>
<div class="epy_par">
<strong class="epy_sig">ev_analyze_prolog(self, ea) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong>: start of function
(C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 - ok</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - not implemented</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_arch_changed"><code class="name flex">
<span>def <span class="ident">ev_arch_changed</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
The loader is done parsing arch-related information, which the
processor module might want to use to finish its initialization.</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_arg_addrs_ready"><code class="name flex">
<span>def <span class="ident">ev_arg_addrs_ready</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Argument address info is ready.</div>
<div class="epy_par">
<strong class="epy_sig">ev_arg_addrs_ready(self, caller, n, tif, addrs) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">caller</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">n</strong>: number of formal arguments
(C++: int)</div>
<div class="epy_nested">
<strong class="epy_parameter">tif</strong>: call prototype
(C++: tinfo_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">addrs</strong>: argument intilization addresses
(C++: ea_t *)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: &lt;0 - do not save into idb; other values mean "ok to save"</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_asm_installed"><code class="name flex">
<span>def <span class="ident">ev_asm_installed</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
After setting a new assembler</div>
<div class="epy_par">
<strong class="epy_sig">ev_asm_installed(self, asmnum) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">asmnum</strong>: See also ev_newasm
(C++: int)</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_assemble"><code class="name flex">
<span>def <span class="ident">ev_assemble</span></span>(<span>self, *args) &#8209;&gt;&#160;PyObject&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Assemble an instruction. (display a warning if an error is found).</div>
<div class="epy_par">
<strong class="epy_sig">ev_assemble(self, ea, cs, ip, use32, line) -&gt; PyObject *</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong>: linear address of instruction
(C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">cs</strong>: cs of instruction
(C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">ip</strong>: ip of instruction
(C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">use32</strong>: is 32bit segment?
(C++: bool)</div>
<div class="epy_nested">
<strong class="epy_parameter">line</strong>: line to assemble
(C++: const char *)</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_auto_queue_empty"><code class="name flex">
<span>def <span class="ident">ev_auto_queue_empty</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
One analysis queue is empty.</div>
<div class="epy_par">
<strong class="epy_sig">ev_auto_queue_empty(self, type) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">type</strong> (C++: atype_t)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: void - see also
idb_event::auto_empty_finally</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_calc_arglocs"><code class="name flex">
<span>def <span class="ident">ev_calc_arglocs</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Calculate function argument locations. This callback should fill
retloc, all arglocs, and stkargs. This callback is never called for
'CM_CC_SPECIAL' functions.</div>
<div class="epy_par">
<strong class="epy_sig">ev_calc_arglocs(self, fti) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">fti</strong>: points to the func type info
(C++: func_type_data_t *)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - not implemented</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 - ok</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: -1 - error</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_calc_cdecl_purged_bytes"><code class="name flex">
<span>def <span class="ident">ev_calc_cdecl_purged_bytes</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Calculate number of purged bytes after call.</div>
<div class="epy_par">
<strong class="epy_sig">ev_calc_cdecl_purged_bytes(self, ea) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong>: address of the call instruction
(C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: number of purged bytes (usually add sp, N)</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_calc_next_eas"><code class="name flex">
<span>def <span class="ident">ev_calc_next_eas</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Calculate list of addresses the instruction in 'insn' may pass control
to. This callback is required for source level debugging.</div>
<div class="epy_par">
<strong class="epy_sig">ev_calc_next_eas(self, res, insn, over) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">res</strong>: , out: array for the results.
(C++: eavec_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">insn</strong>: the instruction
(C++: const insn_t*)</div>
<div class="epy_nested">
<strong class="epy_parameter">over</strong>: calculate for step over (ignore call targets)
(C++:<div class="epy_nested">
bool)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: &lt;0 - incalculable (indirect jumps, for example)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: &gt;=0 - number of addresses of called functions in the array.<div class="epy_nested">
They must be put at the beginning of the array (0 if
over=true)</div>
</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_calc_purged_bytes"><code class="name flex">
<span>def <span class="ident">ev_calc_purged_bytes</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Calculate number of purged bytes by the given function type.</div>
<div class="epy_par">
<strong class="epy_sig">ev_calc_purged_bytes(self, p_purged_bytes, fti) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">p_purged_bytes</strong>: ptr to output
(C++: int *)</div>
<div class="epy_nested">
<strong class="epy_parameter">fti</strong>: func type details
(C++: const func_type_data_t *)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 -</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - not implemented</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_calc_retloc"><code class="name flex">
<span>def <span class="ident">ev_calc_retloc</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Calculate return value location.</div>
<div class="epy_par">
<strong class="epy_sig">ev_calc_retloc(self, retloc, rettype, cc) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">retloc</strong> (C++: argloc_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">rettype</strong> (C++: const tinfo_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">cc</strong> (C++: cm_t)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - not implemented</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 - ok,</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: -1 - error</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_calc_spdelta"><code class="name flex">
<span>def <span class="ident">ev_calc_spdelta</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Calculate amount of change to sp for the given insn. This event is
required to decompile code snippets.</div>
<div class="epy_par">
<strong class="epy_sig">ev_calc_spdelta(self, spdelta, insn) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">spdelta</strong> (C++: sval_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">insn</strong> (C++: const insn_t *)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 - ok</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - not implemented</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_calc_step_over"><code class="name flex">
<span>def <span class="ident">ev_calc_step_over</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Calculate the address of the instruction which will be executed after
"step over". The kernel will put a breakpoint there. If the step over
is equal to step into or we cannot calculate the address, return
'BADADDR' .</div>
<div class="epy_par">
<strong class="epy_sig">ev_calc_step_over(self, target, ip) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">target</strong>: pointer to the answer
(C++: ea_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">ip</strong>: instruction address
(C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - unimplemented</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 - implemented</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_calc_switch_cases"><code class="name flex">
<span>def <span class="ident">ev_calc_switch_cases</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Calculate case values and targets for a custom jump table.</div>
<div class="epy_par">
<strong class="epy_sig">ev_calc_switch_cases(self, casevec, targets, insn_ea, si) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">casevec</strong>: vector of case values (may be NULL)
(C++: casevec_t<div class="epy_nested">
*)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">targets</strong>: corresponding target addresses (my be NULL)
(C++:<div class="epy_nested">
eavec_t *)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">insn_ea</strong>: address of the 'indirect jump' instruction
(C++:<div class="epy_nested">
ea_t)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">si</strong>: switch information
(C++: switch_info_t *)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 - ok</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: &lt;=0 - failed</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_calc_varglocs"><code class="name flex">
<span>def <span class="ident">ev_calc_varglocs</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Calculate locations of the arguments that correspond to '...'.</div>
<div class="epy_par">
<strong class="epy_sig">ev_calc_varglocs(self, ftd, aux_regs, aux_stkargs, nfixed) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">ftd</strong>: , inout: info about all arguments (including varargs)<div class="epy_nested">
(C++: func_type_data_t *)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">aux_regs</strong>: buffer for hidden register arguments, may be NULL<div class="epy_nested">
(C++: regobjs_t *)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">aux_stkargs</strong>: buffer for hidden stack arguments, may be NULL<div class="epy_nested">
(C++: relobj_t *)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">nfixed</strong>: number of fixed arguments
(C++: int)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - not implemented</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 - ok</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: -1 - error On some platforms variadic calls require passing<div class="epy_nested">
additional information: for example, number of floating
variadic arguments must be passed in rax on gcc-x64. The
locations and values that constitute this additional
information are returned in the buffers pointed by
aux_regs and aux_stkargs</div>
</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_calcrel"><code class="name flex">
<span>def <span class="ident">ev_calcrel</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Reserved.</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_can_have_type"><code class="name flex">
<span>def <span class="ident">ev_can_have_type</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Can the operand have a type as offset, segment, decimal, etc? (for
example, a register AX can't have a type, meaning that the user can't
change its representation. see 'bytes.hpp' for information about types
and flags)</div>
<div class="epy_par">
<strong class="epy_sig">ev_can_have_type(self, op) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">op</strong> (C++: const op_t *)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - unknown</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: &lt;0 - no</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 - yes</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_clean_tbit"><code class="name flex">
<span>def <span class="ident">ev_clean_tbit</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Clear the TF bit after an insn like pushf stored it in memory.</div>
<div class="epy_par">
<strong class="epy_sig">ev_clean_tbit(self, ea, getreg, regvalues) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong>: instruction address
(C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">getreg</strong>: function to get register values
(C++:<div class="epy_nested">
processor_t::regval_getter_t *)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">regvalues</strong>: register values array
(C++: const regval_t *)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 - ok</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - failed</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_cmp_operands"><code class="name flex">
<span>def <span class="ident">ev_cmp_operands</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Compare instruction operands</div>
<div class="epy_par">
<strong class="epy_sig">ev_cmp_operands(self, op1, op2) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">op1</strong> (C++: const op_t*)</div>
<div class="epy_nested">
<strong class="epy_parameter">op2</strong> (C++: const op_t*)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 - equal</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: -1 - not equal</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - not implemented</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_coagulate"><code class="name flex">
<span>def <span class="ident">ev_coagulate</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Try to define some unexplored bytes. This notification will be called
if the kernel tried all possibilities and could not find anything more
useful than to convert to array of bytes. The module can help the
kernel and convert the bytes into something more useful.</div>
<div class="epy_par">
<strong class="epy_sig">ev_coagulate(self, start_ea) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">start_ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: number of converted bytes</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_coagulate_dref"><code class="name flex">
<span>def <span class="ident">ev_coagulate_dref</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Data reference is being analyzed. plugin may correct 'code_ea' (e.g.
for thumb mode refs, we clear the last bit)</div>
<div class="epy_par">
<strong class="epy_sig">ev_coagulate_dref(self, _from, to, may_define, code_ea) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">_from</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">to</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">may_define</strong> (C++: bool)</div>
<div class="epy_nested">
<strong class="epy_parameter">code_ea</strong> (C++: ea_t *)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: &lt;0 - failed dref analysis, &gt;0 done dref analysis</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - not implemented or continue</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_create_flat_group"><code class="name flex">
<span>def <span class="ident">ev_create_flat_group</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Create special segment representing the flat group.</div>
<div class="epy_par">
<strong class="epy_sig">ev_create_flat_group(self, image_base, bitness, dataseg_sel) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">image_base</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">bitness</strong> (C++: int)</div>
<div class="epy_nested">
<strong class="epy_parameter">dataseg_sel</strong>: return value is ignored
(C++: sel_t)</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_create_func_frame"><code class="name flex">
<span>def <span class="ident">ev_create_func_frame</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Create a function frame for a newly created function Set up frame
size, its attributes etc</div>
<div class="epy_par">
<strong class="epy_sig">ev_create_func_frame(self, pfn) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">pfn</strong> (C++: func_t *)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 - ok</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - not implemented</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_create_merge_handlers"><code class="name flex">
<span>def <span class="ident">ev_create_merge_handlers</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Create merge handlers, if needed</div>
<div class="epy_par">
<strong class="epy_sig">ev_create_merge_handlers(self, md) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">md</strong>: This event is generated immediately after opening idbs.<div class="epy_nested">
(C++: merge_data_t *)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: must be 0</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_create_switch_xrefs"><code class="name flex">
<span>def <span class="ident">ev_create_switch_xrefs</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Create xrefs for a custom jump table.</div>
<div class="epy_par">
<strong class="epy_sig">ev_create_switch_xrefs(self, jumpea, si) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">jumpea</strong>: address of the jump insn
(C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">si</strong>: switch information
(C++: const switch_info_t *)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: must return 1 Must be implemented if module uses custom jump<div class="epy_nested">
tables,</div>
</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_creating_segm"><code class="name flex">
<span>def <span class="ident">ev_creating_segm</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
A new segment is about to be created.</div>
<div class="epy_par">
<strong class="epy_sig">ev_creating_segm(self, seg) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">seg</strong> (C++: segment_t *)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 - ok</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: &lt;0 - segment should not be created</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_decorate_name"><code class="name flex">
<span>def <span class="ident">ev_decorate_name</span></span>(<span>self, *args) &#8209;&gt;&#160;PyObject&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Decorate/undecorate a C symbol name.</div>
<div class="epy_par">
<strong class="epy_sig">ev_decorate_name(self, name, mangle, cc, optional_type) -&gt; PyObject *</strong><div class="epy_nested">
<strong class="epy_parameter">name</strong>: name of symbol
(C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">mangle</strong>: true-mangle, false-unmangle
(C++: bool)</div>
<div class="epy_nested">
<strong class="epy_parameter">cc</strong>: calling convention
(C++: cm_t)
optional_type: tinfo_t const *</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 - if success</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - not implemented or failed</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_del_cref"><code class="name flex">
<span>def <span class="ident">ev_del_cref</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
A code reference is being deleted.</div>
<div class="epy_par">
<strong class="epy_sig">ev_del_cref(self, _from, to, expand) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">_from</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">to</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">expand</strong> (C++: bool)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: &lt;0 - cancel cref deletion</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - not implemented or continue</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_del_dref"><code class="name flex">
<span>def <span class="ident">ev_del_dref</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
A data reference is being deleted.</div>
<div class="epy_par">
<strong class="epy_sig">ev_del_dref(self, _from, to) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">_from</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">to</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: &lt;0 - cancel dref deletion</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - not implemented or continue</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_delay_slot_insn"><code class="name flex">
<span>def <span class="ident">ev_delay_slot_insn</span></span>(<span>self, *args) &#8209;&gt;&#160;PyObject&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get delay slot instructionInput EA may point to the instruction with a
delay slot or to the delay slot instruction itself.</div>
<div class="epy_par">
<strong class="epy_sig">ev_delay_slot_insn(self, ea, bexec, fexec) -&gt; PyObject *</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong>: in: instruction address in question, out: (if the answer is<div class="epy_nested">
positive) if the delay slot contains valid insn: the
address of the delay slot insn else: BADADDR (invalid insn,
e.g. a branch)
(C++: ea_t *)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">bexec</strong>: execute slot if jumping, initially set to 'true'
(C++:<div class="epy_nested">
bool *)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">fexec</strong>: execute slot if not jumping, initally set to 'true'<div class="epy_nested">
(C++: bool *)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 - positive answer</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: &lt;=0 - ordinary insn</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_demangle_name"><code class="name flex">
<span>def <span class="ident">ev_demangle_name</span></span>(<span>self, *args) &#8209;&gt;&#160;PyObject&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Demangle a C++ (or another language) name into a user-readable string.
This event is called by 'demangle_name()' if you call
'demangle_name()' from the handler, protect against recursion!</div>
<div class="epy_par">
<strong class="epy_sig">ev_demangle_name(self, name, disable_mask, demreq) -&gt; PyObject *</strong><div class="epy_nested">
<strong class="epy_parameter">name</strong>: mangled name
(C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">disable_mask</strong>: flags to inhibit parts of output or compiler<div class="epy_nested">
info/other (see MNG_)
(C++: uint32)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">demreq</strong>: operation to perform
(C++: demreq_type_t)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 - if success</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - not implemented</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_emu_insn"><code class="name flex">
<span>def <span class="ident">ev_emu_insn</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Emulate instruction, create cross-references, plan to analyze
subsequent instructions, modify flags etc. Upon entrance to this
function, all information about the instruction is in 'insn'
structure.</div>
<div class="epy_par">
<strong class="epy_sig">ev_emu_insn(self, insn) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">insn</strong> (C++: const insn_t *)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 - ok</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: -1 - the kernel will delete the instruction</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_endbinary"><code class="name flex">
<span>def <span class="ident">ev_endbinary</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
IDA has loaded a binary file.</div>
<div class="epy_par">
<strong class="epy_sig">ev_endbinary(self, ok) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">ok</strong>: file loaded successfully?
(C++: bool)</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_ending_undo"><code class="name flex">
<span>def <span class="ident">ev_ending_undo</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Ended undoing/redoing an action</div>
<div class="epy_par">
<strong class="epy_sig">ev_ending_undo(self, action_name, is_undo) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">action_name</strong>: action that we finished undoing/redoing. is not<div class="epy_nested">
NULL.
(C++: const char *)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">is_undo</strong>: true if performing undo, false if performing redo<div class="epy_nested">
(C++: bool)</div>
</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_equal_reglocs"><code class="name flex">
<span>def <span class="ident">ev_equal_reglocs</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Are 2 register arglocs the same?. We need this callback for the pc
module.</div>
<div class="epy_par">
<strong class="epy_sig">ev_equal_reglocs(self, a1, a2) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">a1</strong> (C++: argloc_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">a2</strong> (C++: argloc_t *)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 - yes</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: -1 - no</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - not implemented</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_extract_address"><code class="name flex">
<span>def <span class="ident">ev_extract_address</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Extract address from a string.</div>
<div class="epy_par">
<strong class="epy_sig">ev_extract_address(self, out_ea, screen_ea, string, position) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">out_ea</strong>: , out
(C++: ea_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">screen_ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">string</strong> (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">position</strong> (C++: size_t)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 - ok</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - kernel should use the standard algorithm</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: -1 - error</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_find_op_value"><code class="name flex">
<span>def <span class="ident">ev_find_op_value</span></span>(<span>self, *args) &#8209;&gt;&#160;PyObject&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Find operand value via a register tracker. The returned value in 'out'
is valid before executing the instruction.</div>
<div class="epy_par">
<strong class="epy_sig">ev_find_op_value(self, pinsn, opn) -&gt; PyObject *</strong><div class="epy_nested">
<strong class="epy_parameter">pinsn</strong>: instruction
(C++: const insn_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">opn</strong>: operand index
(C++: int)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 - if implemented, and value was found</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - not implemented, -1 decoding failed, or no value found</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_find_reg_value"><code class="name flex">
<span>def <span class="ident">ev_find_reg_value</span></span>(<span>self, *args) &#8209;&gt;&#160;PyObject&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Find register value via a register tracker. The returned value in
'out' is valid before executing the instruction.</div>
<div class="epy_par">
<strong class="epy_sig">ev_find_reg_value(self, pinsn, reg) -&gt; PyObject *</strong><div class="epy_nested">
<strong class="epy_parameter">pinsn</strong>: instruction
(C++: const insn_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">reg</strong>: register index
(C++: int)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 - if implemented, and value was found</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - not implemented, -1 decoding failed, or no value found</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_func_bounds"><code class="name flex">
<span>def <span class="ident">ev_func_bounds</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
'find_func_bounds()' finished its work. The module may fine tune the
function bounds</div>
<div class="epy_par">
<strong class="epy_sig">ev_func_bounds(self, possible_return_code, pfn, max_func_end_ea) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">possible_return_code</strong>: , in/out
(C++: int *)</div>
<div class="epy_nested">
<strong class="epy_parameter">pfn</strong> (C++: func_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">max_func_end_ea</strong>: (from the kernel's point of view)
(C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: void -</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_gen_asm_or_lst"><code class="name flex">
<span>def <span class="ident">ev_gen_asm_or_lst</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Callback: generating asm or lst file. The kernel calls this callback
twice, at the beginning and at the end of listing generation. The
processor module can intercept this event and adjust its output</div>
<div class="epy_par">
<strong class="epy_sig">ev_gen_asm_or_lst(self, starting, fp, is_asm, flags, outline) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">starting</strong>: beginning listing generation
(C++: bool)</div>
<div class="epy_nested">
<strong class="epy_parameter">fp</strong>: output file
(C++: FILE *)</div>
<div class="epy_nested">
<strong class="epy_parameter">is_asm</strong>: true:assembler, false:listing
(C++: bool)</div>
<div class="epy_nested">
<strong class="epy_parameter">flags</strong>: flags passed to gen_file()
(C++: int)</div>
<div class="epy_nested">
<strong class="epy_parameter">outline</strong>: ptr to ptr to outline callback. if this callback is<div class="epy_nested">
defined for this code, it will be used by the kernel
to output the generated lines
(C++: html_line_cb_t
**)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: void -</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_gen_map_file"><code class="name flex">
<span>def <span class="ident">ev_gen_map_file</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Generate map file. If not implemented the kernel itself will create
the map file.</div>
<div class="epy_par">
<strong class="epy_sig">ev_gen_map_file(self, nlines, fp) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">nlines</strong>: number of lines in map file (-1 means write error)<div class="epy_nested">
(C++: int *)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">fp</strong>: output file
(C++: FILE *)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - not implemented</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 - ok</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: -1 - write error</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_gen_regvar_def"><code class="name flex">
<span>def <span class="ident">ev_gen_regvar_def</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Generate register variable definition line.</div>
<div class="epy_par">
<strong class="epy_sig">ev_gen_regvar_def(self, outctx, v) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">outctx</strong> (C++: outctx_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">v</strong> (C++: regvar_t *)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: &gt;0 - ok, generated the definition text</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - not implemented</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_gen_src_file_lnnum"><code class="name flex">
<span>def <span class="ident">ev_gen_src_file_lnnum</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Callback: generate analog of:</div>
<div class="epy_par">
&lt; #line "file.c" 123
&lt;</div>
<div class="epy_par">
directive.</div>
<div class="epy_par">
<strong class="epy_sig">ev_gen_src_file_lnnum(self, outctx, file, lnnum) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">outctx</strong>: output context
(C++: outctx_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">file</strong>: source file (may be NULL)
(C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">lnnum</strong>: line number
(C++: size_t)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 - directive has been generated</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - not implemented</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_gen_stkvar_def"><code class="name flex">
<span>def <span class="ident">ev_gen_stkvar_def</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Generate stack variable definition line Default line is varname = type
ptr value, where 'type' is one of byte,word,dword,qword,tbyte</div>
<div class="epy_par">
<strong class="epy_sig">ev_gen_stkvar_def(self, outctx, mptr, v) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">outctx</strong> (C++: outctx_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">mptr</strong> (C++: const member_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">v</strong> (C++: sval_t)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 - ok</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - not implemented</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_get_abi_info"><code class="name flex">
<span>def <span class="ident">ev_get_abi_info</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get all possible ABI names and optional extensions for given compiler
abiname/option is a string entirely consisting of letters, digits and
underscore</div>
<div class="epy_par">
<strong class="epy_sig">ev_get_abi_info(self, abi_names, abi_opts, comp) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">abi_names</strong>: - all possible ABis each in form<div class="epy_nested">
abiname-opt1-opt2-...
(C++: qstrvec_t *)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">abi_opts</strong>: - array of all possible options in form<div class="epy_nested">
"opt:description" or opt:hint-line#description
(C++:
qstrvec_t *)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">comp</strong>: - compiler ID
(C++: comp_t)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - not implemented</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 - ok</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_get_autocmt"><code class="name flex">
<span>def <span class="ident">ev_get_autocmt</span></span>(<span>self, *args) &#8209;&gt;&#160;PyObject&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Callback: get dynamic auto comment. Will be called if the autocomments
are enabled and the comment retrieved from ida.int starts with '$!'.
'insn' contains valid info.</div>
<div class="epy_par">
<strong class="epy_sig">ev_get_autocmt(self, insn) -&gt; PyObject *</strong><div class="epy_nested">
<strong class="epy_parameter">insn</strong>: the instruction
(C++: const insn_t*)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 - new comment has been generated</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - callback has not been handled. the buffer must not be<div class="epy_nested">
changed in this case</div>
</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_get_bg_color"><code class="name flex">
<span>def <span class="ident">ev_get_bg_color</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get item background color. Plugins can hook this callback to color
disassembly lines dynamically</div>
<div class="epy_par">
<strong class="epy_sig">ev_get_bg_color(self, ea) -&gt; int or None</strong><div class="epy_nested">
<strong class="epy_parameter">color</strong>: , out
(C++: bgcolor_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - not implemented</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 - color set</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_get_cc_regs"><code class="name flex">
<span>def <span class="ident">ev_get_cc_regs</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get register allocation convention for given calling convention</div>
<div class="epy_par">
<strong class="epy_sig">ev_get_cc_regs(self, regs, cc) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">regs</strong>: , out
(C++: callregs_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">cc</strong> (C++: cm_t)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 -</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - not implemented</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_get_code16_mode"><code class="name flex">
<span>def <span class="ident">ev_get_code16_mode</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get ISA 16-bit mode</div>
<div class="epy_par">
<strong class="epy_sig">ev_get_code16_mode(self, ea) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong>: address to get the ISA mode
(C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 - 16-bit mode</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - not implemented or 32-bit mode</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_get_dbr_opnum"><code class="name flex">
<span>def <span class="ident">ev_get_dbr_opnum</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get the number of the operand to be displayed in the debugger
reference view (text mode).</div>
<div class="epy_par">
<strong class="epy_sig">ev_get_dbr_opnum(self, opnum, insn) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">opnum</strong>: operand number (out, -1 means no such operand)
(C++:<div class="epy_nested">
int *)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">insn</strong>: the instruction
(C++: const insn_t*)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - unimplemented</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 - implemented</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_get_default_enum_size"><code class="name flex">
<span>def <span class="ident">ev_get_default_enum_size</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get default enum size. Not generated anymore. inf_get_cc_size_e() is
used instead</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_get_frame_retsize"><code class="name flex">
<span>def <span class="ident">ev_get_frame_retsize</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get size of function return address in bytes If this event is not
implemented, the kernel will assume8 bytes for 64-bit function4 bytes
for 32-bit function2 bytes otherwise</div>
<div class="epy_par">
<strong class="epy_sig">ev_get_frame_retsize(self, frsize, pfn) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">frsize</strong>: frame size (out)
(C++: int *)</div>
<div class="epy_nested">
<strong class="epy_parameter">pfn</strong>: , can't be NULL
(C++: const func_t *)</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_get_macro_insn_head"><code class="name flex">
<span>def <span class="ident">ev_get_macro_insn_head</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Calculate the start of a macro instruction. This notification is
called if IP points to the middle of an instruction</div>
<div class="epy_par">
<strong class="epy_sig">ev_get_macro_insn_head(self, head, ip) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">head</strong>: , out: answer, BADADDR means normal instruction
(C++:<div class="epy_nested">
ea_t *)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">ip</strong>: instruction address
(C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - unimplemented</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 - implemented</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_get_operand_string"><code class="name flex">
<span>def <span class="ident">ev_get_operand_string</span></span>(<span>self, *args) &#8209;&gt;&#160;PyObject&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Request text string for operand (cli, java, ...).</div>
<div class="epy_par">
<strong class="epy_sig">ev_get_operand_string(self, insn, opnum) -&gt; PyObject *</strong><div class="epy_nested">
<strong class="epy_parameter">insn</strong>: the instruction
(C++: const insn_t*)</div>
<div class="epy_nested">
<strong class="epy_parameter">opnum</strong>: operand number, -1 means any string operand
(C++: int)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - no string (or empty string)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: &gt;0 - original string length without terminating zero</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_get_procmod"><code class="name flex">
<span>def <span class="ident">ev_get_procmod</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get pointer to the processor module object. All processor modules must
implement this. The pointer is returned as size_t.</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_get_reg_accesses"><code class="name flex">
<span>def <span class="ident">ev_get_reg_accesses</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get info about the registers that are used/changed by an instruction.</div>
<div class="epy_par">
<strong class="epy_sig">ev_get_reg_accesses(self, accvec, insn, flags) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">accvec</strong>: out: info about accessed registers
(C++:<div class="epy_nested">
reg_accesses_t*)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">insn</strong>: instruction in question
(C++: const insn_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">flags</strong>: reserved, must be 0
(C++: int)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: -1 - if accvec is nullptr</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 - found the requested access (and filled accvec)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - not implemented</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_get_reg_info"><code class="name flex">
<span>def <span class="ident">ev_get_reg_info</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get register information by its name. example: "ah"
returns:main_regname="eax" 'bitrange_t' = { offset==8, nbits==8 }This
callback may be unimplemented if the register names are all present in</div>
<div class="epy_par">
\ph{reg_names}<div class="epy_nested">
and they all have the same size</div>
</div>
<div class="epy_par">
<strong class="epy_sig">ev_get_reg_info(self, main_regname, bitrange, regname) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">main_regname</strong>: , out
(C++: const char **)</div>
<div class="epy_nested">
<strong class="epy_parameter">bitrange</strong>: , out: position and size of the value within<div class="epy_nested">
'main_regname' (empty bitrange == whole register)
(C++: bitrange_t *)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">regname</strong> (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 - ok</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: -1 - failed (not found)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - unimplemented</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_get_reg_name"><code class="name flex">
<span>def <span class="ident">ev_get_reg_name</span></span>(<span>self, *args) &#8209;&gt;&#160;PyObject&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Generate text representation of a register. Most processor modules do
not need to implement this callback. It is useful only if</div>
<div class="epy_par">
\ph{reg_names}<div class="epy_nested">
[reg] does not provide the correct register name.</div>
</div>
<div class="epy_par">
<strong class="epy_sig">ev_get_reg_name(self, reg, width, reghi) -&gt; PyObject *</strong><div class="epy_nested">
<strong class="epy_parameter">reg</strong>: internal register number as defined in the processor<div class="epy_nested">
module
(C++: int)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">width</strong>: register width in bytes
(C++: size_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">reghi</strong>: if not -1 then this function will return the register<div class="epy_nested">
pair
(C++: int)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: -1 - if error</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: strlen(buf) - if success</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_get_simd_types"><code class="name flex">
<span>def <span class="ident">ev_get_simd_types</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get SIMD-related types according to given attributes ant/or argument
location</div>
<div class="epy_par">
<strong class="epy_sig">ev_get_simd_types(self, out, simd_attrs, argloc, create_tifs) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">out</strong> (C++: simd_info_vec_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">simd_attrs</strong>: , may be NULL
(C++: const simd_info_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">argloc</strong>: , may be NULL
(C++: const argloc_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">create_tifs</strong>: return valid tinfo_t objects, create if neccessary<div class="epy_nested">
(C++: bool)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: number - of found types</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: -1 - error If name==NULL, initialize all SIMD types</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_get_stkarg_offset"><code class="name flex">
<span>def <span class="ident">ev_get_stkarg_offset</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get offset from SP to the first stack argument. For example: pc: 0,
hppa: -0x34, ppc: 0x38</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_get_stkvar_scale_factor"><code class="name flex">
<span>def <span class="ident">ev_get_stkvar_scale_factor</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Should stack variable references be multiplied by a coefficient before
being used in the stack frame?. Currently used by TMS320C55 because
the references into the stack should be multiplied by 2
'PR_SCALE_STKVARS' should be set to use this callback</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_getreg"><code class="name flex">
<span>def <span class="ident">ev_getreg</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
IBM PC only internal request, should never be used for other purpose
Get register value by internal index</div>
<div class="epy_par">
<strong class="epy_sig">ev_getreg(self, regval, regnum) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">regval</strong>: , out
(C++: uval_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">regnum</strong> (C++: int)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 - ok</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - not implemented</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: -1 - failed (undefined value or bad regnum)</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_init"><code class="name flex">
<span>def <span class="ident">ev_init</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
The IDP module is just loaded.</div>
<div class="epy_par">
<strong class="epy_sig">ev_init(self, idp_modname) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">idp_modname</strong>: processor module name
(C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: &lt;0 - on failure</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_insn_reads_tbit"><code class="name flex">
<span>def <span class="ident">ev_insn_reads_tbit</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Check if insn will read the TF bit.</div>
<div class="epy_par">
<strong class="epy_sig">ev_insn_reads_tbit(self, insn, getreg, regvalues) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">insn</strong>: the instruction
(C++: const insn_t*)</div>
<div class="epy_nested">
<strong class="epy_parameter">getreg</strong>: function to get register values
(C++:<div class="epy_nested">
processor_t::regval_getter_t *)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">regvalues</strong>: register values array
(C++: const regval_t *)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 2 - yes, will generate 'step' exception</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 - yes, will store the TF bit in memory</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - no</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_is_align_insn"><code class="name flex">
<span>def <span class="ident">ev_is_align_insn</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is the instruction created only for alignment purposes?. Do not
directly call this function, use 'is_align_insn()'</div>
<div class="epy_par">
<strong class="epy_sig">ev_is_align_insn(self, ea) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong>: - instruction address
(C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: number - of bytes in the instruction</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_is_alloca_probe"><code class="name flex">
<span>def <span class="ident">ev_is_alloca_probe</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Does the function at 'ea' behave as __alloca_probe?</div>
<div class="epy_par">
<strong class="epy_sig">ev_is_alloca_probe(self, ea) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 - yes</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - no</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_is_basic_block_end"><code class="name flex">
<span>def <span class="ident">ev_is_basic_block_end</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is the current instruction end of a basic block?. This function should
be defined for processors with delayed jump slots.</div>
<div class="epy_par">
<strong class="epy_sig">ev_is_basic_block_end(self, insn, call_insn_stops_block) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">insn</strong>: the instruction
(C++: const insn_t*)</div>
<div class="epy_nested">
<strong class="epy_parameter">call_insn_stops_block</strong> (C++: bool)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - unknown</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: &lt;0 - no</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 - yes</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_is_call_insn"><code class="name flex">
<span>def <span class="ident">ev_is_call_insn</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is the instruction a "call"?</div>
<div class="epy_par">
<strong class="epy_sig">ev_is_call_insn(self, insn) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">insn</strong>: instruction
(C++: const insn_t *)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - unknown</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: &lt;0 - no</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 - yes</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_is_cond_insn"><code class="name flex">
<span>def <span class="ident">ev_is_cond_insn</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is conditional instruction?</div>
<div class="epy_par">
<strong class="epy_sig">ev_is_cond_insn(self, insn) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">insn</strong>: instruction address
(C++: const insn_t *)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 - yes</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: -1 - no</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - not implemented or not instruction</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_is_control_flow_guard"><code class="name flex">
<span>def <span class="ident">ev_is_control_flow_guard</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Detect if an instruction is a "thunk call" to a flow guard function
(equivalent to call reg/return/nop)</div>
<div class="epy_par">
<strong class="epy_sig">ev_is_control_flow_guard(self, p_reg, insn) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">p_reg</strong>: indirect register number, may be -1
(C++: int *)</div>
<div class="epy_nested">
<strong class="epy_parameter">insn</strong>: call/jump instruction
(C++: const insn_t *)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: -1 - no thunk detected</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 - indirect call</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 2 - security check routine call (NOP)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 3 - return thunk</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - not implemented</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_is_far_jump"><code class="name flex">
<span>def <span class="ident">ev_is_far_jump</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
is indirect far jump or call instruction? meaningful only if the
processor has 'near' and 'far' reference types</div>
<div class="epy_par">
<strong class="epy_sig">ev_is_far_jump(self, icode) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">icode</strong> (C++: int)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - not implemented</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 - yes</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: -1 - no</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_is_indirect_jump"><code class="name flex">
<span>def <span class="ident">ev_is_indirect_jump</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Determine if instruction is an indirect jump. If 'CF_JUMP' bit cannot
describe all jump types jumps, please define this callback.</div>
<div class="epy_par">
<strong class="epy_sig">ev_is_indirect_jump(self, insn) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">insn</strong>: the instruction
(C++: const insn_t*)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - use
CF_JUMP</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 - no</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 2 - yes</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_is_insn_table_jump"><code class="name flex">
<span>def <span class="ident">ev_is_insn_table_jump</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Reserved.</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_is_jump_func"><code class="name flex">
<span>def <span class="ident">ev_is_jump_func</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is the function a trivial "jump" function?.</div>
<div class="epy_par">
<strong class="epy_sig">ev_is_jump_func(self, pfn, jump_target, func_pointer) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">pfn</strong> (C++: func_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">jump_target</strong> (C++: ea_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">func_pointer</strong> (C++: ea_t *)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: &lt;0 - no</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - don't know</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 - yes, see 'jump_target' and 'func_pointer'</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_is_ret_insn"><code class="name flex">
<span>def <span class="ident">ev_is_ret_insn</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is the instruction a "return"?</div>
<div class="epy_par">
<strong class="epy_sig">ev_is_ret_insn(self, insn, strict) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">insn</strong>: instruction
(C++: const insn_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">strict</strong>: 1: report only ret instructions 0: include instructions<div class="epy_nested">
like "leave" which begins the function epilog
(C++:
bool)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - unknown</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: &lt;0 - no</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 - yes</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_is_sane_insn"><code class="name flex">
<span>def <span class="ident">ev_is_sane_insn</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is the instruction sane for the current file type?.</div>
<div class="epy_par">
<strong class="epy_sig">ev_is_sane_insn(self, insn, no_crefs) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">insn</strong>: the instruction
(C++: const insn_t*)</div>
<div class="epy_nested">
<strong class="epy_parameter">no_crefs</strong>: 1: the instruction has no code refs to it. ida just<div class="epy_nested">
tries to convert unexplored bytes to an instruction
(but there is no other reason to convert them into an
instruction) 0: the instruction is created because of
some coderef, user request or another weighty reason.
(C++: int)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: &gt;=0 - ok</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: &lt;0 - no, the instruction isn't likely to appear in the<div class="epy_nested">
program</div>
</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_is_sp_based"><code class="name flex">
<span>def <span class="ident">ev_is_sp_based</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Check whether the operand is relative to stack pointer or frame
pointer This event is used to determine how to output a stack variable
If not implemented, then all operands are sp based by default.
Implement this event only if some stack references use frame pointer
instead of stack pointer.</div>
<div class="epy_par">
<strong class="epy_sig">ev_is_sp_based(self, mode, insn, op) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">mode</strong>: out, combination of SP/FP operand flags
(C++: int *)</div>
<div class="epy_nested">
<strong class="epy_parameter">insn</strong> (C++: const insn_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">op</strong> (C++: const op_t *)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - not implemented</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 - ok</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_is_switch"><code class="name flex">
<span>def <span class="ident">ev_is_switch</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Find 'switch' idiom. It will be called for instructions marked with
'CF_JUMP' .</div>
<div class="epy_par">
<strong class="epy_sig">ev_is_switch(self, si, insn) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">si</strong>: , out
(C++: switch_info_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">insn</strong>: instruction possibly belonging to a switch
(C++: const<div class="epy_nested">
insn_t *)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 - switch is found, 'si' is filled</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: -1 - no switch found</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - not implemented</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_last_cb_before_loader"><code class="name flex">
<span>def <span class="ident">ev_last_cb_before_loader</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">ev_last_cb_before_loader(self) -&gt; int</strong></div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_loader"><code class="name flex">
<span>def <span class="ident">ev_loader</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
This code and higher ones are reserved for the loaders. The arguments
and the return values are defined by the loaders</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_lower_func_type"><code class="name flex">
<span>def <span class="ident">ev_lower_func_type</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get function arguments which should be converted to pointers when
lowering function prototype. The processor module can also modify
'fti' in order to make non-standard conversion of some arguments.</div>
<div class="epy_par">
<strong class="epy_sig">ev_lower_func_type(self, argnums, fti) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">argnums</strong>: , out - numbers of arguments to be converted to<div class="epy_nested">
pointers in acsending order
(C++: intvec_t *)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">fti</strong>: , inout func type details (special values -1/-2 for return<div class="epy_nested">
value - position of hidden 'retstr' argument: -1 - at the
beginning, -2 - at the end)
(C++: func_type_data_t *)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - not implemented</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 - argnums was filled</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 2 - argnums was filled and made substantial changes to fti</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_max_ptr_size"><code class="name flex">
<span>def <span class="ident">ev_max_ptr_size</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get maximal size of a pointer in bytes.</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_may_be_func"><code class="name flex">
<span>def <span class="ident">ev_may_be_func</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Can a function start here?</div>
<div class="epy_par">
<strong class="epy_sig">ev_may_be_func(self, insn, state) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">insn</strong>: the instruction
(C++: const insn_t*)</div>
<div class="epy_nested">
<strong class="epy_parameter">state</strong>: autoanalysis phase 0: creating functions 1: creating<div class="epy_nested">
chunks
(C++: int)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: probability 1..100</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_may_show_sreg"><code class="name flex">
<span>def <span class="ident">ev_may_show_sreg</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
The kernel wants to display the segment registers in the messages
window.</div>
<div class="epy_par">
<strong class="epy_sig">ev_may_show_sreg(self, current_ea) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">current_ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: &lt;0 - if the kernel should not show the segment registers.<div class="epy_nested">
(assuming that the module has done it)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - not implemented</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_moving_segm"><code class="name flex">
<span>def <span class="ident">ev_moving_segm</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
May the kernel move the segment?</div>
<div class="epy_par">
<strong class="epy_sig">ev_moving_segm(self, seg, to, flags) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">seg</strong>: segment to move
(C++: segment_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">to</strong>: new segment start address
(C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">flags</strong>: combination of Move segment flags
(C++: int)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - yes</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: &lt;0 - the kernel should stop</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_newasm"><code class="name flex">
<span>def <span class="ident">ev_newasm</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Before setting a new assembler.</div>
<div class="epy_par">
<strong class="epy_sig">ev_newasm(self, asmnum) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">asmnum</strong>: See also ev_asm_installed
(C++: int)</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_newbinary"><code class="name flex">
<span>def <span class="ident">ev_newbinary</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
IDA is about to load a binary file.</div>
<div class="epy_par">
<strong class="epy_sig">ev_newbinary(self, filename, fileoff, basepara, binoff, nbytes) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">filename</strong>: binary file name
(C++: char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">fileoff</strong>: offset in the file
(C++: qoff64_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">basepara</strong>: base loading paragraph
(C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">binoff</strong>: loader offset
(C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">nbytes</strong>: number of bytes to load
(C++: uint64)</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_newfile"><code class="name flex">
<span>def <span class="ident">ev_newfile</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
A new file has been loaded.</div>
<div class="epy_par">
<strong class="epy_sig">ev_newfile(self, fname) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">fname</strong>: input file name
(C++: char *)</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_newprc"><code class="name flex">
<span>def <span class="ident">ev_newprc</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Before changing processor type.</div>
<div class="epy_par">
<strong class="epy_sig">ev_newprc(self, pnum, keep_cfg) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">pnum</strong>: processor number in the array of processor names
(C++:<div class="epy_nested">
int)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">keep_cfg</strong>: true: do not modify kernel configuration
(C++: bool)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 - ok</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: &lt;0 - prohibit</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_next_exec_insn"><code class="name flex">
<span>def <span class="ident">ev_next_exec_insn</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get next address to be executed This function must return the next
address to be executed. If the instruction following the current one
is executed, then it must return 'BADADDR' Usually the instructions to
consider are: jumps, branches, calls, returns. This function is
essential if the 'single step' is not supported in hardware.</div>
<div class="epy_par">
<strong class="epy_sig">ev_next_exec_insn(self, target, ea, tid, getreg, regvalues) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">target</strong>: , out: pointer to the answer
(C++: ea_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">ea</strong>: instruction address
(C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">tid</strong>: current therad id
(C++: int)</div>
<div class="epy_nested">
<strong class="epy_parameter">getreg</strong>: function to get register values
(C++:<div class="epy_nested">
processor_t::regval_getter_t *)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">regvalues</strong>: register values array
(C++: const regval_t *)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - unimplemented</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 - implemented</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_oldfile"><code class="name flex">
<span>def <span class="ident">ev_oldfile</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
An old file has been loaded.</div>
<div class="epy_par">
<strong class="epy_sig">ev_oldfile(self, fname) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">fname</strong>: input file name
(C++: char *)</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_out_assumes"><code class="name flex">
<span>def <span class="ident">ev_out_assumes</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Function to produce assume directives when segment register value
changes.</div>
<div class="epy_par">
<strong class="epy_sig">ev_out_assumes(self, outctx) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">outctx</strong> (C++: outctx_t *)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 - ok</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - not implemented</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_out_data"><code class="name flex">
<span>def <span class="ident">ev_out_data</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Generate text representation of data items This function may change
the database and create cross-references if analyze_only is set</div>
<div class="epy_par">
<strong class="epy_sig">ev_out_data(self, outctx, analyze_only) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">outctx</strong> (C++: outctx_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">analyze_only</strong> (C++: bool)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 - ok</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - not implemented</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_out_footer"><code class="name flex">
<span>def <span class="ident">ev_out_footer</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Function to produce end of disassembled text</div>
<div class="epy_par">
<strong class="epy_sig">ev_out_footer(self, outctx) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">outctx</strong> (C++: outctx_t *)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: void -</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_out_header"><code class="name flex">
<span>def <span class="ident">ev_out_header</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Function to produce start of disassembled text</div>
<div class="epy_par">
<strong class="epy_sig">ev_out_header(self, outctx) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">outctx</strong> (C++: outctx_t *)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: void -</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_out_insn"><code class="name flex">
<span>def <span class="ident">ev_out_insn</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Generate text representation of an instruction in 'ctx.insn'
'outctx_t' provides functions to output the generated text. This
function shouldn't change the database, flags or anything else. All
these actions should be performed only by emu_insn() function.</div>
<div class="epy_par">
<strong class="epy_sig">ev_out_insn(self, outctx) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">outctx</strong> (C++: outctx_t *)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: void -</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_out_label"><code class="name flex">
<span>def <span class="ident">ev_out_label</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
The kernel is going to generate an instruction label line or a
function header.</div>
<div class="epy_par">
<strong class="epy_sig">ev_out_label(self, outctx, colored_name) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">outctx</strong> (C++: outctx_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">colored_name</strong> (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: &lt;0 - if the kernel should not generate the label</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - not implemented or continue</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_out_mnem"><code class="name flex">
<span>def <span class="ident">ev_out_mnem</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Generate instruction mnemonics. This callback should append the
colored mnemonics to ctx.outbuf Optional notification, if absent,
out_mnem will be called.</div>
<div class="epy_par">
<strong class="epy_sig">ev_out_mnem(self, outctx) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">outctx</strong> (C++: outctx_t *)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 - if appended the mnemonics</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - not implemented</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_out_operand"><code class="name flex">
<span>def <span class="ident">ev_out_operand</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Generate text representation of an instruction operand 'outctx_t'
provides functions to output the generated text. All these actions
should be performed only by emu_insn() function.</div>
<div class="epy_par">
<strong class="epy_sig">ev_out_operand(self, outctx, op) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">outctx</strong> (C++: outctx_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">op</strong> (C++: const op_t *)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 - ok</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: -1 - operand is hidden</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_out_segend"><code class="name flex">
<span>def <span class="ident">ev_out_segend</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Function to produce end of segment</div>
<div class="epy_par">
<strong class="epy_sig">ev_out_segend(self, outctx, seg) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">outctx</strong> (C++: outctx_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">seg</strong> (C++: segment_t *)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 - ok</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - not implemented</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_out_segstart"><code class="name flex">
<span>def <span class="ident">ev_out_segstart</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Function to produce start of segment</div>
<div class="epy_par">
<strong class="epy_sig">ev_out_segstart(self, outctx, seg) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">outctx</strong> (C++: outctx_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">seg</strong> (C++: segment_t *)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 - ok</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - not implemented</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_out_special_item"><code class="name flex">
<span>def <span class="ident">ev_out_special_item</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Generate text representation of an item in a special segment i.e.
absolute symbols, externs, communal definitions etc</div>
<div class="epy_par">
<strong class="epy_sig">ev_out_special_item(self, outctx, segtype) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">outctx</strong> (C++: outctx_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">segtype</strong> (C++: uchar)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 - ok</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - not implemented</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: -1 - overflow</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_realcvt"><code class="name flex">
<span>def <span class="ident">ev_realcvt</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Floating point -&gt; IEEE conversion</div>
<div class="epy_par">
<strong class="epy_sig">ev_realcvt(self, m, e, swt) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">m</strong>: ptr to processor-specific floating point value
(C++: void<div class="epy_nested">
*)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">e</strong>: IDA representation of a floating point value
(C++:<div class="epy_nested">
fpvalue_t *)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">swt</strong>: operation (see realcvt() in ieee.h)
(C++: uint16)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - not implemented</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 - ok</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_rename"><code class="name flex">
<span>def <span class="ident">ev_rename</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
The kernel is going to rename a byte.</div>
<div class="epy_par">
<strong class="epy_sig">ev_rename(self, ea, new_name) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">new_name</strong> (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: &lt;0 - if the kernel should not rename it.</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 2 - to inhibit the notification. I.e., the kernel should not<div class="epy_nested">
rename, but ' set_name() ' should return 'true'. also see</div>
</div>
</div>
<div class="epy_par">
\idpcode{renamed}<div class="epy_nested">
the return value is ignored when kernel
is going to delete name</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_replaying_undo"><code class="name flex">
<span>def <span class="ident">ev_replaying_undo</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Replaying an undo/redo buffer</div>
<div class="epy_par">
<strong class="epy_sig">ev_replaying_undo(self, action_name, vec, is_undo) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">action_name</strong>: action that we perform undo/redo for. may be NULL<div class="epy_nested">
for intermediary buffers.
(C++: const char *)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">vec</strong> (C++: const undo_records_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">is_undo</strong>: true if performing undo, false if performing redo This<div class="epy_nested">
event may be generated multiple times per undo/redo
(C++: bool)</div>
</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_set_code16_mode"><code class="name flex">
<span>def <span class="ident">ev_set_code16_mode</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Some processors have ISA 16-bit mode e.g. ARM Thumb mode, PPC VLE,
MIPS16 Set ISA 16-bit mode</div>
<div class="epy_par">
<strong class="epy_sig">ev_set_code16_mode(self, ea, code16) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong>: address to set new ISA mode
(C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">code16</strong>: true for 16-bit mode, false for 32-bit mode
(C++:<div class="epy_nested">
bool)</div>
</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_set_idp_options"><code class="name flex">
<span>def <span class="ident">ev_set_idp_options</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Set IDP-specific configuration option Also see set_options_t in
'config.hpp'</div>
<div class="epy_par">
<strong class="epy_sig">ev_set_idp_options(self, keyword, value_type, value, idb_loaded) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">keyword</strong> (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">value_type</strong> (C++: int)</div>
<div class="epy_nested">
<strong class="epy_parameter">value</strong> (C++: const void *)</div>
<div class="epy_nested">
<strong class="epy_parameter">idb_loaded</strong>: true if the ev_oldfile/ev_newfile events have been<div class="epy_nested">
generated
(C++: bool)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 - ok</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - not implemented</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: -1 - error (and message in errbuf)</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_set_proc_options"><code class="name flex">
<span>def <span class="ident">ev_set_proc_options</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Called if the user specified an option string in the command line:
-p<processor name="">:<options>. Can be used for setting a processor
subtype. Also called if option string is passed to
'set_processor_type()' and IDC's SetProcessorType().</options></processor></div>
<div class="epy_par">
<strong class="epy_sig">ev_set_proc_options(self, options, confidence) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">options</strong> (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">confidence</strong>: 0: loader's suggestion 1: user's decision
(C++:<div class="epy_nested">
int)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: &lt;0 - if bad option string</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_setup_til"><code class="name flex">
<span>def <span class="ident">ev_setup_til</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Setup default type libraries. (called after loading a new file into
the database). The processor module may load tils, setup memory model
and perform other actions required to set up the type system. This is
an optional callback.</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_shadow_args_size"><code class="name flex">
<span>def <span class="ident">ev_shadow_args_size</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get size of shadow args in bytes.</div>
<div class="epy_par">
<strong class="epy_sig">ev_shadow_args_size(self, shadow_args_size, pfn) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">shadow_args_size</strong> (C++: int *)</div>
<div class="epy_nested">
<strong class="epy_parameter">pfn</strong>: (may be NULL)
(C++: func_t *)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 - if filled *shadow_args_size</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - not implemented</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_str2reg"><code class="name flex">
<span>def <span class="ident">ev_str2reg</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Convert a register name to a register number. The register number is
the register index in the \ph{reg_names}
array Most processor modules
do not need to implement this callback It is useful only if</div>
<div class="epy_par">
\ph{reg_names}<div class="epy_nested">
[reg] does not provide the correct register names</div>
</div>
<div class="epy_par">
<strong class="epy_sig">ev_str2reg(self, regname) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">regname</strong> (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: register - number + 1</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - not implemented or could not be decoded</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_term"><code class="name flex">
<span>def <span class="ident">ev_term</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
The IDP module is being unloaded.</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_treat_hindering_item"><code class="name flex">
<span>def <span class="ident">ev_treat_hindering_item</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
An item hinders creation of another item.</div>
<div class="epy_par">
<strong class="epy_sig">ev_treat_hindering_item(self, hindering_item_ea, new_item_flags, new_item_ea, new_item_length) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">hindering_item_ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">new_item_flags</strong>: (0 for code)
(C++: flags_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">new_item_ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">new_item_length</strong> (C++: asize_t)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - no reaction</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: !=0 - the kernel may delete the hindering item</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_undefine"><code class="name flex">
<span>def <span class="ident">ev_undefine</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
An item in the database (insn or data) is being deleted.</div>
<div class="epy_par">
<strong class="epy_sig">ev_undefine(self, ea) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 - do not delete srranges at the item end</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - srranges can be deleted</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_update_call_stack"><code class="name flex">
<span>def <span class="ident">ev_update_call_stack</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Calculate the call stack trace for the given thread. This callback is
invoked when the process is suspended and should fill the 'trace'
object with the information about the current call stack. Note that
this callback is NOT invoked if the current debugger backend
implements stack tracing via
debugger_t::event_t::ev_update_call_stack. The debugger-specific
algorithm takes priority. Implementing this callback in the processor
module is useful when multiple debugging platforms follow similar
patterns, and thus the same processor-specific algorithm can be used
for different platforms.</div>
<div class="epy_par">
<strong class="epy_sig">ev_update_call_stack(self, stack, tid, getreg, regvalues) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">stack</strong>: result
(C++: call_stack_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">tid</strong>: thread id
(C++: int)</div>
<div class="epy_nested">
<strong class="epy_parameter">getreg</strong>: function to get register values
(C++:<div class="epy_nested">
processor_t::regval_getter_t *)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">regvalues</strong>: register values array
(C++: const regval_t *)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 - ok</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: -1 - failed</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - unimplemented</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_use_arg_types"><code class="name flex">
<span>def <span class="ident">ev_use_arg_types</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Use information about callee arguments.</div>
<div class="epy_par">
<strong class="epy_sig">ev_use_arg_types(self, ea, fti, rargs) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong>: address of the call instruction
(C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">fti</strong>: info about function type
(C++: func_type_data_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">rargs</strong>: array of register arguments
(C++: funcargvec_t *)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 - (and removes handled arguments from fti and rargs)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - not implemented</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_use_regarg_type"><code class="name flex">
<span>def <span class="ident">ev_use_regarg_type</span></span>(<span>self, *args) &#8209;&gt;&#160;PyObject&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Use information about register argument.</div>
<div class="epy_par">
<strong class="epy_sig">ev_use_regarg_type(self, ea, rargs) -&gt; PyObject *</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong>: address of the instruction
(C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">rargs</strong>: vector of register arguments (including regs extracted<div class="epy_nested">
from scattered arguments)
(C++: const funcargvec_t *)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 -</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - not implemented</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_use_stkarg_type"><code class="name flex">
<span>def <span class="ident">ev_use_stkarg_type</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Use information about a stack argument.</div>
<div class="epy_par">
<strong class="epy_sig">ev_use_stkarg_type(self, ea, arg) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong>: address of the push instruction which pushes the function<div class="epy_nested">
argument into the stack
(C++: ea_t)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">arg</strong>: argument info
(C++: const funcarg_t *)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 - ok</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: &lt;=0 - failed, the kernel will create a comment with the<div class="epy_nested">
argument name or type for the instruction</div>
</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_validate_flirt_func"><code class="name flex">
<span>def <span class="ident">ev_validate_flirt_func</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Flirt has recognized a library function. This callback can be used by
a plugin or proc module to intercept it and validate such a function.</div>
<div class="epy_par">
<strong class="epy_sig">ev_validate_flirt_func(self, start_ea, funcname) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">start_ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">funcname</strong> (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: -1 - do not create a function,</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - function is validated</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_verify_noreturn"><code class="name flex">
<span>def <span class="ident">ev_verify_noreturn</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
The kernel wants to set 'noreturn' flags for a function.</div>
<div class="epy_par">
<strong class="epy_sig">ev_verify_noreturn(self, pfn) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">pfn</strong> (C++: func_t *)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - ok. any other value: do not set 'noreturn' flag</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.ev_verify_sp"><code class="name flex">
<span>def <span class="ident">ev_verify_sp</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
All function instructions have been analyzed. Now the processor module
can analyze the stack pointer for the whole function</div>
<div class="epy_par">
<strong class="epy_sig">ev_verify_sp(self, pfn) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">pfn</strong> (C++: func_t *)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - ok</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: &lt;0 - bad stack pointer</div>
</div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.hook"><code class="name flex">
<span>def <span class="ident">hook</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">hook(self) -&gt; bool</strong></div></div>
</dd>
<dt id="ida_idp.IDP_Hooks.unhook"><code class="name flex">
<span>def <span class="ident">unhook</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">unhook(self) -&gt; bool</strong></div></div>
</dd>
</dl>
</dd>
<dt id="ida_idp.asm_t"><code class="flex name class">
<span>class <span class="ident">asm_t</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ asm_t class.</div>
<div class="epy_par">
<strong class="epy_sig">__init__(self) -&gt; asm_t</strong></div></div>
<h3>Instance variables</h3>
<dl>
<dt id="ida_idp.asm_t.a_align"><code class="name">var <span class="ident">a_align</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">asm_t_a_align_get(self) -&gt; char const *</strong></div></div>
</dd>
<dt id="ida_idp.asm_t.a_ascii"><code class="name">var <span class="ident">a_ascii</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">asm_t_a_ascii_get(self) -&gt; char const *</strong></div></div>
</dd>
<dt id="ida_idp.asm_t.a_band"><code class="name">var <span class="ident">a_band</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">asm_t_a_band_get(self) -&gt; char const *</strong></div></div>
</dd>
<dt id="ida_idp.asm_t.a_bnot"><code class="name">var <span class="ident">a_bnot</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">asm_t_a_bnot_get(self) -&gt; char const *</strong></div></div>
</dd>
<dt id="ida_idp.asm_t.a_bor"><code class="name">var <span class="ident">a_bor</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">asm_t_a_bor_get(self) -&gt; char const *</strong></div></div>
</dd>
<dt id="ida_idp.asm_t.a_bss"><code class="name">var <span class="ident">a_bss</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">asm_t_a_bss_get(self) -&gt; char const *</strong></div></div>
</dd>
<dt id="ida_idp.asm_t.a_byte"><code class="name">var <span class="ident">a_byte</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">asm_t_a_byte_get(self) -&gt; char const *</strong></div></div>
</dd>
<dt id="ida_idp.asm_t.a_comdef"><code class="name">var <span class="ident">a_comdef</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">asm_t_a_comdef_get(self) -&gt; char const *</strong></div></div>
</dd>
<dt id="ida_idp.asm_t.a_curip"><code class="name">var <span class="ident">a_curip</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">asm_t_a_curip_get(self) -&gt; char const *</strong></div></div>
</dd>
<dt id="ida_idp.asm_t.a_double"><code class="name">var <span class="ident">a_double</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">asm_t_a_double_get(self) -&gt; char const *</strong></div></div>
</dd>
<dt id="ida_idp.asm_t.a_dups"><code class="name">var <span class="ident">a_dups</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">asm_t_a_dups_get(self) -&gt; char const *</strong></div></div>
</dd>
<dt id="ida_idp.asm_t.a_dword"><code class="name">var <span class="ident">a_dword</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">asm_t_a_dword_get(self) -&gt; char const *</strong></div></div>
</dd>
<dt id="ida_idp.asm_t.a_equ"><code class="name">var <span class="ident">a_equ</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">asm_t_a_equ_get(self) -&gt; char const *</strong></div></div>
</dd>
<dt id="ida_idp.asm_t.a_extrn"><code class="name">var <span class="ident">a_extrn</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">asm_t_a_extrn_get(self) -&gt; char const *</strong></div></div>
</dd>
<dt id="ida_idp.asm_t.a_float"><code class="name">var <span class="ident">a_float</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">asm_t_a_float_get(self) -&gt; char const *</strong></div></div>
</dd>
<dt id="ida_idp.asm_t.a_include_fmt"><code class="name">var <span class="ident">a_include_fmt</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">asm_t_a_include_fmt_get(self) -&gt; char const *</strong></div></div>
</dd>
<dt id="ida_idp.asm_t.a_mod"><code class="name">var <span class="ident">a_mod</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">asm_t_a_mod_get(self) -&gt; char const *</strong></div></div>
</dd>
<dt id="ida_idp.asm_t.a_oword"><code class="name">var <span class="ident">a_oword</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">asm_t_a_oword_get(self) -&gt; char const *</strong></div></div>
</dd>
<dt id="ida_idp.asm_t.a_packreal"><code class="name">var <span class="ident">a_packreal</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">asm_t_a_packreal_get(self) -&gt; char const *</strong></div></div>
</dd>
<dt id="ida_idp.asm_t.a_public"><code class="name">var <span class="ident">a_public</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">asm_t_a_public_get(self) -&gt; char const *</strong></div></div>
</dd>
<dt id="ida_idp.asm_t.a_qword"><code class="name">var <span class="ident">a_qword</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">asm_t_a_qword_get(self) -&gt; char const *</strong></div></div>
</dd>
<dt id="ida_idp.asm_t.a_rva"><code class="name">var <span class="ident">a_rva</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">asm_t_a_rva_get(self) -&gt; char const *</strong></div></div>
</dd>
<dt id="ida_idp.asm_t.a_seg"><code class="name">var <span class="ident">a_seg</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">asm_t_a_seg_get(self) -&gt; char const *</strong></div></div>
</dd>
<dt id="ida_idp.asm_t.a_shl"><code class="name">var <span class="ident">a_shl</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">asm_t_a_shl_get(self) -&gt; char const *</strong></div></div>
</dd>
<dt id="ida_idp.asm_t.a_shr"><code class="name">var <span class="ident">a_shr</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">asm_t_a_shr_get(self) -&gt; char const *</strong></div></div>
</dd>
<dt id="ida_idp.asm_t.a_sizeof_fmt"><code class="name">var <span class="ident">a_sizeof_fmt</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">asm_t_a_sizeof_fmt_get(self) -&gt; char const *</strong></div></div>
</dd>
<dt id="ida_idp.asm_t.a_tbyte"><code class="name">var <span class="ident">a_tbyte</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">asm_t_a_tbyte_get(self) -&gt; char const *</strong></div></div>
</dd>
<dt id="ida_idp.asm_t.a_vstruc_fmt"><code class="name">var <span class="ident">a_vstruc_fmt</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">asm_t_a_vstruc_fmt_get(self) -&gt; char const *</strong></div></div>
</dd>
<dt id="ida_idp.asm_t.a_weak"><code class="name">var <span class="ident">a_weak</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">asm_t_a_weak_get(self) -&gt; char const *</strong></div></div>
</dd>
<dt id="ida_idp.asm_t.a_word"><code class="name">var <span class="ident">a_word</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">asm_t_a_word_get(self) -&gt; char const *</strong></div></div>
</dd>
<dt id="ida_idp.asm_t.a_xor"><code class="name">var <span class="ident">a_xor</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">asm_t_a_xor_get(self) -&gt; char const *</strong></div></div>
</dd>
<dt id="ida_idp.asm_t.a_yword"><code class="name">var <span class="ident">a_yword</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">asm_t_a_yword_get(self) -&gt; char const *</strong></div></div>
</dd>
<dt id="ida_idp.asm_t.accsep"><code class="name">var <span class="ident">accsep</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">asm_t_accsep_get(self) -&gt; char</strong></div></div>
</dd>
<dt id="ida_idp.asm_t.ascsep"><code class="name">var <span class="ident">ascsep</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">asm_t_ascsep_get(self) -&gt; char</strong></div></div>
</dd>
<dt id="ida_idp.asm_t.cmnt"><code class="name">var <span class="ident">cmnt</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">asm_t_cmnt_get(self) -&gt; char const *</strong></div></div>
</dd>
<dt id="ida_idp.asm_t.cmnt2"><code class="name">var <span class="ident">cmnt2</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">asm_t_cmnt2_get(self) -&gt; char const *</strong></div></div>
</dd>
<dt id="ida_idp.asm_t.end"><code class="name">var <span class="ident">end</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">asm_t_end_get(self) -&gt; char const *</strong></div></div>
</dd>
<dt id="ida_idp.asm_t.esccodes"><code class="name">var <span class="ident">esccodes</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">asm_t_esccodes_get(self) -&gt; char const *</strong></div></div>
</dd>
<dt id="ida_idp.asm_t.flag"><code class="name">var <span class="ident">flag</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">asm_t_flag_get(self) -&gt; uint32</strong></div></div>
</dd>
<dt id="ida_idp.asm_t.flag2"><code class="name">var <span class="ident">flag2</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">asm_t_flag2_get(self) -&gt; uint32</strong></div></div>
</dd>
<dt id="ida_idp.asm_t.header"><code class="name">var <span class="ident">header</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">asm_t_header_get(self) -&gt; char const *const *</strong></div></div>
</dd>
<dt id="ida_idp.asm_t.help"><code class="name">var <span class="ident">help</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">asm_t_help_get(self) -&gt; help_t</strong></div></div>
</dd>
<dt id="ida_idp.asm_t.high16"><code class="name">var <span class="ident">high16</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">asm_t_high16_get(self) -&gt; char const *</strong></div></div>
</dd>
<dt id="ida_idp.asm_t.high8"><code class="name">var <span class="ident">high8</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">asm_t_high8_get(self) -&gt; char const *</strong></div></div>
</dd>
<dt id="ida_idp.asm_t.lbrace"><code class="name">var <span class="ident">lbrace</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">asm_t_lbrace_get(self) -&gt; char</strong></div></div>
</dd>
<dt id="ida_idp.asm_t.low16"><code class="name">var <span class="ident">low16</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">asm_t_low16_get(self) -&gt; char const *</strong></div></div>
</dd>
<dt id="ida_idp.asm_t.low8"><code class="name">var <span class="ident">low8</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">asm_t_low8_get(self) -&gt; char const *</strong></div></div>
</dd>
<dt id="ida_idp.asm_t.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">asm_t_name_get(self) -&gt; char const *</strong></div></div>
</dd>
<dt id="ida_idp.asm_t.origin"><code class="name">var <span class="ident">origin</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">asm_t_origin_get(self) -&gt; char const *</strong></div></div>
</dd>
<dt id="ida_idp.asm_t.rbrace"><code class="name">var <span class="ident">rbrace</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">asm_t_rbrace_get(self) -&gt; char</strong></div></div>
</dd>
<dt id="ida_idp.asm_t.uflag"><code class="name">var <span class="ident">uflag</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">asm_t_uflag_get(self) -&gt; uint16</strong></div></div>
</dd>
</dl>
</dd>
<dt id="ida_idp.processor_t"><code class="flex name class">
<span>class <span class="ident">processor_t</span></span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ IDP_Hooks class.</div>
<div class="epy_par">
<strong class="epy_sig">__init__(self, _flags=0) -&gt; IDP_Hooks</strong><div class="epy_nested">
_flags: uint32</div>
</div></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="ida_idp.IDP_Hooks" href="#ida_idp.IDP_Hooks">IDP_Hooks</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="ida_idp.processor_t.auto_empty"><code class="name flex">
<span>def <span class="ident">auto_empty</span></span>(<span>self, *args)</span>
</code></dt>
<dd>
<div class="desc"/>
</dd>
<dt id="ida_idp.processor_t.auto_empty_finally"><code class="name flex">
<span>def <span class="ident">auto_empty_finally</span></span>(<span>self, *args)</span>
</code></dt>
<dd>
<div class="desc"/>
</dd>
<dt id="ida_idp.processor_t.closebase"><code class="name flex">
<span>def <span class="ident">closebase</span></span>(<span>self, *args)</span>
</code></dt>
<dd>
<div class="desc"/>
</dd>
<dt id="ida_idp.processor_t.compiler_changed"><code class="name flex">
<span>def <span class="ident">compiler_changed</span></span>(<span>self, *args)</span>
</code></dt>
<dd>
<div class="desc"/>
</dd>
<dt id="ida_idp.processor_t.deleting_func"><code class="name flex">
<span>def <span class="ident">deleting_func</span></span>(<span>self, pfn)</span>
</code></dt>
<dd>
<div class="desc"/>
</dd>
<dt id="ida_idp.processor_t.determined_main"><code class="name flex">
<span>def <span class="ident">determined_main</span></span>(<span>self, *args)</span>
</code></dt>
<dd>
<div class="desc"/>
</dd>
<dt id="ida_idp.processor_t.func_added"><code class="name flex">
<span>def <span class="ident">func_added</span></span>(<span>self, pfn)</span>
</code></dt>
<dd>
<div class="desc"/>
</dd>
<dt id="ida_idp.processor_t.get_auxpref"><code class="name flex">
<span>def <span class="ident">get_auxpref</span></span>(<span>self, insn)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
This function returns insn.auxpref value</div></div>
</dd>
<dt id="ida_idp.processor_t.get_idpdesc"><code class="name flex">
<span>def <span class="ident">get_idpdesc</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
This function must be present and should return the list of
short processor names similar to the one in ph.psnames.
This method can be overridden to return to the kernel a different IDP description.</div></div>
</dd>
<dt id="ida_idp.processor_t.get_uFlag"><code class="name flex">
<span>def <span class="ident">get_uFlag</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Use this utility function to retrieve the 'uFlag' global variable</div></div>
</dd>
<dt id="ida_idp.processor_t.idasgn_loaded"><code class="name flex">
<span>def <span class="ident">idasgn_loaded</span></span>(<span>self, *args)</span>
</code></dt>
<dd>
<div class="desc"/>
</dd>
<dt id="ida_idp.processor_t.kernel_config_loaded"><code class="name flex">
<span>def <span class="ident">kernel_config_loaded</span></span>(<span>self, *args)</span>
</code></dt>
<dd>
<div class="desc"/>
</dd>
<dt id="ida_idp.processor_t.make_code"><code class="name flex">
<span>def <span class="ident">make_code</span></span>(<span>self, *args)</span>
</code></dt>
<dd>
<div class="desc"/>
</dd>
<dt id="ida_idp.processor_t.make_data"><code class="name flex">
<span>def <span class="ident">make_data</span></span>(<span>self, *args)</span>
</code></dt>
<dd>
<div class="desc"/>
</dd>
<dt id="ida_idp.processor_t.renamed"><code class="name flex">
<span>def <span class="ident">renamed</span></span>(<span>self, *args)</span>
</code></dt>
<dd>
<div class="desc"/>
</dd>
<dt id="ida_idp.processor_t.savebase"><code class="name flex">
<span>def <span class="ident">savebase</span></span>(<span>self, *args)</span>
</code></dt>
<dd>
<div class="desc"/>
</dd>
<dt id="ida_idp.processor_t.segm_moved"><code class="name flex">
<span>def <span class="ident">segm_moved</span></span>(<span>self, from_ea, to_ea, size, changed_netmap)</span>
</code></dt>
<dd>
<div class="desc"/>
</dd>
<dt id="ida_idp.processor_t.set_func_end"><code class="name flex">
<span>def <span class="ident">set_func_end</span></span>(<span>self, *args)</span>
</code></dt>
<dd>
<div class="desc"/>
</dd>
<dt id="ida_idp.processor_t.set_func_start"><code class="name flex">
<span>def <span class="ident">set_func_start</span></span>(<span>self, *args)</span>
</code></dt>
<dd>
<div class="desc"/>
</dd>
<dt id="ida_idp.processor_t.sgr_changed"><code class="name flex">
<span>def <span class="ident">sgr_changed</span></span>(<span>self, *args)</span>
</code></dt>
<dd>
<div class="desc"/>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="ida_idp.IDP_Hooks" href="#ida_idp.IDP_Hooks">IDP_Hooks</a></b></code>:
<ul class="hlist">
<li><code><a title="ida_idp.IDP_Hooks.ev_add_cref" href="#ida_idp.IDP_Hooks.ev_add_cref">ev_add_cref</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_add_dref" href="#ida_idp.IDP_Hooks.ev_add_dref">ev_add_dref</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_adjust_argloc" href="#ida_idp.IDP_Hooks.ev_adjust_argloc">ev_adjust_argloc</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_adjust_libfunc_ea" href="#ida_idp.IDP_Hooks.ev_adjust_libfunc_ea">ev_adjust_libfunc_ea</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_adjust_refinfo" href="#ida_idp.IDP_Hooks.ev_adjust_refinfo">ev_adjust_refinfo</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_ana_insn" href="#ida_idp.IDP_Hooks.ev_ana_insn">ev_ana_insn</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_analyze_prolog" href="#ida_idp.IDP_Hooks.ev_analyze_prolog">ev_analyze_prolog</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_arch_changed" href="#ida_idp.IDP_Hooks.ev_arch_changed">ev_arch_changed</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_arg_addrs_ready" href="#ida_idp.IDP_Hooks.ev_arg_addrs_ready">ev_arg_addrs_ready</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_asm_installed" href="#ida_idp.IDP_Hooks.ev_asm_installed">ev_asm_installed</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_assemble" href="#ida_idp.IDP_Hooks.ev_assemble">ev_assemble</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_auto_queue_empty" href="#ida_idp.IDP_Hooks.ev_auto_queue_empty">ev_auto_queue_empty</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_calc_arglocs" href="#ida_idp.IDP_Hooks.ev_calc_arglocs">ev_calc_arglocs</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_calc_cdecl_purged_bytes" href="#ida_idp.IDP_Hooks.ev_calc_cdecl_purged_bytes">ev_calc_cdecl_purged_bytes</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_calc_next_eas" href="#ida_idp.IDP_Hooks.ev_calc_next_eas">ev_calc_next_eas</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_calc_purged_bytes" href="#ida_idp.IDP_Hooks.ev_calc_purged_bytes">ev_calc_purged_bytes</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_calc_retloc" href="#ida_idp.IDP_Hooks.ev_calc_retloc">ev_calc_retloc</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_calc_spdelta" href="#ida_idp.IDP_Hooks.ev_calc_spdelta">ev_calc_spdelta</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_calc_step_over" href="#ida_idp.IDP_Hooks.ev_calc_step_over">ev_calc_step_over</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_calc_switch_cases" href="#ida_idp.IDP_Hooks.ev_calc_switch_cases">ev_calc_switch_cases</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_calc_varglocs" href="#ida_idp.IDP_Hooks.ev_calc_varglocs">ev_calc_varglocs</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_calcrel" href="#ida_idp.IDP_Hooks.ev_calcrel">ev_calcrel</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_can_have_type" href="#ida_idp.IDP_Hooks.ev_can_have_type">ev_can_have_type</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_clean_tbit" href="#ida_idp.IDP_Hooks.ev_clean_tbit">ev_clean_tbit</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_cmp_operands" href="#ida_idp.IDP_Hooks.ev_cmp_operands">ev_cmp_operands</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_coagulate" href="#ida_idp.IDP_Hooks.ev_coagulate">ev_coagulate</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_coagulate_dref" href="#ida_idp.IDP_Hooks.ev_coagulate_dref">ev_coagulate_dref</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_create_flat_group" href="#ida_idp.IDP_Hooks.ev_create_flat_group">ev_create_flat_group</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_create_func_frame" href="#ida_idp.IDP_Hooks.ev_create_func_frame">ev_create_func_frame</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_create_merge_handlers" href="#ida_idp.IDP_Hooks.ev_create_merge_handlers">ev_create_merge_handlers</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_create_switch_xrefs" href="#ida_idp.IDP_Hooks.ev_create_switch_xrefs">ev_create_switch_xrefs</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_creating_segm" href="#ida_idp.IDP_Hooks.ev_creating_segm">ev_creating_segm</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_decorate_name" href="#ida_idp.IDP_Hooks.ev_decorate_name">ev_decorate_name</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_del_cref" href="#ida_idp.IDP_Hooks.ev_del_cref">ev_del_cref</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_del_dref" href="#ida_idp.IDP_Hooks.ev_del_dref">ev_del_dref</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_delay_slot_insn" href="#ida_idp.IDP_Hooks.ev_delay_slot_insn">ev_delay_slot_insn</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_demangle_name" href="#ida_idp.IDP_Hooks.ev_demangle_name">ev_demangle_name</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_emu_insn" href="#ida_idp.IDP_Hooks.ev_emu_insn">ev_emu_insn</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_endbinary" href="#ida_idp.IDP_Hooks.ev_endbinary">ev_endbinary</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_ending_undo" href="#ida_idp.IDP_Hooks.ev_ending_undo">ev_ending_undo</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_equal_reglocs" href="#ida_idp.IDP_Hooks.ev_equal_reglocs">ev_equal_reglocs</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_extract_address" href="#ida_idp.IDP_Hooks.ev_extract_address">ev_extract_address</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_find_op_value" href="#ida_idp.IDP_Hooks.ev_find_op_value">ev_find_op_value</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_find_reg_value" href="#ida_idp.IDP_Hooks.ev_find_reg_value">ev_find_reg_value</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_func_bounds" href="#ida_idp.IDP_Hooks.ev_func_bounds">ev_func_bounds</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_gen_asm_or_lst" href="#ida_idp.IDP_Hooks.ev_gen_asm_or_lst">ev_gen_asm_or_lst</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_gen_map_file" href="#ida_idp.IDP_Hooks.ev_gen_map_file">ev_gen_map_file</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_gen_regvar_def" href="#ida_idp.IDP_Hooks.ev_gen_regvar_def">ev_gen_regvar_def</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_gen_src_file_lnnum" href="#ida_idp.IDP_Hooks.ev_gen_src_file_lnnum">ev_gen_src_file_lnnum</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_gen_stkvar_def" href="#ida_idp.IDP_Hooks.ev_gen_stkvar_def">ev_gen_stkvar_def</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_get_abi_info" href="#ida_idp.IDP_Hooks.ev_get_abi_info">ev_get_abi_info</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_get_autocmt" href="#ida_idp.IDP_Hooks.ev_get_autocmt">ev_get_autocmt</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_get_bg_color" href="#ida_idp.IDP_Hooks.ev_get_bg_color">ev_get_bg_color</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_get_cc_regs" href="#ida_idp.IDP_Hooks.ev_get_cc_regs">ev_get_cc_regs</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_get_code16_mode" href="#ida_idp.IDP_Hooks.ev_get_code16_mode">ev_get_code16_mode</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_get_dbr_opnum" href="#ida_idp.IDP_Hooks.ev_get_dbr_opnum">ev_get_dbr_opnum</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_get_default_enum_size" href="#ida_idp.IDP_Hooks.ev_get_default_enum_size">ev_get_default_enum_size</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_get_frame_retsize" href="#ida_idp.IDP_Hooks.ev_get_frame_retsize">ev_get_frame_retsize</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_get_macro_insn_head" href="#ida_idp.IDP_Hooks.ev_get_macro_insn_head">ev_get_macro_insn_head</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_get_operand_string" href="#ida_idp.IDP_Hooks.ev_get_operand_string">ev_get_operand_string</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_get_procmod" href="#ida_idp.IDP_Hooks.ev_get_procmod">ev_get_procmod</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_get_reg_accesses" href="#ida_idp.IDP_Hooks.ev_get_reg_accesses">ev_get_reg_accesses</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_get_reg_info" href="#ida_idp.IDP_Hooks.ev_get_reg_info">ev_get_reg_info</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_get_reg_name" href="#ida_idp.IDP_Hooks.ev_get_reg_name">ev_get_reg_name</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_get_simd_types" href="#ida_idp.IDP_Hooks.ev_get_simd_types">ev_get_simd_types</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_get_stkarg_offset" href="#ida_idp.IDP_Hooks.ev_get_stkarg_offset">ev_get_stkarg_offset</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_get_stkvar_scale_factor" href="#ida_idp.IDP_Hooks.ev_get_stkvar_scale_factor">ev_get_stkvar_scale_factor</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_getreg" href="#ida_idp.IDP_Hooks.ev_getreg">ev_getreg</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_init" href="#ida_idp.IDP_Hooks.ev_init">ev_init</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_insn_reads_tbit" href="#ida_idp.IDP_Hooks.ev_insn_reads_tbit">ev_insn_reads_tbit</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_is_align_insn" href="#ida_idp.IDP_Hooks.ev_is_align_insn">ev_is_align_insn</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_is_alloca_probe" href="#ida_idp.IDP_Hooks.ev_is_alloca_probe">ev_is_alloca_probe</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_is_basic_block_end" href="#ida_idp.IDP_Hooks.ev_is_basic_block_end">ev_is_basic_block_end</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_is_call_insn" href="#ida_idp.IDP_Hooks.ev_is_call_insn">ev_is_call_insn</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_is_cond_insn" href="#ida_idp.IDP_Hooks.ev_is_cond_insn">ev_is_cond_insn</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_is_control_flow_guard" href="#ida_idp.IDP_Hooks.ev_is_control_flow_guard">ev_is_control_flow_guard</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_is_far_jump" href="#ida_idp.IDP_Hooks.ev_is_far_jump">ev_is_far_jump</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_is_indirect_jump" href="#ida_idp.IDP_Hooks.ev_is_indirect_jump">ev_is_indirect_jump</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_is_insn_table_jump" href="#ida_idp.IDP_Hooks.ev_is_insn_table_jump">ev_is_insn_table_jump</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_is_jump_func" href="#ida_idp.IDP_Hooks.ev_is_jump_func">ev_is_jump_func</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_is_ret_insn" href="#ida_idp.IDP_Hooks.ev_is_ret_insn">ev_is_ret_insn</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_is_sane_insn" href="#ida_idp.IDP_Hooks.ev_is_sane_insn">ev_is_sane_insn</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_is_sp_based" href="#ida_idp.IDP_Hooks.ev_is_sp_based">ev_is_sp_based</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_is_switch" href="#ida_idp.IDP_Hooks.ev_is_switch">ev_is_switch</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_last_cb_before_loader" href="#ida_idp.IDP_Hooks.ev_last_cb_before_loader">ev_last_cb_before_loader</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_loader" href="#ida_idp.IDP_Hooks.ev_loader">ev_loader</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_lower_func_type" href="#ida_idp.IDP_Hooks.ev_lower_func_type">ev_lower_func_type</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_max_ptr_size" href="#ida_idp.IDP_Hooks.ev_max_ptr_size">ev_max_ptr_size</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_may_be_func" href="#ida_idp.IDP_Hooks.ev_may_be_func">ev_may_be_func</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_may_show_sreg" href="#ida_idp.IDP_Hooks.ev_may_show_sreg">ev_may_show_sreg</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_moving_segm" href="#ida_idp.IDP_Hooks.ev_moving_segm">ev_moving_segm</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_newasm" href="#ida_idp.IDP_Hooks.ev_newasm">ev_newasm</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_newbinary" href="#ida_idp.IDP_Hooks.ev_newbinary">ev_newbinary</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_newfile" href="#ida_idp.IDP_Hooks.ev_newfile">ev_newfile</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_newprc" href="#ida_idp.IDP_Hooks.ev_newprc">ev_newprc</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_next_exec_insn" href="#ida_idp.IDP_Hooks.ev_next_exec_insn">ev_next_exec_insn</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_oldfile" href="#ida_idp.IDP_Hooks.ev_oldfile">ev_oldfile</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_out_assumes" href="#ida_idp.IDP_Hooks.ev_out_assumes">ev_out_assumes</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_out_data" href="#ida_idp.IDP_Hooks.ev_out_data">ev_out_data</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_out_footer" href="#ida_idp.IDP_Hooks.ev_out_footer">ev_out_footer</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_out_header" href="#ida_idp.IDP_Hooks.ev_out_header">ev_out_header</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_out_insn" href="#ida_idp.IDP_Hooks.ev_out_insn">ev_out_insn</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_out_label" href="#ida_idp.IDP_Hooks.ev_out_label">ev_out_label</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_out_mnem" href="#ida_idp.IDP_Hooks.ev_out_mnem">ev_out_mnem</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_out_operand" href="#ida_idp.IDP_Hooks.ev_out_operand">ev_out_operand</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_out_segend" href="#ida_idp.IDP_Hooks.ev_out_segend">ev_out_segend</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_out_segstart" href="#ida_idp.IDP_Hooks.ev_out_segstart">ev_out_segstart</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_out_special_item" href="#ida_idp.IDP_Hooks.ev_out_special_item">ev_out_special_item</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_realcvt" href="#ida_idp.IDP_Hooks.ev_realcvt">ev_realcvt</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_rename" href="#ida_idp.IDP_Hooks.ev_rename">ev_rename</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_replaying_undo" href="#ida_idp.IDP_Hooks.ev_replaying_undo">ev_replaying_undo</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_set_code16_mode" href="#ida_idp.IDP_Hooks.ev_set_code16_mode">ev_set_code16_mode</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_set_idp_options" href="#ida_idp.IDP_Hooks.ev_set_idp_options">ev_set_idp_options</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_set_proc_options" href="#ida_idp.IDP_Hooks.ev_set_proc_options">ev_set_proc_options</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_setup_til" href="#ida_idp.IDP_Hooks.ev_setup_til">ev_setup_til</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_shadow_args_size" href="#ida_idp.IDP_Hooks.ev_shadow_args_size">ev_shadow_args_size</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_str2reg" href="#ida_idp.IDP_Hooks.ev_str2reg">ev_str2reg</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_term" href="#ida_idp.IDP_Hooks.ev_term">ev_term</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_treat_hindering_item" href="#ida_idp.IDP_Hooks.ev_treat_hindering_item">ev_treat_hindering_item</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_undefine" href="#ida_idp.IDP_Hooks.ev_undefine">ev_undefine</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_update_call_stack" href="#ida_idp.IDP_Hooks.ev_update_call_stack">ev_update_call_stack</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_use_arg_types" href="#ida_idp.IDP_Hooks.ev_use_arg_types">ev_use_arg_types</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_use_regarg_type" href="#ida_idp.IDP_Hooks.ev_use_regarg_type">ev_use_regarg_type</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_use_stkarg_type" href="#ida_idp.IDP_Hooks.ev_use_stkarg_type">ev_use_stkarg_type</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_validate_flirt_func" href="#ida_idp.IDP_Hooks.ev_validate_flirt_func">ev_validate_flirt_func</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_verify_noreturn" href="#ida_idp.IDP_Hooks.ev_verify_noreturn">ev_verify_noreturn</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.ev_verify_sp" href="#ida_idp.IDP_Hooks.ev_verify_sp">ev_verify_sp</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.hook" href="#ida_idp.IDP_Hooks.hook">hook</a></code></li>
<li><code><a title="ida_idp.IDP_Hooks.unhook" href="#ida_idp.IDP_Hooks.unhook">unhook</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="ida_idp.reg_access_t"><code class="flex name class">
<span>class <span class="ident">reg_access_t</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ reg_access_t class.</div>
<div class="epy_par">
<strong class="epy_sig">__init__(self) -&gt; reg_access_t</strong></div></div>
<h3>Instance variables</h3>
<dl>
<dt id="ida_idp.reg_access_t.access_type"><code class="name">var <span class="ident">access_type</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">reg_access_t_access_type_get(self) -&gt; access_type_t</strong></div></div>
</dd>
<dt id="ida_idp.reg_access_t.opnum"><code class="name">var <span class="ident">opnum</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">reg_access_t_opnum_get(self) -&gt; uchar</strong></div></div>
</dd>
<dt id="ida_idp.reg_access_t.range"><code class="name">var <span class="ident">range</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">reg_access_t_range_get(self) -&gt; bitrange_t</strong></div></div>
</dd>
<dt id="ida_idp.reg_access_t.regnum"><code class="name">var <span class="ident">regnum</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">reg_access_t_regnum_get(self) -&gt; int</strong></div></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ida_idp.reg_access_t.have_common_bits"><code class="name flex">
<span>def <span class="ident">have_common_bits</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">have_common_bits(self, r) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">r</strong> (C++: const
reg_access_t
&amp;)</div>
</div></div>
</dd>
</dl>
</dd>
<dt id="ida_idp.reg_access_vec_t"><code class="flex name class">
<span>class <span class="ident">reg_access_vec_t</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ qvector&lt; reg_access_t &gt; class.</div>
<div class="epy_par">
<strong class="epy_sig">__init__(self) -&gt; reg_access_vec_t</strong><div class="epy_nested">
x: qvector&lt; reg_access_t &gt; const &amp;</div>
</div></div>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="ida_idp.reg_accesses_t" href="#ida_idp.reg_accesses_t">reg_accesses_t</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="ida_idp.reg_access_vec_t.add_unique"><code class="name flex">
<span>def <span class="ident">add_unique</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">add_unique(self, x) -&gt; bool</strong><div class="epy_nested">
x: reg_access_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_idp.reg_access_vec_t.at"><code class="name flex">
<span>def <span class="ident">at</span></span>(<span>self, *args) &#8209;&gt;&#160;<a title="ida_idp.reg_access_t" href="#ida_idp.reg_access_t">reg_access_t</a>&#160;const&#160;&amp;</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">at(self, _idx) -&gt; reg_access_t</strong><div class="epy_nested">
_idx: size_t</div>
</div></div>
</dd>
<dt id="ida_idp.reg_access_vec_t.back"><code class="name flex">
<span>def <span class="ident">back</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"/>
</dd>
<dt id="ida_idp.reg_access_vec_t.begin"><code class="name flex">
<span>def <span class="ident">begin</span></span>(<span>self, *args) &#8209;&gt;&#160;qvectorreg_access_t&#160;&gt;::const_iterator</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">begin(self) -&gt; reg_access_t</strong></div>
<div class="epy_par">
<strong class="epy_sig">begin(self) -&gt; reg_access_t</strong></div></div>
</dd>
<dt id="ida_idp.reg_access_vec_t.capacity"><code class="name flex">
<span>def <span class="ident">capacity</span></span>(<span>self, *args) &#8209;&gt;&#160;size_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">capacity(self) -&gt; size_t</strong></div></div>
</dd>
<dt id="ida_idp.reg_access_vec_t.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">clear(self)</strong></div></div>
</dd>
<dt id="ida_idp.reg_access_vec_t.empty"><code class="name flex">
<span>def <span class="ident">empty</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">empty(self) -&gt; bool</strong></div></div>
</dd>
<dt id="ida_idp.reg_access_vec_t.end"><code class="name flex">
<span>def <span class="ident">end</span></span>(<span>self, *args) &#8209;&gt;&#160;qvectorreg_access_t&#160;&gt;::const_iterator</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">end(self) -&gt; reg_access_t</strong></div>
<div class="epy_par">
<strong class="epy_sig">end(self) -&gt; reg_access_t</strong></div></div>
</dd>
<dt id="ida_idp.reg_access_vec_t.erase"><code class="name flex">
<span>def <span class="ident">erase</span></span>(<span>self, *args) &#8209;&gt;&#160;qvectorreg_access_t&#160;&gt;::iterator</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">erase(self, it) -&gt; reg_access_t</strong><div class="epy_nested">
it: qvector&lt; reg_access_t &gt;::iterator</div>
</div>
<div class="epy_par">
<strong class="epy_sig">erase(self, first, last) -&gt; reg_access_t</strong><div class="epy_nested">
first: qvector&lt; reg_access_t &gt;::iterator
last: qvector&lt; reg_access_t &gt;::iterator</div>
</div></div>
</dd>
<dt id="ida_idp.reg_access_vec_t.extract"><code class="name flex">
<span>def <span class="ident">extract</span></span>(<span>self, *args) &#8209;&gt;&#160;<a title="ida_idp.reg_access_t" href="#ida_idp.reg_access_t">reg_access_t</a>&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">extract(self) -&gt; reg_access_t</strong></div></div>
</dd>
<dt id="ida_idp.reg_access_vec_t.find"><code class="name flex">
<span>def <span class="ident">find</span></span>(<span>self, *args) &#8209;&gt;&#160;qvectorreg_access_t&#160;&gt;::const_iterator</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">find(self, x) -&gt; reg_access_t</strong><div class="epy_nested">
x: reg_access_t const &amp;</div>
</div>
<div class="epy_par">
<strong class="epy_sig">find(self, x) -&gt; reg_access_t</strong><div class="epy_nested">
x: reg_access_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_idp.reg_access_vec_t.front"><code class="name flex">
<span>def <span class="ident">front</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"/>
</dd>
<dt id="ida_idp.reg_access_vec_t.grow"><code class="name flex">
<span>def <span class="ident">grow</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
grow(self, x=reg_access_t())<div class="epy_nested">
x: reg_access_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_idp.reg_access_vec_t.has"><code class="name flex">
<span>def <span class="ident">has</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">has(self, x) -&gt; bool</strong><div class="epy_nested">
x: reg_access_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_idp.reg_access_vec_t.inject"><code class="name flex">
<span>def <span class="ident">inject</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">inject(self, s, len)</strong><div class="epy_nested">
s: reg_access_t *
len: size_t</div>
</div></div>
</dd>
<dt id="ida_idp.reg_access_vec_t.insert"><code class="name flex">
<span>def <span class="ident">insert</span></span>(<span>self, *args) &#8209;&gt;&#160;qvectorreg_access_t&#160;&gt;::iterator</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">insert(self, it, x) -&gt; reg_access_t</strong><div class="epy_nested">
it: qvector&lt; reg_access_t &gt;::iterator
x: reg_access_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_idp.reg_access_vec_t.pop_back"><code class="name flex">
<span>def <span class="ident">pop_back</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">pop_back(self)</strong></div></div>
</dd>
<dt id="ida_idp.reg_access_vec_t.push_back"><code class="name flex">
<span>def <span class="ident">push_back</span></span>(<span>self, *args) &#8209;&gt;&#160;<a title="ida_idp.reg_access_t" href="#ida_idp.reg_access_t">reg_access_t</a>&#160;&amp;</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">push_back(self, x)</strong><div class="epy_nested">
x: reg_access_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_idp.reg_access_vec_t.qclear"><code class="name flex">
<span>def <span class="ident">qclear</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">qclear(self)</strong></div></div>
</dd>
<dt id="ida_idp.reg_access_vec_t.reserve"><code class="name flex">
<span>def <span class="ident">reserve</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">reserve(self, cnt)</strong><div class="epy_nested">
cnt: size_t</div>
</div></div>
</dd>
<dt id="ida_idp.reg_access_vec_t.resize"><code class="name flex">
<span>def <span class="ident">resize</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">resize(self, _newsize, x)</strong><div class="epy_nested">
_newsize: size_t
x: reg_access_t const &amp;</div>
</div>
<div class="epy_par">
<strong class="epy_sig">resize(self, _newsize)</strong><div class="epy_nested">
_newsize: size_t</div>
</div></div>
</dd>
<dt id="ida_idp.reg_access_vec_t.size"><code class="name flex">
<span>def <span class="ident">size</span></span>(<span>self, *args) &#8209;&gt;&#160;size_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">size(self) -&gt; size_t</strong></div></div>
</dd>
<dt id="ida_idp.reg_access_vec_t.swap"><code class="name flex">
<span>def <span class="ident">swap</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">swap(self, r)</strong><div class="epy_nested">
r: qvector&lt; reg_access_t &gt; &amp;</div>
</div></div>
</dd>
<dt id="ida_idp.reg_access_vec_t.truncate"><code class="name flex">
<span>def <span class="ident">truncate</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">truncate(self)</strong></div></div>
</dd>
</dl>
</dd>
<dt id="ida_idp.reg_accesses_t"><code class="flex name class">
<span>class <span class="ident">reg_accesses_t</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ reg_accesses_t class.</div>
<div class="epy_par">
<strong class="epy_sig">__init__(self) -&gt; reg_accesses_t</strong></div></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="ida_idp.reg_access_vec_t" href="#ida_idp.reg_access_vec_t">reg_access_vec_t</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="ida_idp.reg_access_vec_t" href="#ida_idp.reg_access_vec_t">reg_access_vec_t</a></b></code>:
<ul class="hlist">
<li><code><a title="ida_idp.reg_access_vec_t.add_unique" href="#ida_idp.reg_access_vec_t.add_unique">add_unique</a></code></li>
<li><code><a title="ida_idp.reg_access_vec_t.at" href="#ida_idp.reg_access_vec_t.at">at</a></code></li>
<li><code><a title="ida_idp.reg_access_vec_t.begin" href="#ida_idp.reg_access_vec_t.begin">begin</a></code></li>
<li><code><a title="ida_idp.reg_access_vec_t.capacity" href="#ida_idp.reg_access_vec_t.capacity">capacity</a></code></li>
<li><code><a title="ida_idp.reg_access_vec_t.clear" href="#ida_idp.reg_access_vec_t.clear">clear</a></code></li>
<li><code><a title="ida_idp.reg_access_vec_t.empty" href="#ida_idp.reg_access_vec_t.empty">empty</a></code></li>
<li><code><a title="ida_idp.reg_access_vec_t.end" href="#ida_idp.reg_access_vec_t.end">end</a></code></li>
<li><code><a title="ida_idp.reg_access_vec_t.erase" href="#ida_idp.reg_access_vec_t.erase">erase</a></code></li>
<li><code><a title="ida_idp.reg_access_vec_t.extract" href="#ida_idp.reg_access_vec_t.extract">extract</a></code></li>
<li><code><a title="ida_idp.reg_access_vec_t.find" href="#ida_idp.reg_access_vec_t.find">find</a></code></li>
<li><code><a title="ida_idp.reg_access_vec_t.grow" href="#ida_idp.reg_access_vec_t.grow">grow</a></code></li>
<li><code><a title="ida_idp.reg_access_vec_t.has" href="#ida_idp.reg_access_vec_t.has">has</a></code></li>
<li><code><a title="ida_idp.reg_access_vec_t.inject" href="#ida_idp.reg_access_vec_t.inject">inject</a></code></li>
<li><code><a title="ida_idp.reg_access_vec_t.insert" href="#ida_idp.reg_access_vec_t.insert">insert</a></code></li>
<li><code><a title="ida_idp.reg_access_vec_t.pop_back" href="#ida_idp.reg_access_vec_t.pop_back">pop_back</a></code></li>
<li><code><a title="ida_idp.reg_access_vec_t.push_back" href="#ida_idp.reg_access_vec_t.push_back">push_back</a></code></li>
<li><code><a title="ida_idp.reg_access_vec_t.qclear" href="#ida_idp.reg_access_vec_t.qclear">qclear</a></code></li>
<li><code><a title="ida_idp.reg_access_vec_t.reserve" href="#ida_idp.reg_access_vec_t.reserve">reserve</a></code></li>
<li><code><a title="ida_idp.reg_access_vec_t.resize" href="#ida_idp.reg_access_vec_t.resize">resize</a></code></li>
<li><code><a title="ida_idp.reg_access_vec_t.size" href="#ida_idp.reg_access_vec_t.size">size</a></code></li>
<li><code><a title="ida_idp.reg_access_vec_t.swap" href="#ida_idp.reg_access_vec_t.swap">swap</a></code></li>
<li><code><a title="ida_idp.reg_access_vec_t.truncate" href="#ida_idp.reg_access_vec_t.truncate">truncate</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="ida_idp.reg_info_t"><code class="flex name class">
<span>class <span class="ident">reg_info_t</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ reg_info_t class.</div>
<div class="epy_par">
<strong class="epy_sig">__init__(self) -&gt; reg_info_t</strong></div></div>
<h3>Instance variables</h3>
<dl>
<dt id="ida_idp.reg_info_t.reg"><code class="name">var <span class="ident">reg</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">reg_info_t_reg_get(self) -&gt; int</strong></div></div>
</dd>
<dt id="ida_idp.reg_info_t.size"><code class="name">var <span class="ident">size</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">reg_info_t_size_get(self) -&gt; int</strong></div></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ida_idp.reg_info_t.compare"><code class="name flex">
<span>def <span class="ident">compare</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">compare(self, r) -&gt; int</strong><div class="epy_nested">
r: reg_info_t const &amp;</div>
</div></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
</main>
<footer id="footer">
<p>Copyright (c) 2021 Hex-Rays SA. <a href="/terms_of_use.shtml">Terms of use</a> and <a href="/privacy_policy.shtml">privacy policy</a>.</p>
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> ???</a>.</p>
</footer>
</body>
</html>