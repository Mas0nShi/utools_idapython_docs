<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1"/>
<meta name="generator" content="pdoc ???"/>
<title>ida_loader API documentation</title>
<meta name="description" content="IDA Plugin SDK API wrapper: loader"/>
<link rel="preload stylesheet" as="style" href="assets/sanitize.min.css"/>
<link rel="preload stylesheet" as="style" href="assets/typography.min.css"/>
<link rel="stylesheet preload" as="style" href="assets/github.min.css"/>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar &amp;gt; *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl &amp;gt; dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:-webkit-fill-available}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name &amp;gt; span:first-child{white-space:nowrap}.name.class &amp;gt; span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary &amp;gt; *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content: ',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width: 700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content padding:3em 4em;border-left:1px solid #ddd;lid #ddd;}pre code{font-size:1em}.item .name{font-size:1em}main{/* display:flex; *//* flex-direction:row-reverse; *//* justify-content:flex-end; */}.toc ul ul,#index ul{padding-left:1.5em}.toc &gt; ul &gt; li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer="defer" src="assets/highlight.min.js"/>
<script>window.addEventListener('DOMContentLoaded', () =&gt; hljs.initHighlighting())</script>
<style>
#section-intro .epy_par
{
margin-top: 18px;
}
</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ida_loader</code></h1>
</header>
<section id="section-intro">
<div class="epy_par">
IDA Plugin SDK API wrapper: loader</div>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="ida_loader.ACCEPT_ARCHIVE"><code class="name">var <span class="ident">ACCEPT_ARCHIVE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Specify that a file format is served by archive loader See
'loader_t::accept_file'</div></div>
</dd>
<dt id="ida_loader.ACCEPT_CONTINUE"><code class="name">var <span class="ident">ACCEPT_CONTINUE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Specify that the function must be called another time See
'loader_t::accept_file'</div></div>
</dd>
<dt id="ida_loader.ACCEPT_FIRST"><code class="name">var <span class="ident">ACCEPT_FIRST</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Specify that a file format should be place first in "load file" dialog
box. See 'loader_t::accept_file'</div></div>
</dd>
<dt id="ida_loader.DBFL_BAK"><code class="name">var <span class="ident">DBFL_BAK</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
create backup file (if !DBFL_KILL)</div></div>
</dd>
<dt id="ida_loader.DBFL_COMP"><code class="name">var <span class="ident">DBFL_COMP</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
collect garbage</div></div>
</dd>
<dt id="ida_loader.DBFL_KILL"><code class="name">var <span class="ident">DBFL_KILL</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
delete unpacked database</div></div>
</dd>
<dt id="ida_loader.DBFL_TEMP"><code class="name">var <span class="ident">DBFL_TEMP</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
temporary database</div></div>
</dd>
<dt id="ida_loader.DLLEXT"><code class="name">var <span class="ident">DLLEXT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
DLLEXT = 'so'</div></div>
</dd>
<dt id="ida_loader.FILEREG_NOTPATCHABLE"><code class="name">var <span class="ident">FILEREG_NOTPATCHABLE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
the data is kept in some encoded form in the file.</div></div>
</dd>
<dt id="ida_loader.FILEREG_PATCHABLE"><code class="name">var <span class="ident">FILEREG_PATCHABLE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
means that the input file may be patched (i.e. no compression, no
iterated data, etc)</div></div>
</dd>
<dt id="ida_loader.GENFLG_ASMINC"><code class="name">var <span class="ident">GENFLG_ASMINC</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
'OFILE_ASM' , 'OFILE_LST' : gen information only about types</div></div>
</dd>
<dt id="ida_loader.GENFLG_ASMTYPE"><code class="name">var <span class="ident">GENFLG_ASMTYPE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
'OFILE_ASM' , 'OFILE_LST' : gen information about types too</div></div>
</dd>
<dt id="ida_loader.GENFLG_GENHTML"><code class="name">var <span class="ident">GENFLG_GENHTML</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
'OFILE_ASM' , 'OFILE_LST' : generate html ( 'ui_genfile_callback'
will be used)</div></div>
</dd>
<dt id="ida_loader.GENFLG_IDCTYPE"><code class="name">var <span class="ident">GENFLG_IDCTYPE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
'OFILE_IDC' : gen only information about types</div></div>
</dd>
<dt id="ida_loader.GENFLG_MAPDMNG"><code class="name">var <span class="ident">GENFLG_MAPDMNG</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
'OFILE_MAP' : demangle names</div></div>
</dd>
<dt id="ida_loader.GENFLG_MAPLOC"><code class="name">var <span class="ident">GENFLG_MAPLOC</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
'OFILE_MAP' : include local names</div></div>
</dd>
<dt id="ida_loader.GENFLG_MAPNAME"><code class="name">var <span class="ident">GENFLG_MAPNAME</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
'OFILE_MAP' : include dummy names</div></div>
</dd>
<dt id="ida_loader.GENFLG_MAPSEG"><code class="name">var <span class="ident">GENFLG_MAPSEG</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
'OFILE_MAP' : generate map of segments</div></div>
</dd>
<dt id="ida_loader.IDP_DLL"><code class="name">var <span class="ident">IDP_DLL</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
IDP_DLL = '*.so'</div></div>
</dd>
<dt id="ida_loader.LDRF_RELOAD"><code class="name">var <span class="ident">LDRF_RELOAD</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
loader recognizes 'NEF_RELOAD' flag</div></div>
</dd>
<dt id="ida_loader.LDRF_REQ_PROC"><code class="name">var <span class="ident">LDRF_REQ_PROC</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Requires a processor to be set. if this bit is not set, load_file()
must call set_processor_type(..., SETPROC_LOADER)</div></div>
</dd>
<dt id="ida_loader.LOADER_DLL"><code class="name">var <span class="ident">LOADER_DLL</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
LOADER_DLL = '*.so'</div></div>
</dd>
<dt id="ida_loader.MAX_DATABASE_DESCRIPTION"><code class="name">var <span class="ident">MAX_DATABASE_DESCRIPTION</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Maximum database snapshot description length.</div></div>
</dd>
<dt id="ida_loader.MODULE_ENTRY_IDP"><code class="name">var <span class="ident">MODULE_ENTRY_IDP</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
MODULE_ENTRY_IDP = 'LPH'</div></div>
</dd>
<dt id="ida_loader.MODULE_ENTRY_LOADER"><code class="name">var <span class="ident">MODULE_ENTRY_LOADER</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
MODULE_ENTRY_LOADER = 'LDSC'</div></div>
</dd>
<dt id="ida_loader.MODULE_ENTRY_PLUGIN"><code class="name">var <span class="ident">MODULE_ENTRY_PLUGIN</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
MODULE_ENTRY_PLUGIN = 'PLUGIN'</div></div>
</dd>
<dt id="ida_loader.NEF_CODE"><code class="name">var <span class="ident">NEF_CODE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
for 'load_binary_file()' : load as a code segment</div></div>
</dd>
<dt id="ida_loader.NEF_FILL"><code class="name">var <span class="ident">NEF_FILL</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Fill segment gaps.</div></div>
</dd>
<dt id="ida_loader.NEF_FIRST"><code class="name">var <span class="ident">NEF_FIRST</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
This is the first file loaded into the database.</div></div>
</dd>
<dt id="ida_loader.NEF_FLAT"><code class="name">var <span class="ident">NEF_FLAT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Autocreate FLAT group (PE)</div></div>
</dd>
<dt id="ida_loader.NEF_IMPS"><code class="name">var <span class="ident">NEF_IMPS</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Create import segment.</div></div>
</dd>
<dt id="ida_loader.NEF_LALL"><code class="name">var <span class="ident">NEF_LALL</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Load all segments without questions.</div></div>
</dd>
<dt id="ida_loader.NEF_LOPT"><code class="name">var <span class="ident">NEF_LOPT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Display additional loader options dialog.</div></div>
</dd>
<dt id="ida_loader.NEF_MAN"><code class="name">var <span class="ident">NEF_MAN</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Manual load.</div></div>
</dd>
<dt id="ida_loader.NEF_MINI"><code class="name">var <span class="ident">NEF_MINI</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Create mini database (do not copy segment bytes from the input file;
use only the file header metadata)</div></div>
</dd>
<dt id="ida_loader.NEF_NAME"><code class="name">var <span class="ident">NEF_NAME</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Rename entries.</div></div>
</dd>
<dt id="ida_loader.NEF_RELOAD"><code class="name">var <span class="ident">NEF_RELOAD</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
reload the file at the same place:don't create segmentsdon't create
fixup infodon't import segmentsetc load only the bytes into the base.
a loader should have 'LDRF_RELOAD' bit set</div></div>
</dd>
<dt id="ida_loader.NEF_RSCS"><code class="name">var <span class="ident">NEF_RSCS</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Load resources.</div></div>
</dd>
<dt id="ida_loader.NEF_SEGS"><code class="name">var <span class="ident">NEF_SEGS</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Create segments.</div></div>
</dd>
<dt id="ida_loader.OFILE_ASM"><code class="name">var <span class="ident">OFILE_ASM</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
OFILE_ASM = 4</div></div>
</dd>
<dt id="ida_loader.OFILE_DIF"><code class="name">var <span class="ident">OFILE_DIF</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
OFILE_DIF = 5</div></div>
</dd>
<dt id="ida_loader.OFILE_EXE"><code class="name">var <span class="ident">OFILE_EXE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
OFILE_EXE = 1</div></div>
</dd>
<dt id="ida_loader.OFILE_IDC"><code class="name">var <span class="ident">OFILE_IDC</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
OFILE_IDC = 2</div></div>
</dd>
<dt id="ida_loader.OFILE_LST"><code class="name">var <span class="ident">OFILE_LST</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
OFILE_LST = 3</div></div>
</dd>
<dt id="ida_loader.OFILE_MAP"><code class="name">var <span class="ident">OFILE_MAP</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
OFILE_MAP = 0</div></div>
</dd>
<dt id="ida_loader.PATH_TYPE_CMD"><code class="name">var <span class="ident">PATH_TYPE_CMD</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
PATH_TYPE_CMD = 0</div></div>
</dd>
<dt id="ida_loader.PATH_TYPE_ID0"><code class="name">var <span class="ident">PATH_TYPE_ID0</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
PATH_TYPE_ID0 = 2</div></div>
</dd>
<dt id="ida_loader.PATH_TYPE_IDB"><code class="name">var <span class="ident">PATH_TYPE_IDB</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
PATH_TYPE_IDB = 1</div></div>
</dd>
<dt id="ida_loader.PLUGIN_DLL"><code class="name">var <span class="ident">PLUGIN_DLL</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Pattern to find plugin files.</div></div>
</dd>
<dt id="ida_loader.SSF_AUTOMATIC"><code class="name">var <span class="ident">SSF_AUTOMATIC</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
automatic snapshot</div></div>
</dd>
<dt id="ida_loader.SSUF_DESC"><code class="name">var <span class="ident">SSUF_DESC</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Update the description.</div></div>
</dd>
<dt id="ida_loader.SSUF_FLAGS"><code class="name">var <span class="ident">SSUF_FLAGS</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Update the flags.</div></div>
</dd>
<dt id="ida_loader.SSUF_PATH"><code class="name">var <span class="ident">SSUF_PATH</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
Update the path.</div></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="ida_loader.base2file"><code class="name flex">
<span>def <span class="ident">base2file</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Unload database to a binary file. This function works for wide byte
processors too.</div>
<div class="epy_par">
<strong class="epy_sig">base2file(fp, pos, ea1, ea2) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">fp</strong>: pointer to file (C++: FILE *)</div>
<div class="epy_nested">
<strong class="epy_parameter">pos</strong>: position in the file (C++: qoff64_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">ea1</strong>: range of source linear addresses (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">ea2</strong>: range of source linear addresses (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: 1-ok(always), write error leads to immediate exit</div>
</div></div>
</dd>
<dt id="ida_loader.build_snapshot_tree"><code class="name flex">
<span>def <span class="ident">build_snapshot_tree</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Build the snapshot tree.</div>
<div class="epy_par">
<strong class="epy_sig">build_snapshot_tree(root) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">root</strong>: snapshot root that will contain the snapshot tree<div class="epy_nested">
elements. (C++: snapshot_t
*)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: success</div>
</div></div>
</dd>
<dt id="ida_loader.clr_database_flag"><code class="name flex">
<span>def <span class="ident">clr_database_flag</span></span>(<span>*args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">clr_database_flag(dbfl)</strong><div class="epy_nested">
<strong class="epy_parameter">dbfl</strong> (C++: uint32)</div>
</div></div>
</dd>
<dt id="ida_loader.extract_module_from_archive"><code class="name flex">
<span>def <span class="ident">extract_module_from_archive</span></span>(<span>*args) &#8209;&gt;&#160;PyObject&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Extract a module for an archive file. Parse an archive file, show the
list of modules to the user, allow him to select a module, extract the
selected module to a file (if the extract module is an archive, repeat
the process). This function can handle ZIP, AR, AIXAR, OMFLIB files.
The temporary file will be automatically deleted by IDA at the end.</div>
<div class="epy_par">
<strong class="epy_sig">extract_module_from_archive(fname, is_remote=False) -&gt; PyObject *</strong><div class="epy_nested">
fname: char const *</div>
<div class="epy_nested">
<strong class="epy_parameter">is_remote</strong>: is the input file remote? (C++: bool)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: true - ok</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: false - something bad happened (error message has been<div class="epy_nested">
displayed to the user)</div>
</div>
</div></div>
</dd>
<dt id="ida_loader.file2base"><code class="name flex">
<span>def <span class="ident">file2base</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Load portion of file into the database. This function will include
(ea1..ea2) into the addressing space of the program (make it
enabled).The storage type of the specified range will be changed to
STT_VA.</div>
<div class="epy_par">
<strong class="epy_sig">file2base(li, pos, ea1, ea2, patchable) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">li</strong>: pointer of input source (C++: linput_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">pos</strong>: position in the file (C++: qoff64_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">ea1</strong>: range of destination linear addresses (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">ea2</strong>: range of destination linear addresses (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">patchable</strong>: should the kernel remember correspondence of file<div class="epy_nested">
offsets to linear addresses. (C++: int)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 - ok</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - read error, a warning is displayed</div>
</div></div>
</dd>
<dt id="ida_loader.find_plugin"><code class="name flex">
<span>def <span class="ident">find_plugin</span></span>(<span>*args) &#8209;&gt;&#160;plugin_t&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Find a user-defined plugin and optionally load it.</div>
<div class="epy_par">
<strong class="epy_sig">find_plugin(name, load_if_needed=False) -&gt; plugin_t *</strong><div class="epy_nested">
<strong class="epy_parameter">name</strong>: short plugin name without path and extension, or absolute<div class="epy_nested">
path to the file name (C++: const char *)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">load_if_needed</strong>: if the plugin is not present in the memory, try<div class="epy_nested">
to load it (C++: bool)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: pointer to plugin description block</div>
</div></div>
</dd>
<dt id="ida_loader.flush_buffers"><code class="name flex">
<span>def <span class="ident">flush_buffers</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Flush buffers to the disk.</div></div>
</dd>
<dt id="ida_loader.gen_exe_file"><code class="name flex">
<span>def <span class="ident">gen_exe_file</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Generate an exe file (unload the database in binary form).</div>
<div class="epy_par">
<strong class="epy_sig">gen_exe_file(fp) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">fp</strong> (C++: FILE *)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: fp the output file handle. if fp == NULL then return:
1:<div class="epy_nested">
can generate an executable file
0: can't generate an
executable file</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 - ok</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - failed</div>
</div></div>
</dd>
<dt id="ida_loader.gen_file"><code class="name flex">
<span>def <span class="ident">gen_file</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Generate an output file. 'OFILE_EXE' :</div>
<div class="epy_par">
<strong class="epy_sig">gen_file(otype, fp, ea1, ea2, flags) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">otype</strong>: type of output file. (C++: ofile_type_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">fp</strong>: the output file handle (C++: FILE *)</div>
<div class="epy_nested">
<strong class="epy_parameter">ea1</strong>: start address. For some file types this argument is<div class="epy_nested">
ignored (C++: ea_t)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">ea2</strong>: end address. For some file types this argument is ignored<div class="epy_nested">
as usual in ida, the end address of the range is not
included (C++: ea_t)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">flags</strong>: Generate file flags (C++: int)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: number of the generated lines. -1 if an error occurred</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - can't generate exe file</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 - ok</div>
</div></div>
</dd>
<dt id="ida_loader.get_basic_file_type"><code class="name flex">
<span>def <span class="ident">get_basic_file_type</span></span>(<span>*args) &#8209;&gt;&#160;filetype_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get the input file type. This function can recognize libraries and zip
files.</div>
<div class="epy_par">
<strong class="epy_sig">get_basic_file_type(li) -&gt; filetype_t</strong><div class="epy_nested">
<strong class="epy_parameter">li</strong> (C++: linput_t *)</div>
</div></div>
</dd>
<dt id="ida_loader.get_elf_debug_file_directory"><code class="name flex">
<span>def <span class="ident">get_elf_debug_file_directory</span></span>(<span>*args) &#8209;&gt;&#160;char&#160;const&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get the value of the ELF_DEBUG_FILE_DIRECTORY configuration directive.</div></div>
</dd>
<dt id="ida_loader.get_file_type_name"><code class="name flex">
<span>def <span class="ident">get_file_type_name</span></span>(<span>*args) &#8209;&gt;&#160;size_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get name of the current file type. The current file type is kept in</div>
<div class="epy_par">
\inf{filetype}<div class="epy_nested">
.</div>
</div></div>
</dd>
<dt id="ida_loader.get_fileregion_ea"><code class="name flex">
<span>def <span class="ident">get_fileregion_ea</span></span>(<span>*args) &#8209;&gt;&#160;ea_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get linear address which corresponds to the specified input file
offset. If can't be found, return 'BADADDR'</div>
<div class="epy_par">
<strong class="epy_sig">get_fileregion_ea(offset) -&gt; ea_t</strong><div class="epy_nested">
<strong class="epy_parameter">offset</strong> (C++: qoff64_t)</div>
</div></div>
</dd>
<dt id="ida_loader.get_fileregion_offset"><code class="name flex">
<span>def <span class="ident">get_fileregion_offset</span></span>(<span>*args) &#8209;&gt;&#160;qoff64_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get offset in the input file which corresponds to the given ea. If the
specified ea can't be mapped into the input file offset, return -1.</div>
<div class="epy_par">
<strong class="epy_sig">get_fileregion_offset(ea) -&gt; qoff64_t</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
</div></div>
</dd>
<dt id="ida_loader.get_path"><code class="name flex">
<span>def <span class="ident">get_path</span></span>(<span>*args) &#8209;&gt;&#160;char&#160;const&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get the file path</div>
<div class="epy_par">
<strong class="epy_sig">get_path(pt) -&gt; char const *</strong><div class="epy_nested">
<strong class="epy_parameter">pt</strong>: file path type
Types of the file pathes (C++: path_type_t)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: file path, never returns NULL</div>
</div></div>
</dd>
<dt id="ida_loader.get_plugin_options"><code class="name flex">
<span>def <span class="ident">get_plugin_options</span></span>(<span>*args) &#8209;&gt;&#160;char&#160;const&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get plugin options from the command line. If the user has specified
the options in the -Oplugin_name:options format, them this function
will return the 'options' part of it The 'plugin' parameter should
denote the plugin name Returns NULL if there we no options specified</div>
<div class="epy_par">
<strong class="epy_sig">get_plugin_options(plugin) -&gt; char const *</strong><div class="epy_nested">
<strong class="epy_parameter">plugin</strong> (C++: const char *)</div>
</div></div>
</dd>
<dt id="ida_loader.is_database_flag"><code class="name flex">
<span>def <span class="ident">is_database_flag</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get the current database flag</div>
<div class="epy_par">
<strong class="epy_sig">is_database_flag(dbfl) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">dbfl</strong>: flag
Database flags (C++: uint32)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: the state of the flag (set or cleared)</div>
</div></div>
</dd>
<dt id="ida_loader.is_trusted_idb"><code class="name flex">
<span>def <span class="ident">is_trusted_idb</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is the database considered as trusted?</div></div>
</dd>
<dt id="ida_loader.load_and_run_plugin"><code class="name flex">
<span>def <span class="ident">load_and_run_plugin</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Load &amp; run a plugin.</div>
<div class="epy_par">
<strong class="epy_sig">load_and_run_plugin(name, arg) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">name</strong> (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">arg</strong> (C++: size_t)</div>
</div></div>
</dd>
<dt id="ida_loader.load_binary_file"><code class="name flex">
<span>def <span class="ident">load_binary_file</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Load a binary file into the database. This function usually is called
from ui.</div>
<div class="epy_par">
<strong class="epy_sig">load_binary_file(filename, li, _neflags, fileoff, basepara, binoff, nbytes) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">filename</strong>: the name of input file as is (if the input file is<div class="epy_nested">
from library, then this is the name from the library)
(C++: const char *)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">li</strong>: loader input source (C++: linput_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">_neflags</strong>: Load file flags . For the first file, the flag<div class="epy_nested">
NEF_FIRST
must be set. (C++: ushort)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">fileoff</strong>: Offset in the input file (C++: qoff64_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">basepara</strong>: Load address in paragraphs (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">binoff</strong>: Load offset (load_address=(basepara&lt;&lt;4)+binoff) (C++:<div class="epy_nested">
ea_t)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">nbytes</strong>: Number of bytes to load from the file.
0: up to the<div class="epy_nested">
end of the file (C++: uint64)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: true - ok</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: false - failed (couldn't open the file)</div>
</div></div>
</dd>
<dt id="ida_loader.load_ids_module"><code class="name flex">
<span>def <span class="ident">load_ids_module</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Load and apply IDS file. This function loads the specified IDS file
and applies it to the database. If the program imports functions from
a module with the same name as the name of the ids file being loaded,
then only functions from this module will be affected. Otherwise (i.e.
when the program does not import a module with this name) any function
in the program may be affected.</div>
<div class="epy_par">
<strong class="epy_sig">load_ids_module(fname) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">fname</strong>: name of file to apply (C++: char *)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 - ok</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - some error (a message is displayed). if the ids file does<div class="epy_nested">
not exist, no message is displayed</div>
</div>
</div></div>
</dd>
<dt id="ida_loader.load_plugin"><code class="name flex">
<span>def <span class="ident">load_plugin</span></span>(<span>*args) &#8209;&gt;&#160;PyObject&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">load_plugin(name) -&gt; PyObject *</strong><div class="epy_nested">
Loads a plugin</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>:<ul class="epy_ul">
<li class="epy_li"><span class="epy_nested">
None if plugin could not be loaded</span>
</li>
<li class="epy_li"><span class="epy_nested">
An opaque object representing the loaded plugin</span>
</li>
</ul>
</div>
</div></div>
</dd>
<dt id="ida_loader.mem2base"><code class="name flex">
<span>def <span class="ident">mem2base</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">mem2base(py_mem, ea, fpos=-1) -&gt; int</strong><div class="epy_nested">
Load database from the memory.</div>
<div class="epy_nested">
<strong class="epy_parameter">mem</strong>: the buffer</div>
<div class="epy_nested">
<strong class="epy_parameter">ea</strong>: start linear addresses</div>
<div class="epy_nested">
<strong class="epy_parameter">fpos</strong>: position in the input file the data is taken from.<div class="epy_nested">
if == -1, then no file position correspond to the data.</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>:<ul class="epy_ul">
<li class="epy_li"><span class="epy_nested">
Returns zero if the passed buffer was not a string</span>
</li>
<li class="epy_li"><span class="epy_nested">
Otherwise 1 is returned</span>
</li>
</ul>
</div>
</div></div>
</dd>
<dt id="ida_loader.process_archive"><code class="name flex">
<span>def <span class="ident">process_archive</span></span>(<span>*args) &#8209;&gt;&#160;qstring&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Calls 'loader_t::process_archive()' For parameters and return value
description look at 'loader_t::process_archive()' . Additional
parameter:</div>
<div class="epy_par">
<strong class="epy_sig">process_archive(temp_file, li, module_name, neflags, defmember, loader) -&gt; str</strong><div class="epy_nested">
<strong class="epy_parameter">temp_file</strong> (C++: qstring
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">li</strong> (C++: linput_t *)</div>
<div class="epy_nested">
<strong class="epy_parameter">module_name</strong> (C++: qstring
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">neflags</strong> (C++: ushort
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">defmember</strong> (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">loader</strong>: pointer to
load_info_t
structure. (C++: const<div class="epy_nested">
load_info_t
*)</div>
</div>
</div></div>
</dd>
<dt id="ida_loader.reload_file"><code class="name flex">
<span>def <span class="ident">reload_file</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Reload the input file. This function reloads the byte values from the
input file. It doesn't modify the segmentation, names, comments, etc.</div>
<div class="epy_par">
<strong class="epy_sig">reload_file(file, is_remote) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">file</strong>: name of the input file. if file == NULL then returns:<div class="epy_nested">
1: can reload the input file
0: can't reload the input
file (C++: const char *)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">is_remote</strong>: is the file located on a remote computer with the<div class="epy_nested">
debugger server? (C++: bool)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: success</div>
</div></div>
</dd>
<dt id="ida_loader.run_plugin"><code class="name flex">
<span>def <span class="ident">run_plugin</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">run_plugin(plg, arg) -&gt; bool</strong><div class="epy_nested">
Runs a plugin</div>
<div class="epy_nested">
<strong class="epy_parameter">plg</strong>: A plugin object (returned by load_plugin())</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: Boolean</div>
</div></div>
</dd>
<dt id="ida_loader.save_database"><code class="name flex">
<span>def <span class="ident">save_database</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Save current database using a new file name.when both root and attr
are not NULL then the snapshot attributes will be updated, otherwise
the snapshot attributes will be inherited from the current database.</div>
<div class="epy_par">
<strong class="epy_sig">save_database(outfile, flags, root=None, attr=None) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">outfile</strong>: output database file name (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">flags</strong>: Database flags (C++: uint32)</div>
<div class="epy_nested">
<strong class="epy_parameter">root</strong>: optional: snapshot tree root. (C++: const
snapshot_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">attr</strong>: optional: snapshot attributes (C++: const
snapshot_t
*)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: success</div>
</div></div>
</dd>
<dt id="ida_loader.set_database_flag"><code class="name flex">
<span>def <span class="ident">set_database_flag</span></span>(<span>*args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Set or clear database flag</div>
<div class="epy_par">
<strong class="epy_sig">set_database_flag(dbfl, cnd=True)</strong><div class="epy_nested">
<strong class="epy_parameter">dbfl</strong>: flag
Database flags (C++: uint32)</div>
<div class="epy_nested">
<strong class="epy_parameter">cnd</strong>: set if true or clear flag otherwise (C++: bool)</div>
</div></div>
</dd>
<dt id="ida_loader.set_path"><code class="name flex">
<span>def <span class="ident">set_path</span></span>(<span>*args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Set the file path</div>
<div class="epy_par">
<strong class="epy_sig">set_path(pt, path)</strong><div class="epy_nested">
<strong class="epy_parameter">pt</strong>: file path type
Types of the file pathes (C++: path_type_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">path</strong>: new file path, use NULL or empty string to clear the file<div class="epy_nested">
path (C++: const char *)</div>
</div>
</div></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ida_loader.idp_desc_t"><code class="flex name class">
<span>class <span class="ident">idp_desc_t</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ idp_desc_t class.</div>
<div class="epy_par">
<strong class="epy_sig">__init__(self) -&gt; idp_desc_t</strong></div></div>
<h3>Instance variables</h3>
<dl>
<dt id="ida_loader.idp_desc_t.checked"><code class="name">var <span class="ident">checked</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">idp_desc_t_checked_get(self) -&gt; bool</strong></div></div>
</dd>
<dt id="ida_loader.idp_desc_t.family"><code class="name">var <span class="ident">family</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">idp_desc_t_family_get(self) -&gt; qstring *</strong></div></div>
</dd>
<dt id="ida_loader.idp_desc_t.is_script"><code class="name">var <span class="ident">is_script</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">idp_desc_t_is_script_get(self) -&gt; bool</strong></div></div>
</dd>
<dt id="ida_loader.idp_desc_t.mtime"><code class="name">var <span class="ident">mtime</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">idp_desc_t_mtime_get(self) -&gt; time_t</strong></div></div>
</dd>
<dt id="ida_loader.idp_desc_t.names"><code class="name">var <span class="ident">names</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">idp_desc_t_names_get(self) -&gt; idp_names_t *</strong></div></div>
</dd>
<dt id="ida_loader.idp_desc_t.path"><code class="name">var <span class="ident">path</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">idp_desc_t_path_get(self) -&gt; qstring *</strong></div></div>
</dd>
</dl>
</dd>
<dt id="ida_loader.idp_name_t"><code class="flex name class">
<span>class <span class="ident">idp_name_t</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ idp_name_t class.</div>
<div class="epy_par">
<strong class="epy_sig">__init__(self) -&gt; idp_name_t</strong></div></div>
<h3>Instance variables</h3>
<dl>
<dt id="ida_loader.idp_name_t.hidden"><code class="name">var <span class="ident">hidden</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">idp_name_t_hidden_get(self) -&gt; bool</strong></div></div>
</dd>
<dt id="ida_loader.idp_name_t.lname"><code class="name">var <span class="ident">lname</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">idp_name_t_lname_get(self) -&gt; qstring *</strong></div></div>
</dd>
<dt id="ida_loader.idp_name_t.sname"><code class="name">var <span class="ident">sname</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">idp_name_t_sname_get(self) -&gt; qstring *</strong></div></div>
</dd>
</dl>
</dd>
<dt id="ida_loader.loader_t"><code class="flex name class">
<span>class <span class="ident">loader_t</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ loader_t class.</div>
<div class="epy_par">
<strong class="epy_sig">__init__(self) -&gt; loader_t</strong></div></div>
<h3>Instance variables</h3>
<dl>
<dt id="ida_loader.loader_t.flags"><code class="name">var <span class="ident">flags</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">loader_t_flags_get(self) -&gt; uint32</strong></div></div>
</dd>
<dt id="ida_loader.loader_t.version"><code class="name">var <span class="ident">version</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">loader_t_version_get(self) -&gt; uint32</strong></div></div>
</dd>
</dl>
</dd>
<dt id="ida_loader.plugin_info_t"><code class="flex name class">
<span>class <span class="ident">plugin_info_t</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ plugin_info_t class.</div>
<div class="epy_par">
<strong class="epy_sig">__init__(self) -&gt; plugin_info_t</strong></div></div>
<h3>Instance variables</h3>
<dl>
<dt id="ida_loader.plugin_info_t.arg"><code class="name">var <span class="ident">arg</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">plugin_info_t_arg_get(self) -&gt; size_t</strong></div></div>
</dd>
<dt id="ida_loader.plugin_info_t.comment"><code class="name">var <span class="ident">comment</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">plugin_info_t_comment_get(self) -&gt; char *</strong></div></div>
</dd>
<dt id="ida_loader.plugin_info_t.dllmem"><code class="name">var <span class="ident">dllmem</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">plugin_info_t_dllmem_get(self) -&gt; idadll_t *</strong></div></div>
</dd>
<dt id="ida_loader.plugin_info_t.entry"><code class="name">var <span class="ident">entry</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">plugin_info_t_entry_get(self) -&gt; plugin_t *</strong></div></div>
</dd>
<dt id="ida_loader.plugin_info_t.flags"><code class="name">var <span class="ident">flags</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">plugin_info_t_flags_get(self) -&gt; int</strong></div></div>
</dd>
<dt id="ida_loader.plugin_info_t.hotkey"><code class="name">var <span class="ident">hotkey</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">plugin_info_t_hotkey_get(self) -&gt; ushort</strong></div></div>
</dd>
<dt id="ida_loader.plugin_info_t.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">plugin_info_t_name_get(self) -&gt; char *</strong></div></div>
</dd>
<dt id="ida_loader.plugin_info_t.next"><code class="name">var <span class="ident">next</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">plugin_info_t_next_get(self) -&gt; plugin_info_t</strong></div></div>
</dd>
<dt id="ida_loader.plugin_info_t.org_hotkey"><code class="name">var <span class="ident">org_hotkey</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">plugin_info_t_org_hotkey_get(self) -&gt; ushort</strong></div></div>
</dd>
<dt id="ida_loader.plugin_info_t.org_name"><code class="name">var <span class="ident">org_name</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">plugin_info_t_org_name_get(self) -&gt; char *</strong></div></div>
</dd>
<dt id="ida_loader.plugin_info_t.path"><code class="name">var <span class="ident">path</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">plugin_info_t_path_get(self) -&gt; char *</strong></div></div>
</dd>
</dl>
</dd>
<dt id="ida_loader.qvector_snapshotvec_t"><code class="flex name class">
<span>class <span class="ident">qvector_snapshotvec_t</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ qvector&lt; snapshot_t * &gt; class.</div>
<div class="epy_par">
<strong class="epy_sig">__init__(self) -&gt; qvector_snapshotvec_t</strong><div class="epy_nested">
x: qvector&lt; snapshot_t * &gt; const &amp;</div>
</div></div>
<h3>Methods</h3>
<dl>
<dt id="ida_loader.qvector_snapshotvec_t.add_unique"><code class="name flex">
<span>def <span class="ident">add_unique</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">add_unique(self, x) -&gt; bool</strong><div class="epy_nested">
x: snapshot_t *const &amp;</div>
</div></div>
</dd>
<dt id="ida_loader.qvector_snapshotvec_t.at"><code class="name flex">
<span>def <span class="ident">at</span></span>(<span>self, *args) &#8209;&gt;&#160;<a title="ida_loader.snapshot_t" href="#ida_loader.snapshot_t">snapshot_t</a>&#160;*const&#160;&amp;</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">at(self, _idx) -&gt; snapshot_t</strong><div class="epy_nested">
_idx: size_t</div>
</div></div>
</dd>
<dt id="ida_loader.qvector_snapshotvec_t.back"><code class="name flex">
<span>def <span class="ident">back</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"/>
</dd>
<dt id="ida_loader.qvector_snapshotvec_t.begin"><code class="name flex">
<span>def <span class="ident">begin</span></span>(<span>self, *args) &#8209;&gt;&#160;qvectorsnapshot_t&#160;*&#160;&gt;::const_iterator</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">begin(self) -&gt; qvector&lt; snapshot_t * &gt;::iterator</strong></div>
<div class="epy_par">
<strong class="epy_sig">begin(self) -&gt; qvector&lt; snapshot_t * &gt;::const_iterator</strong></div></div>
</dd>
<dt id="ida_loader.qvector_snapshotvec_t.capacity"><code class="name flex">
<span>def <span class="ident">capacity</span></span>(<span>self, *args) &#8209;&gt;&#160;size_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">capacity(self) -&gt; size_t</strong></div></div>
</dd>
<dt id="ida_loader.qvector_snapshotvec_t.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">clear(self)</strong></div></div>
</dd>
<dt id="ida_loader.qvector_snapshotvec_t.empty"><code class="name flex">
<span>def <span class="ident">empty</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">empty(self) -&gt; bool</strong></div></div>
</dd>
<dt id="ida_loader.qvector_snapshotvec_t.end"><code class="name flex">
<span>def <span class="ident">end</span></span>(<span>self, *args) &#8209;&gt;&#160;qvectorsnapshot_t&#160;*&#160;&gt;::const_iterator</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">end(self) -&gt; qvector&lt; snapshot_t * &gt;::iterator</strong></div>
<div class="epy_par">
<strong class="epy_sig">end(self) -&gt; qvector&lt; snapshot_t * &gt;::const_iterator</strong></div></div>
</dd>
<dt id="ida_loader.qvector_snapshotvec_t.erase"><code class="name flex">
<span>def <span class="ident">erase</span></span>(<span>self, *args) &#8209;&gt;&#160;qvectorsnapshot_t&#160;*&#160;&gt;::iterator</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">erase(self, it) -&gt; qvector&lt; snapshot_t * &gt;::iterator</strong><div class="epy_nested">
it: qvector&lt; snapshot_t * &gt;::iterator</div>
</div>
<div class="epy_par">
<strong class="epy_sig">erase(self, first, last) -&gt; qvector&lt; snapshot_t * &gt;::iterator</strong><div class="epy_nested">
first: qvector&lt; snapshot_t * &gt;::iterator
last: qvector&lt; snapshot_t * &gt;::iterator</div>
</div></div>
</dd>
<dt id="ida_loader.qvector_snapshotvec_t.extract"><code class="name flex">
<span>def <span class="ident">extract</span></span>(<span>self, *args) &#8209;&gt;&#160;<a title="ida_loader.snapshot_t" href="#ida_loader.snapshot_t">snapshot_t</a>&#160;**</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">extract(self) -&gt; snapshot_t **</strong></div></div>
</dd>
<dt id="ida_loader.qvector_snapshotvec_t.find"><code class="name flex">
<span>def <span class="ident">find</span></span>(<span>self, *args) &#8209;&gt;&#160;qvectorsnapshot_t&#160;*&#160;&gt;::const_iterator</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">find(self, x) -&gt; qvector&lt; snapshot_t * &gt;::iterator</strong><div class="epy_nested">
x: snapshot_t *const &amp;</div>
</div>
<div class="epy_par">
<strong class="epy_sig">find(self, x) -&gt; qvector&lt; snapshot_t * &gt;::const_iterator</strong><div class="epy_nested">
x: snapshot_t *const &amp;</div>
</div></div>
</dd>
<dt id="ida_loader.qvector_snapshotvec_t.front"><code class="name flex">
<span>def <span class="ident">front</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"/>
</dd>
<dt id="ida_loader.qvector_snapshotvec_t.has"><code class="name flex">
<span>def <span class="ident">has</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">has(self, x) -&gt; bool</strong><div class="epy_nested">
x: snapshot_t *const &amp;</div>
</div></div>
</dd>
<dt id="ida_loader.qvector_snapshotvec_t.inject"><code class="name flex">
<span>def <span class="ident">inject</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">inject(self, s, len)</strong><div class="epy_nested">
s: snapshot_t **
len: size_t</div>
</div></div>
</dd>
<dt id="ida_loader.qvector_snapshotvec_t.insert"><code class="name flex">
<span>def <span class="ident">insert</span></span>(<span>self, *args) &#8209;&gt;&#160;qvectorsnapshot_t&#160;*&#160;&gt;::iterator</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">insert(self, it, x) -&gt; qvector&lt; snapshot_t * &gt;::iterator</strong><div class="epy_nested">
it: qvector&lt; snapshot_t * &gt;::iterator
x: snapshot_t *const &amp;</div>
</div></div>
</dd>
<dt id="ida_loader.qvector_snapshotvec_t.pop_back"><code class="name flex">
<span>def <span class="ident">pop_back</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">pop_back(self)</strong></div></div>
</dd>
<dt id="ida_loader.qvector_snapshotvec_t.push_back"><code class="name flex">
<span>def <span class="ident">push_back</span></span>(<span>self, *args) &#8209;&gt;&#160;<a title="ida_loader.snapshot_t" href="#ida_loader.snapshot_t">snapshot_t</a>&#160;*&amp;</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">push_back(self, x)</strong><div class="epy_nested">
x: snapshot_t *const &amp;</div>
</div></div>
</dd>
<dt id="ida_loader.qvector_snapshotvec_t.qclear"><code class="name flex">
<span>def <span class="ident">qclear</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">qclear(self)</strong></div></div>
</dd>
<dt id="ida_loader.qvector_snapshotvec_t.reserve"><code class="name flex">
<span>def <span class="ident">reserve</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">reserve(self, cnt)</strong><div class="epy_nested">
cnt: size_t</div>
</div></div>
</dd>
<dt id="ida_loader.qvector_snapshotvec_t.resize"><code class="name flex">
<span>def <span class="ident">resize</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">resize(self, _newsize, x)</strong><div class="epy_nested">
_newsize: size_t
x: snapshot_t *const &amp;</div>
</div>
<div class="epy_par">
<strong class="epy_sig">resize(self, _newsize)</strong><div class="epy_nested">
_newsize: size_t</div>
</div></div>
</dd>
<dt id="ida_loader.qvector_snapshotvec_t.size"><code class="name flex">
<span>def <span class="ident">size</span></span>(<span>self, *args) &#8209;&gt;&#160;size_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">size(self) -&gt; size_t</strong></div></div>
</dd>
<dt id="ida_loader.qvector_snapshotvec_t.swap"><code class="name flex">
<span>def <span class="ident">swap</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">swap(self, r)</strong><div class="epy_nested">
r: qvector&lt; snapshot_t * &gt; &amp;</div>
</div></div>
</dd>
<dt id="ida_loader.qvector_snapshotvec_t.truncate"><code class="name flex">
<span>def <span class="ident">truncate</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">truncate(self)</strong></div></div>
</dd>
</dl>
</dd>
<dt id="ida_loader.snapshot_t"><code class="flex name class">
<span>class <span class="ident">snapshot_t</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ snapshot_t class.</div>
<div class="epy_par">
<strong class="epy_sig">__init__(self) -&gt; snapshot_t</strong></div></div>
<h3>Instance variables</h3>
<dl>
<dt id="ida_loader.snapshot_t.children"><code class="name">var <span class="ident">children</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">snapshot_t_children_get(self) -&gt; qvector_snapshotvec_t</strong></div></div>
</dd>
<dt id="ida_loader.snapshot_t.desc"><code class="name">var <span class="ident">desc</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">snapshot_t_desc_get(self) -&gt; char [128]</strong></div></div>
</dd>
<dt id="ida_loader.snapshot_t.filename"><code class="name">var <span class="ident">filename</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">snapshot_t_filename_get(self) -&gt; char [QMAXPATH]</strong></div></div>
</dd>
<dt id="ida_loader.snapshot_t.flags"><code class="name">var <span class="ident">flags</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">snapshot_t_flags_get(self) -&gt; uint16</strong></div></div>
</dd>
<dt id="ida_loader.snapshot_t.id"><code class="name">var <span class="ident">id</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">snapshot_t_id_get(self) -&gt; qtime64_t</strong></div></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ida_loader.snapshot_t.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">clear(self)</strong></div></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
</main>
<footer id="footer">
<p>Copyright (c) 2021 Hex-Rays SA. <a href="/terms_of_use.shtml">Terms of use</a> and <a href="/privacy_policy.shtml">privacy policy</a>.</p>
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> ???</a>.</p>
</footer>
</body>
</html>