<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1"/>
<meta name="generator" content="pdoc ???"/>
<title>ida_ua API documentation</title>
<meta name="description" content="IDA Plugin SDK API wrapper: ua"/>
<link rel="preload stylesheet" as="style" href="assets/sanitize.min.css"/>
<link rel="preload stylesheet" as="style" href="assets/typography.min.css"/>
<link rel="stylesheet preload" as="style" href="assets/github.min.css"/>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar &amp;gt; *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl &amp;gt; dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:-webkit-fill-available}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name &amp;gt; span:first-child{white-space:nowrap}.name.class &amp;gt; span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary &amp;gt; *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content: ',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width: 700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content padding:3em 4em;border-left:1px solid #ddd;lid #ddd;}pre code{font-size:1em}.item .name{font-size:1em}main{/* display:flex; *//* flex-direction:row-reverse; *//* justify-content:flex-end; */}.toc ul ul,#index ul{padding-left:1.5em}.toc &gt; ul &gt; li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer="defer" src="assets/highlight.min.js"/>
<script>window.addEventListener('DOMContentLoaded', () =&gt; hljs.initHighlighting())</script>
<style>
#section-intro .epy_par
{
margin-top: 18px;
}
</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ida_ua</code></h1>
</header>
<section id="section-intro">
<div class="epy_par">
IDA Plugin SDK API wrapper: ua</div>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="ida_ua.BINOPSTATE_DONE"><code class="name">var <span class="ident">BINOPSTATE_DONE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BINOPSTATE_DONE = 524288</div></div>
</dd>
<dt id="ida_ua.BINOPSTATE_GO"><code class="name">var <span class="ident">BINOPSTATE_GO</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BINOPSTATE_GO = 262144</div></div>
</dd>
<dt id="ida_ua.BINOPSTATE_NONE"><code class="name">var <span class="ident">BINOPSTATE_NONE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
BINOPSTATE_NONE = 0</div></div>
</dd>
<dt id="ida_ua.COMMSTATE_DONE"><code class="name">var <span class="ident">COMMSTATE_DONE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
COMMSTATE_DONE = 512</div></div>
</dd>
<dt id="ida_ua.COMMSTATE_GO"><code class="name">var <span class="ident">COMMSTATE_GO</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
COMMSTATE_GO = 256</div></div>
</dd>
<dt id="ida_ua.COMMSTATE_NONE"><code class="name">var <span class="ident">COMMSTATE_NONE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
COMMSTATE_NONE = 0</div></div>
</dd>
<dt id="ida_ua.CTXF_BINOP_STATE"><code class="name">var <span class="ident">CTXF_BINOP_STATE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
CTXF_BINOP_STATE = 786432</div></div>
</dd>
<dt id="ida_ua.CTXF_CMT_STATE"><code class="name">var <span class="ident">CTXF_CMT_STATE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
CTXF_CMT_STATE = 768</div></div>
</dd>
<dt id="ida_ua.CTXF_CODE"><code class="name">var <span class="ident">CTXF_CODE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
CTXF_CODE = 4</div></div>
</dd>
<dt id="ida_ua.CTXF_DBLIND_OPND"><code class="name">var <span class="ident">CTXF_DBLIND_OPND</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
CTXF_DBLIND_OPND = 131072</div></div>
</dd>
<dt id="ida_ua.CTXF_DEMANGLED_LABEL"><code class="name">var <span class="ident">CTXF_DEMANGLED_LABEL</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
CTXF_DEMANGLED_LABEL = 4096</div></div>
</dd>
<dt id="ida_ua.CTXF_DEMANGLED_OK"><code class="name">var <span class="ident">CTXF_DEMANGLED_OK</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
CTXF_DEMANGLED_OK = 16384</div></div>
</dd>
<dt id="ida_ua.CTXF_GEN_CMT"><code class="name">var <span class="ident">CTXF_GEN_CMT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
CTXF_GEN_CMT = 128</div></div>
</dd>
<dt id="ida_ua.CTXF_GEN_XREFS"><code class="name">var <span class="ident">CTXF_GEN_XREFS</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
CTXF_GEN_XREFS = 16</div></div>
</dd>
<dt id="ida_ua.CTXF_LABEL_OK"><code class="name">var <span class="ident">CTXF_LABEL_OK</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
CTXF_LABEL_OK = 8192</div></div>
</dd>
<dt id="ida_ua.CTXF_MAIN"><code class="name">var <span class="ident">CTXF_MAIN</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
CTXF_MAIN = 1</div></div>
</dd>
<dt id="ida_ua.CTXF_MULTI"><code class="name">var <span class="ident">CTXF_MULTI</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
CTXF_MULTI = 2</div></div>
</dd>
<dt id="ida_ua.CTXF_NORMAL_LABEL"><code class="name">var <span class="ident">CTXF_NORMAL_LABEL</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
CTXF_NORMAL_LABEL = 2048</div></div>
</dd>
<dt id="ida_ua.CTXF_OUTCTX_T"><code class="name">var <span class="ident">CTXF_OUTCTX_T</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
CTXF_OUTCTX_T = 65536</div></div>
</dd>
<dt id="ida_ua.CTXF_OVSTORE_PRNT"><code class="name">var <span class="ident">CTXF_OVSTORE_PRNT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
CTXF_OVSTORE_PRNT = 32768</div></div>
</dd>
<dt id="ida_ua.CTXF_STACK"><code class="name">var <span class="ident">CTXF_STACK</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
CTXF_STACK = 8</div></div>
</dd>
<dt id="ida_ua.CTXF_VOIDS"><code class="name">var <span class="ident">CTXF_VOIDS</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
CTXF_VOIDS = 1024</div></div>
</dd>
<dt id="ida_ua.CTXF_XREF_STATE"><code class="name">var <span class="ident">CTXF_XREF_STATE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
CTXF_XREF_STATE = 96</div></div>
</dd>
<dt id="ida_ua.DEFAULT_INDENT"><code class="name">var <span class="ident">DEFAULT_INDENT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
DEFAULT_INDENT = 65535</div></div>
</dd>
<dt id="ida_ua.FCBF_CONT"><code class="name">var <span class="ident">FCBF_CONT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
don't stop on decoding, or any other kind of error</div></div>
</dd>
<dt id="ida_ua.FCBF_DELIM"><code class="name">var <span class="ident">FCBF_DELIM</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
add the 'ash'-specified delimiters around the generated data. Note: if
those are not defined and the INFFL_ALLASM is not set,
'format_charlit()' will return an error</div></div>
</dd>
<dt id="ida_ua.FCBF_ERR_REPL"><code class="name">var <span class="ident">FCBF_ERR_REPL</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
in case of an error, use a CP_REPLCHAR instead of a hex representation
of the problematic byte</div></div>
</dd>
<dt id="ida_ua.FCBF_FF_LIT"><code class="name">var <span class="ident">FCBF_FF_LIT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
in case of codepoints == 0xFF, use it as-is (i.e., LATIN SMALL LETTER
Y WITH DIAERESIS) If both this, and FCBF_REPL are specified, this will
take precedence</div></div>
</dd>
<dt id="ida_ua.GH_BYTESEX_HAS_HIGHBYTE"><code class="name">var <span class="ident">GH_BYTESEX_HAS_HIGHBYTE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
GH_BYTESEX_HAS_HIGHBYTE = 16</div></div>
</dd>
<dt id="ida_ua.GH_PRINT_ALL"><code class="name">var <span class="ident">GH_PRINT_ALL</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
GH_PRINT_ALL = 15</div></div>
</dd>
<dt id="ida_ua.GH_PRINT_ALL_BUT_BYTESEX"><code class="name">var <span class="ident">GH_PRINT_ALL_BUT_BYTESEX</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
GH_PRINT_ALL_BUT_BYTESEX = 11</div></div>
</dd>
<dt id="ida_ua.GH_PRINT_ASM"><code class="name">var <span class="ident">GH_PRINT_ASM</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
GH_PRINT_ASM = 2</div></div>
</dd>
<dt id="ida_ua.GH_PRINT_BYTESEX"><code class="name">var <span class="ident">GH_PRINT_BYTESEX</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
GH_PRINT_BYTESEX = 4</div></div>
</dd>
<dt id="ida_ua.GH_PRINT_HEADER"><code class="name">var <span class="ident">GH_PRINT_HEADER</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
GH_PRINT_HEADER = 8</div></div>
</dd>
<dt id="ida_ua.GH_PRINT_PROC"><code class="name">var <span class="ident">GH_PRINT_PROC</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
GH_PRINT_PROC = 1</div></div>
</dd>
<dt id="ida_ua.GH_PRINT_PROC_AND_ASM"><code class="name">var <span class="ident">GH_PRINT_PROC_AND_ASM</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
GH_PRINT_PROC_AND_ASM = 3</div></div>
</dd>
<dt id="ida_ua.GH_PRINT_PROC_ASM_AND_BYTESEX"><code class="name">var <span class="ident">GH_PRINT_PROC_ASM_AND_BYTESEX</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
GH_PRINT_PROC_ASM_AND_BYTESEX = 7</div></div>
</dd>
<dt id="ida_ua.INSN_64BIT"><code class="name">var <span class="ident">INSN_64BIT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
belongs to 64bit segment?</div></div>
</dd>
<dt id="ida_ua.INSN_MACRO"><code class="name">var <span class="ident">INSN_MACRO</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
macro instruction</div></div>
</dd>
<dt id="ida_ua.INSN_MODMAC"><code class="name">var <span class="ident">INSN_MODMAC</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
may modify the database to make room for the macro insn</div></div>
</dd>
<dt id="ida_ua.MAKELINE_BINPREF"><code class="name">var <span class="ident">MAKELINE_BINPREF</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
MAKELINE_BINPREF = 1</div></div>
</dd>
<dt id="ida_ua.MAKELINE_NONE"><code class="name">var <span class="ident">MAKELINE_NONE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
MAKELINE_NONE = 0</div></div>
</dd>
<dt id="ida_ua.MAKELINE_STACK"><code class="name">var <span class="ident">MAKELINE_STACK</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
MAKELINE_STACK = 4</div></div>
</dd>
<dt id="ida_ua.MAKELINE_VOID"><code class="name">var <span class="ident">MAKELINE_VOID</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
MAKELINE_VOID = 2</div></div>
</dd>
<dt id="ida_ua.OF_NO_BASE_DISP"><code class="name">var <span class="ident">OF_NO_BASE_DISP</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
base displacement doesn't exist. meaningful only for 'o_displ' type.
if set, base displacement ( 'op_t::addr' ) doesn't exist.</div></div>
</dd>
<dt id="ida_ua.OF_NUMBER"><code class="name">var <span class="ident">OF_NUMBER</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
the operand can be converted to a number only</div></div>
</dd>
<dt id="ida_ua.OF_OUTER_DISP"><code class="name">var <span class="ident">OF_OUTER_DISP</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
outer displacement exists. meaningful only for 'o_displ' type. if set,
outer displacement ( 'op_t::value' ) exists.</div></div>
</dd>
<dt id="ida_ua.OF_SHOW"><code class="name">var <span class="ident">OF_SHOW</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
should the operand be displayed?</div></div>
</dd>
<dt id="ida_ua.OOFS_IFSIGN"><code class="name">var <span class="ident">OOFS_IFSIGN</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
output sign if needed</div></div>
</dd>
<dt id="ida_ua.OOFS_NEEDSIGN"><code class="name">var <span class="ident">OOFS_NEEDSIGN</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
always out sign (+-)</div></div>
</dd>
<dt id="ida_ua.OOFS_NOSIGN"><code class="name">var <span class="ident">OOFS_NOSIGN</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
don't output sign, forbid the user to change the sign</div></div>
</dd>
<dt id="ida_ua.OOFW_16"><code class="name">var <span class="ident">OOFW_16</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
16 bit width</div></div>
</dd>
<dt id="ida_ua.OOFW_24"><code class="name">var <span class="ident">OOFW_24</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
24 bit width</div></div>
</dd>
<dt id="ida_ua.OOFW_32"><code class="name">var <span class="ident">OOFW_32</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
32 bit width</div></div>
</dd>
<dt id="ida_ua.OOFW_64"><code class="name">var <span class="ident">OOFW_64</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
64 bit width</div></div>
</dd>
<dt id="ida_ua.OOFW_8"><code class="name">var <span class="ident">OOFW_8</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
8 bit width</div></div>
</dd>
<dt id="ida_ua.OOFW_IMM"><code class="name">var <span class="ident">OOFW_IMM</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
take from x.dtype</div></div>
</dd>
<dt id="ida_ua.OOF_ADDR"><code class="name">var <span class="ident">OOF_ADDR</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
output x.addr, otherwise x.value</div></div>
</dd>
<dt id="ida_ua.OOF_ANYSERIAL"><code class="name">var <span class="ident">OOF_ANYSERIAL</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
if enum: select first available serial</div></div>
</dd>
<dt id="ida_ua.OOF_NOBNOT"><code class="name">var <span class="ident">OOF_NOBNOT</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
prohibit use of binary not</div></div>
</dd>
<dt id="ida_ua.OOF_NUMBER"><code class="name">var <span class="ident">OOF_NUMBER</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
always as a number</div></div>
</dd>
<dt id="ida_ua.OOF_OUTER"><code class="name">var <span class="ident">OOF_OUTER</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
output outer operand</div></div>
</dd>
<dt id="ida_ua.OOF_SIGNED"><code class="name">var <span class="ident">OOF_SIGNED</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
output as signed if &lt; 0</div></div>
</dd>
<dt id="ida_ua.OOF_SIGNMASK"><code class="name">var <span class="ident">OOF_SIGNMASK</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
sign symbol (+/-) output</div></div>
</dd>
<dt id="ida_ua.OOF_SPACES"><code class="name">var <span class="ident">OOF_SPACES</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
do not suppress leading spaces currently works only for floating point
numbers</div></div>
</dd>
<dt id="ida_ua.OOF_WIDTHMASK"><code class="name">var <span class="ident">OOF_WIDTHMASK</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
width of value in bits</div></div>
</dd>
<dt id="ida_ua.OOF_ZSTROFF"><code class="name">var <span class="ident">OOF_ZSTROFF</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
meaningful only if is_stroff(uFlag) append a struct field name if the
field offset is zero? if 'AFL_ZSTROFF' is set, then this flag is
ignored.</div></div>
</dd>
<dt id="ida_ua.PACK_FORM_DEF"><code class="name">var <span class="ident">PACK_FORM_DEF</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
packed factor defined. (! 'o_reg' + 'dt_packreal' )</div></div>
</dd>
<dt id="ida_ua.STKVAR_VALID_SIZE"><code class="name">var <span class="ident">STKVAR_VALID_SIZE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
STKVAR_VALID_SIZE = 1</div></div>
</dd>
<dt id="ida_ua.XREFSTATE_DONE"><code class="name">var <span class="ident">XREFSTATE_DONE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
XREFSTATE_DONE = 64</div></div>
</dd>
<dt id="ida_ua.XREFSTATE_GO"><code class="name">var <span class="ident">XREFSTATE_GO</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
XREFSTATE_GO = 32</div></div>
</dd>
<dt id="ida_ua.XREFSTATE_NONE"><code class="name">var <span class="ident">XREFSTATE_NONE</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
XREFSTATE_NONE = 0</div></div>
</dd>
<dt id="ida_ua.dt_bitfild"><code class="name">var <span class="ident">dt_bitfild</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
bit field (mc680x0)</div></div>
</dd>
<dt id="ida_ua.dt_byte"><code class="name">var <span class="ident">dt_byte</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
8 bit integer</div></div>
</dd>
<dt id="ida_ua.dt_byte16"><code class="name">var <span class="ident">dt_byte16</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
128 bit integer</div></div>
</dd>
<dt id="ida_ua.dt_byte32"><code class="name">var <span class="ident">dt_byte32</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
256 bit integer</div></div>
</dd>
<dt id="ida_ua.dt_byte64"><code class="name">var <span class="ident">dt_byte64</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
512 bit integer</div></div>
</dd>
<dt id="ida_ua.dt_code"><code class="name">var <span class="ident">dt_code</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
ptr to code (not used?)</div></div>
</dd>
<dt id="ida_ua.dt_double"><code class="name">var <span class="ident">dt_double</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
8 byte floating point</div></div>
</dd>
<dt id="ida_ua.dt_dword"><code class="name">var <span class="ident">dt_dword</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
32 bit integer</div></div>
</dd>
<dt id="ida_ua.dt_float"><code class="name">var <span class="ident">dt_float</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
4 byte floating point</div></div>
</dd>
<dt id="ida_ua.dt_fword"><code class="name">var <span class="ident">dt_fword</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
48 bit</div></div>
</dd>
<dt id="ida_ua.dt_half"><code class="name">var <span class="ident">dt_half</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
2-byte floating point</div></div>
</dd>
<dt id="ida_ua.dt_ldbl"><code class="name">var <span class="ident">dt_ldbl</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
long double (which may be different from tbyte)</div></div>
</dd>
<dt id="ida_ua.dt_packreal"><code class="name">var <span class="ident">dt_packreal</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
packed real format for mc68040</div></div>
</dd>
<dt id="ida_ua.dt_qword"><code class="name">var <span class="ident">dt_qword</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
64 bit integer</div></div>
</dd>
<dt id="ida_ua.dt_string"><code class="name">var <span class="ident">dt_string</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
pointer to asciiz string</div></div>
</dd>
<dt id="ida_ua.dt_tbyte"><code class="name">var <span class="ident">dt_tbyte</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
variable size (\ph{tbyte_size}
) floating point</div></div>
</dd>
<dt id="ida_ua.dt_unicode"><code class="name">var <span class="ident">dt_unicode</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
pointer to unicode string</div></div>
</dd>
<dt id="ida_ua.dt_void"><code class="name">var <span class="ident">dt_void</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
none</div></div>
</dd>
<dt id="ida_ua.dt_word"><code class="name">var <span class="ident">dt_word</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
16 bit integer</div></div>
</dd>
<dt id="ida_ua.o_displ"><code class="name">var <span class="ident">o_displ</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
o_displ = 4</div></div>
</dd>
<dt id="ida_ua.o_far"><code class="name">var <span class="ident">o_far</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
o_far = 6</div></div>
</dd>
<dt id="ida_ua.o_idpspec0"><code class="name">var <span class="ident">o_idpspec0</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
o_idpspec0 = 8</div></div>
</dd>
<dt id="ida_ua.o_idpspec1"><code class="name">var <span class="ident">o_idpspec1</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
o_idpspec1 = 9</div></div>
</dd>
<dt id="ida_ua.o_idpspec2"><code class="name">var <span class="ident">o_idpspec2</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
o_idpspec2 = 10</div></div>
</dd>
<dt id="ida_ua.o_idpspec3"><code class="name">var <span class="ident">o_idpspec3</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
o_idpspec3 = 11</div></div>
</dd>
<dt id="ida_ua.o_idpspec4"><code class="name">var <span class="ident">o_idpspec4</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
o_idpspec4 = 12</div></div>
</dd>
<dt id="ida_ua.o_idpspec5"><code class="name">var <span class="ident">o_idpspec5</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
o_idpspec5 = 13</div></div>
</dd>
<dt id="ida_ua.o_imm"><code class="name">var <span class="ident">o_imm</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
o_imm = 5</div></div>
</dd>
<dt id="ida_ua.o_mem"><code class="name">var <span class="ident">o_mem</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
o_mem = 2</div></div>
</dd>
<dt id="ida_ua.o_near"><code class="name">var <span class="ident">o_near</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
o_near = 7</div></div>
</dd>
<dt id="ida_ua.o_phrase"><code class="name">var <span class="ident">o_phrase</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
o_phrase = 3</div></div>
</dd>
<dt id="ida_ua.o_reg"><code class="name">var <span class="ident">o_reg</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
o_reg = 1</div></div>
</dd>
<dt id="ida_ua.o_void"><code class="name">var <span class="ident">o_void</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
o_void = 0</div></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="ida_ua.calc_dataseg"><code class="name flex">
<span>def <span class="ident">calc_dataseg</span></span>(<span>*args) &#8209;&gt;&#160;ea_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get data segment for the instruction operand. 'opnum' and 'rgnum' are
meaningful only if the processor has segment registers.</div>
<div class="epy_par">
<strong class="epy_sig">calc_dataseg(insn, n=-1, rgnum=-1) -&gt; ea_t</strong><div class="epy_nested">
<strong class="epy_parameter">insn</strong>
- an ida_ua.insn_t, or an address (C++: const insn_t &amp;)</div>
<div class="epy_nested">
<strong class="epy_parameter">n</strong> (C++: int)</div>
<div class="epy_nested">
<strong class="epy_parameter">rgnum</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_ua.can_decode"><code class="name flex">
<span>def <span class="ident">can_decode</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Can the bytes at address 'ea' be decoded as instruction?</div>
<div class="epy_par">
<strong class="epy_sig">can_decode(ea) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong>: linear address (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: whether or not the contents at that address could be a valid<div class="epy_nested">
instruction</div>
</div>
</div></div>
</dd>
<dt id="ida_ua.construct_macro"><code class="name flex">
<span>def <span class="ident">construct_macro</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">construct_macro(insn, enable, build_macro) -&gt; bool</strong><div class="epy_nested">
See ua.hpp's construct_macro().</div>
</div></div>
</dd>
<dt id="ida_ua.construct_macro2"><code class="name flex">
<span>def <span class="ident">construct_macro2</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">construct_macro2(_this, insn, enable) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">_this</strong> (C++: macro_constructor_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">insn</strong> (C++: insn_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">enable</strong> (C++: bool)</div>
</div></div>
</dd>
<dt id="ida_ua.create_insn"><code class="name flex">
<span>def <span class="ident">create_insn</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Create an instruction at the specified address. This function checks
if an instruction is present at the specified address and will try to
create one if there is none. It will fail if there is a data item or
other items hindering the creation of the new instruction. This
function will also fill the 'out' structure.</div>
<div class="epy_par">
<strong class="epy_sig">create_insn(ea, out=None) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong>: linear address (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">out</strong>: the resulting instruction (C++: insn_t
*)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: the length of the instruction or 0</div>
</div></div>
</dd>
<dt id="ida_ua.create_outctx"><code class="name flex">
<span>def <span class="ident">create_outctx</span></span>(<span>*args) &#8209;&gt;&#160;<a title="ida_ua.outctx_base_t" href="#ida_ua.outctx_base_t">outctx_base_t</a>&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Create a new output context. To delete it, just use "delete pctx"</div>
<div class="epy_par">
<strong class="epy_sig">create_outctx(ea, F=0, suspop=0) -&gt; outctx_base_t</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">F</strong> (C++: flags_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">suspop</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_ua.decode_insn"><code class="name flex">
<span>def <span class="ident">decode_insn</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Analyze the specified address and fill 'out'. This function does not
modify the database. It just tries to interpret the specified address
as an instruction and fills the 'out' structure.</div>
<div class="epy_par">
<strong class="epy_sig">decode_insn(out, ea) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">out</strong>: the resulting instruction (C++: insn_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">ea</strong>: linear address (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: the length of the (possible) instruction or 0</div>
</div></div>
</dd>
<dt id="ida_ua.decode_preceding_insn"><code class="name flex">
<span>def <span class="ident">decode_preceding_insn</span></span>(<span>*args) &#8209;&gt;&#160;PyObject&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">decode_preceding_insn(out, ea) -&gt; PyObject *</strong><div class="epy_nested">
Decodes the preceding instruction. Please check ua.hpp / decode_preceding_insn()</div>
<div class="epy_nested">
<strong class="epy_parameter">ea</strong>: current ea</div>
<div class="epy_nested">
<strong class="epy_parameter">out</strong>: instruction storage</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: tuple(preceeding_ea or BADADDR, farref = Boolean)</div>
</div></div>
</dd>
<dt id="ida_ua.decode_prev_insn"><code class="name flex">
<span>def <span class="ident">decode_prev_insn</span></span>(<span>*args) &#8209;&gt;&#160;ea_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Decode previous instruction if it exists, fill 'out'.</div>
<div class="epy_par">
<strong class="epy_sig">decode_prev_insn(out, ea) -&gt; ea_t</strong><div class="epy_nested">
<strong class="epy_parameter">out</strong>: the resulting instruction (C++: insn_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">ea</strong>: the address to decode the previous instruction from (C++:<div class="epy_nested">
ea_t)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: the previous instruction address ( BADADDR -no such insn)</div>
</div></div>
</dd>
<dt id="ida_ua.get_dtype_by_size"><code class="name flex">
<span>def <span class="ident">get_dtype_by_size</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get 'op_t::dtype' from size.</div>
<div class="epy_par">
<strong class="epy_sig">get_dtype_by_size(size) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">size</strong> (C++: asize_t)</div>
</div></div>
</dd>
<dt id="ida_ua.get_dtype_flag"><code class="name flex">
<span>def <span class="ident">get_dtype_flag</span></span>(<span>*args) &#8209;&gt;&#160;flags_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get flags for 'op_t::dtype' field.</div>
<div class="epy_par">
<strong class="epy_sig">get_dtype_flag(dtype) -&gt; flags_t</strong><div class="epy_nested">
<strong class="epy_parameter">dtype</strong> (C++: op_dtype_t)</div>
</div></div>
</dd>
<dt id="ida_ua.get_dtype_size"><code class="name flex">
<span>def <span class="ident">get_dtype_size</span></span>(<span>*args) &#8209;&gt;&#160;size_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get size of opt_::dtype field.</div>
<div class="epy_par">
<strong class="epy_sig">get_dtype_size(dtype) -&gt; size_t</strong><div class="epy_nested">
<strong class="epy_parameter">dtype</strong> (C++: op_dtype_t)</div>
</div></div>
</dd>
<dt id="ida_ua.get_immvals"><code class="name flex">
<span>def <span class="ident">get_immvals</span></span>(<span>*args) &#8209;&gt;&#160;PyObject&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get immediate values at the specified address. This function decodes
instruction at the specified address or inspects the data item. It
finds immediate values and copies them to 'out'. This function will
store the original value of the operands in 'out', unless the last
bits of 'F' are "...0 11111111", in which case the transformed values
(as needed for printing) will be stored instead.</div>
<div class="epy_par">
<strong class="epy_sig">get_immvals(ea, n, F=0) -&gt; PyObject *</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong>: address to analyze (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">n</strong>: number of operand (0.. UA_MAXOP -1), -1 means all operands<div class="epy_nested">
(C++: int)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">F</strong>: flags for the specified address (C++: flags_t)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: number of immediate values (0..2* UA_MAXOP )</div>
</div></div>
</dd>
<dt id="ida_ua.get_lookback"><code class="name flex">
<span>def <span class="ident">get_lookback</span></span>(<span>*args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Number of instructions to look back. This variable is not used by the
kernel. Its value may be specified in ida.cfg: LOOKBACK = <number>.
IDP may use it as you like it. (TMS module uses it)</number></div></div>
</dd>
<dt id="ida_ua.get_printable_immvals"><code class="name flex">
<span>def <span class="ident">get_printable_immvals</span></span>(<span>*args) &#8209;&gt;&#160;PyObject&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Get immediate ready-to-print values at the specified address</div>
<div class="epy_par">
<strong class="epy_sig">get_printable_immvals(ea, n, F=0) -&gt; PyObject *</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong>: address to analyze (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">n</strong>: number of operand (0.. UA_MAXOP -1), -1 means all operands<div class="epy_nested">
(C++: int)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">F</strong>: flags for the specified address (C++: flags_t)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: number of immediate values (0..2* UA_MAXOP )</div>
</div></div>
</dd>
<dt id="ida_ua.insn_add_cref"><code class="name flex">
<span>def <span class="ident">insn_add_cref</span></span>(<span>*args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">insn_add_cref(insn, to, opoff, type)</strong><div class="epy_nested">
insn: an ida_ua.insn_t, or an address (C++: const insn_t &amp;)
to: ea_t
opoff: int
type: enum cref_t</div>
</div></div>
</dd>
<dt id="ida_ua.insn_add_dref"><code class="name flex">
<span>def <span class="ident">insn_add_dref</span></span>(<span>*args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">insn_add_dref(insn, to, opoff, type)</strong><div class="epy_nested">
insn: an ida_ua.insn_t, or an address (C++: const insn_t &amp;)
to: ea_t
opoff: int
type: enum dref_t</div>
</div></div>
</dd>
<dt id="ida_ua.insn_add_off_drefs"><code class="name flex">
<span>def <span class="ident">insn_add_off_drefs</span></span>(<span>*args) &#8209;&gt;&#160;ea_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">insn_add_off_drefs(insn, x, type, outf) -&gt; ea_t</strong><div class="epy_nested">
insn: an ida_ua.insn_t, or an address (C++: const insn_t &amp;)
x: op_t const &amp;
type: enum dref_t
outf: int</div>
</div></div>
</dd>
<dt id="ida_ua.insn_create_stkvar"><code class="name flex">
<span>def <span class="ident">insn_create_stkvar</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">insn_create_stkvar(insn, x, v, flags) -&gt; bool</strong><div class="epy_nested">
insn: an ida_ua.insn_t, or an address (C++: const insn_t &amp;)
x: op_t const &amp;
v: adiff_t
flags: int</div>
</div></div>
</dd>
<dt id="ida_ua.insn_t__from_ptrval__"><code class="name flex">
<span>def <span class="ident">insn_t__from_ptrval__</span></span>(<span>*args) &#8209;&gt;&#160;<a title="ida_ua.insn_t" href="#ida_ua.insn_t">insn_t</a>&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">insn_t__from_ptrval__(ptrval) -&gt; insn_t</strong><div class="epy_nested">
ptrval: size_t</div>
</div></div>
</dd>
<dt id="ida_ua.is_floating_dtype"><code class="name flex">
<span>def <span class="ident">is_floating_dtype</span></span>(<span>*args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is a floating type operand?</div>
<div class="epy_par">
<strong class="epy_sig">is_floating_dtype(dtype) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">dtype</strong> (C++: op_dtype_t)</div>
</div></div>
</dd>
<dt id="ida_ua.map_code_ea"><code class="name flex">
<span>def <span class="ident">map_code_ea</span></span>(<span>*args) &#8209;&gt;&#160;ea_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Map a code address. This function takes into account the segment
translations.</div>
<div class="epy_par">
<strong class="epy_sig">map_code_ea(insn, addr, opnum) -&gt; ea_t</strong><div class="epy_nested">
<strong class="epy_parameter">insn</strong>: the current instruction
- an ida_ua.insn_t, or an<div class="epy_nested">
address (C++: const insn_t &amp;)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">addr</strong>: the referenced address to map (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">opnum</strong>: operand number (C++: int)</div>
</div>
<div class="epy_par">
<strong class="epy_sig">map_code_ea(insn, op) -&gt; ea_t</strong><div class="epy_nested">
<strong class="epy_parameter">insn</strong>: the current instruction
- an ida_ua.insn_t, or an<div class="epy_nested">
address (C++: const insn_t &amp;)</div>
</div>
<div class="epy_nested">
op: op_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_ua.map_data_ea"><code class="name flex">
<span>def <span class="ident">map_data_ea</span></span>(<span>*args) &#8209;&gt;&#160;ea_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Map a data address.</div>
<div class="epy_par">
<strong class="epy_sig">map_data_ea(insn, addr, opnum=-1) -&gt; ea_t</strong><div class="epy_nested">
<strong class="epy_parameter">insn</strong>: the current instruction
- an ida_ua.insn_t, or an<div class="epy_nested">
address (C++: const insn_t &amp;)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">addr</strong>: the referenced address to map (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">opnum</strong>: operand number (C++: int)</div>
</div>
<div class="epy_par">
<strong class="epy_sig">map_data_ea(insn, op) -&gt; ea_t</strong><div class="epy_nested">
<strong class="epy_parameter">insn</strong>: the current instruction
- an ida_ua.insn_t, or an<div class="epy_nested">
address (C++: const insn_t &amp;)</div>
</div>
<div class="epy_nested">
op: op_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_ua.map_ea"><code class="name flex">
<span>def <span class="ident">map_ea</span></span>(<span>*args) &#8209;&gt;&#160;ea_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">map_ea(insn, op, iscode) -&gt; ea_t</strong><div class="epy_nested">
<strong class="epy_parameter">insn</strong>
- an ida_ua.insn_t, or an address (C++: const insn_t &amp;)</div>
<div class="epy_nested">
<strong class="epy_parameter">op</strong> (C++: const
op_t
&amp;)</div>
<div class="epy_nested">
<strong class="epy_parameter">iscode</strong> (C++: bool)</div>
</div>
<div class="epy_par">
<strong class="epy_sig">map_ea(insn, addr, opnum, iscode) -&gt; ea_t</strong><div class="epy_nested">
<strong class="epy_parameter">insn</strong>
- an ida_ua.insn_t, or an address (C++: const insn_t &amp;)
addr: ea_t
opnum: int</div>
<div class="epy_nested">
<strong class="epy_parameter">iscode</strong> (C++: bool)</div>
</div></div>
</dd>
<dt id="ida_ua.op_t__from_ptrval__"><code class="name flex">
<span>def <span class="ident">op_t__from_ptrval__</span></span>(<span>*args) &#8209;&gt;&#160;<a title="ida_ua.op_t" href="#ida_ua.op_t">op_t</a>&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">op_t__from_ptrval__(ptrval) -&gt; op_t</strong><div class="epy_nested">
ptrval: size_t</div>
</div></div>
</dd>
<dt id="ida_ua.outctx_base_t__from_ptrval__"><code class="name flex">
<span>def <span class="ident">outctx_base_t__from_ptrval__</span></span>(<span>*args) &#8209;&gt;&#160;<a title="ida_ua.outctx_base_t" href="#ida_ua.outctx_base_t">outctx_base_t</a>&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">outctx_base_t__from_ptrval__(ptrval) -&gt; outctx_base_t</strong><div class="epy_nested">
ptrval: size_t</div>
</div></div>
</dd>
<dt id="ida_ua.outctx_t__from_ptrval__"><code class="name flex">
<span>def <span class="ident">outctx_t__from_ptrval__</span></span>(<span>*args) &#8209;&gt;&#160;<a title="ida_ua.outctx_t" href="#ida_ua.outctx_t">outctx_t</a>&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">outctx_t__from_ptrval__(ptrval) -&gt; outctx_t</strong><div class="epy_nested">
ptrval: size_t</div>
</div></div>
</dd>
<dt id="ida_ua.print_insn_mnem"><code class="name flex">
<span>def <span class="ident">print_insn_mnem</span></span>(<span>*args) &#8209;&gt;&#160;qstring&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Print instruction mnemonics.</div>
<div class="epy_par">
<strong class="epy_sig">print_insn_mnem(ea) -&gt; str</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong>: linear address of the instruction (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: success</div>
</div></div>
</dd>
<dt id="ida_ua.print_operand"><code class="name flex">
<span>def <span class="ident">print_operand</span></span>(<span>*args) &#8209;&gt;&#160;qstring&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Generate text representation for operand #n. This function will
generate the text representation of the specified operand (includes
color codes.)</div>
<div class="epy_par">
<strong class="epy_sig">print_operand(ea, n, getn_flags=0, newtype=None) -&gt; str</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong>: the item address (instruction or data) (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">n</strong>: operand number (0,1,2...). meaningful only for instructions<div class="epy_nested">
(C++: int)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">getn_flags</strong> (C++: int)</div>
<div class="epy_nested">
<strong class="epy_parameter">newtype</strong>: if specified, print the operand using the specified<div class="epy_nested">
type (C++: struct
printop_t
*)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: success</div>
</div></div>
</dd>
<dt id="ida_ua.ua_mnem"><code class="name flex">
<span>def <span class="ident">ua_mnem</span></span>(<span>*args) &#8209;&gt;&#160;qstring&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Print instruction mnemonics.</div>
<div class="epy_par">
<strong class="epy_sig">print_insn_mnem(ea) -&gt; str</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong>: linear address of the instruction (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: success</div>
</div></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ida_ua.insn_t"><code class="flex name class">
<span>class <span class="ident">insn_t</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ insn_t class.</div>
<div class="epy_par">
<strong class="epy_sig">__init__(self) -&gt; insn_t</strong></div></div>
<h3>Instance variables</h3>
<dl>
<dt id="ida_ua.insn_t.Op1"><code class="name">var <span class="ident">Op1</span></code></dt>
<dd>
<div class="desc"/>
</dd>
<dt id="ida_ua.insn_t.Op2"><code class="name">var <span class="ident">Op2</span></code></dt>
<dd>
<div class="desc"/>
</dd>
<dt id="ida_ua.insn_t.Op3"><code class="name">var <span class="ident">Op3</span></code></dt>
<dd>
<div class="desc"/>
</dd>
<dt id="ida_ua.insn_t.Op4"><code class="name">var <span class="ident">Op4</span></code></dt>
<dd>
<div class="desc"/>
</dd>
<dt id="ida_ua.insn_t.Op5"><code class="name">var <span class="ident">Op5</span></code></dt>
<dd>
<div class="desc"/>
</dd>
<dt id="ida_ua.insn_t.Op6"><code class="name">var <span class="ident">Op6</span></code></dt>
<dd>
<div class="desc"/>
</dd>
<dt id="ida_ua.insn_t.Op7"><code class="name">var <span class="ident">Op7</span></code></dt>
<dd>
<div class="desc"/>
</dd>
<dt id="ida_ua.insn_t.Op8"><code class="name">var <span class="ident">Op8</span></code></dt>
<dd>
<div class="desc"/>
</dd>
<dt id="ida_ua.insn_t.auxpref"><code class="name">var <span class="ident">auxpref</span> :&#160;uint32</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">__get_auxpref__(self) -&gt; uint32</strong></div></div>
</dd>
<dt id="ida_ua.insn_t.cs"><code class="name">var <span class="ident">cs</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">insn_t_cs_get(self) -&gt; ea_t</strong></div></div>
</dd>
<dt id="ida_ua.insn_t.ea"><code class="name">var <span class="ident">ea</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">insn_t_ea_get(self) -&gt; ea_t</strong></div></div>
</dd>
<dt id="ida_ua.insn_t.flags"><code class="name">var <span class="ident">flags</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">insn_t_flags_get(self) -&gt; int16</strong></div></div>
</dd>
<dt id="ida_ua.insn_t.insnpref"><code class="name">var <span class="ident">insnpref</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">insn_t_insnpref_get(self) -&gt; char</strong></div></div>
</dd>
<dt id="ida_ua.insn_t.ip"><code class="name">var <span class="ident">ip</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">insn_t_ip_get(self) -&gt; ea_t</strong></div></div>
</dd>
<dt id="ida_ua.insn_t.itype"><code class="name">var <span class="ident">itype</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">insn_t_itype_get(self) -&gt; uint16</strong></div></div>
</dd>
<dt id="ida_ua.insn_t.ops"><code class="name">var <span class="ident">ops</span> :&#160;wrapped_array_top_t,8&#160;&gt;</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">__get_ops__(self) -&gt; operands_array</strong></div></div>
</dd>
<dt id="ida_ua.insn_t.segpref"><code class="name">var <span class="ident">segpref</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">insn_t_segpref_get(self) -&gt; char</strong></div></div>
</dd>
<dt id="ida_ua.insn_t.size"><code class="name">var <span class="ident">size</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">insn_t_size_get(self) -&gt; uint16</strong></div></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ida_ua.insn_t.add_cref"><code class="name flex">
<span>def <span class="ident">add_cref</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Add a code cross-reference from the instruction.</div>
<div class="epy_par">
<strong class="epy_sig">add_cref(self, to, opoff, type)</strong><div class="epy_nested">
<strong class="epy_parameter">to</strong>: target linear address (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">opoff</strong>: offset of the operand from the start of instruction. if<div class="epy_nested">
the offset is unknown, then 0. (C++: int)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">type</strong>: type of xref (C++: cref_t)</div>
</div></div>
</dd>
<dt id="ida_ua.insn_t.add_dref"><code class="name flex">
<span>def <span class="ident">add_dref</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Add a data cross-reference from the instruction. See 'add_off_drefs()'</div>
<ul class="epy_ul">
<li class="epy_li"><span class="epy_par">
usually it can be used in most cases.</span>
</li>
</ul>
<div class="epy_par">
<strong class="epy_sig">add_dref(self, to, opoff, type)</strong><div class="epy_nested">
<strong class="epy_parameter">to</strong>: target linear address (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">opoff</strong>: offset of the operand from the start of instruction if<div class="epy_nested">
the offset is unknown, then 0 (C++: int)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">type</strong>: type of xref (C++: dref_t)</div>
</div></div>
</dd>
<dt id="ida_ua.insn_t.add_off_drefs"><code class="name flex">
<span>def <span class="ident">add_off_drefs</span></span>(<span>self, *args) &#8209;&gt;&#160;ea_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Add xrefs for an operand of the instruction. This function creates all
cross references for 'enum', 'offset' and 'structure offset' operands.
Use 'add_off_drefs()' in the presence of negative offsets.</div>
<div class="epy_par">
<strong class="epy_sig">add_off_drefs(self, x, type, outf) -&gt; ea_t</strong><div class="epy_nested">
<strong class="epy_parameter">x</strong>: reference to operand (C++: const
op_t
&amp;)</div>
<div class="epy_nested">
<strong class="epy_parameter">type</strong>: type of xref (C++: dref_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">outf</strong>: out_value() flags. These flags should match the flags<div class="epy_nested">
used to output the operand (C++: int)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: if
is_off() : the reference target address (the same as<div class="epy_nested">
calc_reference_data). if
is_stroff() :
BADADDR
because for
stroffs the target address is unknown else:
BADADDR
because
enums do not represent addresses</div>
</div>
</div></div>
</dd>
<dt id="ida_ua.insn_t.assign"><code class="name flex">
<span>def <span class="ident">assign</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">assign(self, other)</strong><div class="epy_nested">
other: an ida_ua.insn_t, or an address (C++: const insn_t &amp;)</div>
</div></div>
</dd>
<dt id="ida_ua.insn_t.create_op_data"><code class="name flex">
<span>def <span class="ident">create_op_data</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">create_op_data(self, ea_, opoff, dtype) -&gt; bool</strong><div class="epy_nested">
ea_: ea_t
opoff: int
dtype: op_dtype_t</div>
</div>
<div class="epy_par">
<strong class="epy_sig">create_op_data(self, ea_, op) -&gt; bool</strong><div class="epy_nested">
ea_: ea_t
op: op_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_ua.insn_t.create_stkvar"><code class="name flex">
<span>def <span class="ident">create_stkvar</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">create_stkvar(self, x, v, flags_) -&gt; bool</strong><div class="epy_nested">
x: op_t const &amp;
v: adiff_t
flags_: int</div>
</div></div>
</dd>
<dt id="ida_ua.insn_t.get_canon_feature"><code class="name flex">
<span>def <span class="ident">get_canon_feature</span></span>(<span>self, *args) &#8209;&gt;&#160;uint32</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
see 'instruc_t::feature'</div>
<div class="epy_par">
<strong class="epy_sig">get_canon_feature(self, ph) -&gt; uint32</strong><div class="epy_nested">
<strong class="epy_parameter">ph</strong> (C++: const
processor_t
&amp;)</div>
</div></div>
</dd>
<dt id="ida_ua.insn_t.get_canon_mnem"><code class="name flex">
<span>def <span class="ident">get_canon_mnem</span></span>(<span>self, *args) &#8209;&gt;&#160;char&#160;const&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
see 'instruc_t::name'</div>
<div class="epy_par">
<strong class="epy_sig">get_canon_mnem(self, ph) -&gt; char const</strong><div class="epy_nested">
<strong class="epy_parameter">ph</strong> (C++: const
processor_t
&amp;)</div>
</div></div>
</dd>
<dt id="ida_ua.insn_t.get_next_byte"><code class="name flex">
<span>def <span class="ident">get_next_byte</span></span>(<span>self, *args) &#8209;&gt;&#160;uint8</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">get_next_byte(self) -&gt; uint8</strong></div></div>
</dd>
<dt id="ida_ua.insn_t.get_next_dword"><code class="name flex">
<span>def <span class="ident">get_next_dword</span></span>(<span>self, *args) &#8209;&gt;&#160;uint32</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">get_next_dword(self) -&gt; uint32</strong></div></div>
</dd>
<dt id="ida_ua.insn_t.get_next_qword"><code class="name flex">
<span>def <span class="ident">get_next_qword</span></span>(<span>self, *args) &#8209;&gt;&#160;uint64</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">get_next_qword(self) -&gt; uint64</strong></div></div>
</dd>
<dt id="ida_ua.insn_t.get_next_word"><code class="name flex">
<span>def <span class="ident">get_next_word</span></span>(<span>self, *args) &#8209;&gt;&#160;uint16</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">get_next_word(self) -&gt; uint16</strong></div></div>
</dd>
<dt id="ida_ua.insn_t.is_64bit"><code class="name flex">
<span>def <span class="ident">is_64bit</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Belongs to a 64bit segment?</div></div>
</dd>
<dt id="ida_ua.insn_t.is_canon_insn"><code class="name flex">
<span>def <span class="ident">is_canon_insn</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
see \ph{ 'is_canon_insn()' }</div>
<div class="epy_par">
<strong class="epy_sig">is_canon_insn(self, ph) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">ph</strong> (C++: const
processor_t
&amp;)</div>
</div></div>
</dd>
<dt id="ida_ua.insn_t.is_macro"><code class="name flex">
<span>def <span class="ident">is_macro</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is a macro instruction?</div></div>
</dd>
</dl>
</dd>
<dt id="ida_ua.macro_constructor_t"><code class="flex name class">
<span>class <span class="ident">macro_constructor_t</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ macro_constructor_t class.</div>
<div class="epy_par">
<strong class="epy_sig">__init__(self) -&gt; macro_constructor_t</strong><div class="epy_nested">
self: PyObject *</div>
</div></div>
<h3>Instance variables</h3>
<dl>
<dt id="ida_ua.macro_constructor_t.reserved"><code class="name">var <span class="ident">reserved</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">macro_constructor_t_reserved_get(self) -&gt; size_t</strong></div></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ida_ua.macro_constructor_t.build_macro"><code class="name flex">
<span>def <span class="ident">build_macro</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Try to extend the instruction.</div>
<div class="epy_par">
<strong class="epy_sig">build_macro(self, insn, may_go_forward) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">insn</strong>: Instruction to modify, usually the first instruction of<div class="epy_nested">
the macro (C++: insn_t
*)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">may_go_forward</strong>: Is it ok to consider the next instruction for<div class="epy_nested">
the macro? This argument may be false, for
example, if there is a cross reference to the
end of INSN. In this case creating a macro is
not desired. However, it may still be useful to
perform minor tweaks to the instruction using
the information about the surrounding
instructions. (C++: bool)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: true if created an macro instruction. This function may<div class="epy_nested">
modify 'insn' and return false; these changes will be
accepted by the kernel but the instruction will not be
considered as a macro.</div>
</div>
</div></div>
</dd>
</dl>
</dd>
<dt id="ida_ua.op_t"><code class="flex name class">
<span>class <span class="ident">op_t</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ op_t class.</div>
<div class="epy_par">
<strong class="epy_sig">__init__(self) -&gt; op_t</strong></div></div>
<h3>Instance variables</h3>
<dl>
<dt id="ida_ua.op_t.addr"><code class="name">var <span class="ident">addr</span> :&#160;ea_t</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">__get_addr__(self) -&gt; ea_t</strong></div></div>
</dd>
<dt id="ida_ua.op_t.dtype"><code class="name">var <span class="ident">dtype</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">op_t_dtype_get(self) -&gt; op_dtype_t</strong></div></div>
</dd>
<dt id="ida_ua.op_t.flags"><code class="name">var <span class="ident">flags</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">op_t_flags_get(self) -&gt; uchar</strong></div></div>
</dd>
<dt id="ida_ua.op_t.n"><code class="name">var <span class="ident">n</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">op_t_n_get(self) -&gt; uchar</strong></div></div>
</dd>
<dt id="ida_ua.op_t.offb"><code class="name">var <span class="ident">offb</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">op_t_offb_get(self) -&gt; char</strong></div></div>
</dd>
<dt id="ida_ua.op_t.offo"><code class="name">var <span class="ident">offo</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">op_t_offo_get(self) -&gt; char</strong></div></div>
</dd>
<dt id="ida_ua.op_t.phrase"><code class="name">var <span class="ident">phrase</span> :&#160;uint16</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">__get_reg_phrase__(self) -&gt; uint16</strong></div></div>
</dd>
<dt id="ida_ua.op_t.reg"><code class="name">var <span class="ident">reg</span> :&#160;uint16</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">__get_reg_phrase__(self) -&gt; uint16</strong></div></div>
</dd>
<dt id="ida_ua.op_t.specflag1"><code class="name">var <span class="ident">specflag1</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">op_t_specflag1_get(self) -&gt; char</strong></div></div>
</dd>
<dt id="ida_ua.op_t.specflag2"><code class="name">var <span class="ident">specflag2</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">op_t_specflag2_get(self) -&gt; char</strong></div></div>
</dd>
<dt id="ida_ua.op_t.specflag3"><code class="name">var <span class="ident">specflag3</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">op_t_specflag3_get(self) -&gt; char</strong></div></div>
</dd>
<dt id="ida_ua.op_t.specflag4"><code class="name">var <span class="ident">specflag4</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">op_t_specflag4_get(self) -&gt; char</strong></div></div>
</dd>
<dt id="ida_ua.op_t.specval"><code class="name">var <span class="ident">specval</span> :&#160;ea_t</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">__get_specval__(self) -&gt; ea_t</strong></div></div>
</dd>
<dt id="ida_ua.op_t.type"><code class="name">var <span class="ident">type</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">op_t_type_get(self) -&gt; optype_t</strong></div></div>
</dd>
<dt id="ida_ua.op_t.value"><code class="name">var <span class="ident">value</span> :&#160;ea_t</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">__get_value__(self) -&gt; ea_t</strong></div></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ida_ua.op_t.assign"><code class="name flex">
<span>def <span class="ident">assign</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">assign(self, other)</strong><div class="epy_nested">
other: op_t const &amp;</div>
</div></div>
</dd>
<dt id="ida_ua.op_t.clr_shown"><code class="name flex">
<span>def <span class="ident">clr_shown</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Set operand to hidden.</div></div>
</dd>
<dt id="ida_ua.op_t.has_reg"><code class="name flex">
<span>def <span class="ident">has_reg</span></span>(<span>self, r)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Checks if the operand accesses the given processor register</div></div>
</dd>
<dt id="ida_ua.op_t.is_imm"><code class="name flex">
<span>def <span class="ident">is_imm</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is immediate operand?</div>
<div class="epy_par">
<strong class="epy_sig">is_imm(self, v) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">v</strong> (C++: uval_t)</div>
</div></div>
</dd>
<dt id="ida_ua.op_t.is_reg"><code class="name flex">
<span>def <span class="ident">is_reg</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is register operand?</div>
<div class="epy_par">
<strong class="epy_sig">is_reg(self, r) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">r</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_ua.op_t.set_shown"><code class="name flex">
<span>def <span class="ident">set_shown</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Set operand to be shown.</div></div>
</dd>
<dt id="ida_ua.op_t.shown"><code class="name flex">
<span>def <span class="ident">shown</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Is operand set to be shown?</div></div>
</dd>
</dl>
</dd>
<dt id="ida_ua.operands_array"><code class="flex name class">
<span>class <span class="ident">operands_array</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ wrapped_array_t&lt; op_t,8 &gt; class.</div>
<div class="epy_par">
<strong class="epy_sig">__init__(self, data) -&gt; operands_array</strong><div class="epy_nested">
data: op_t (&amp;)[8]</div>
</div></div>
<h3>Instance variables</h3>
<dl>
<dt id="ida_ua.operands_array.bytes"><code class="name">var <span class="ident">bytes</span> :&#160;bytevec_t</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">_get_bytes(self) -&gt; bytevec_t</strong></div></div>
</dd>
<dt id="ida_ua.operands_array.data"><code class="name">var <span class="ident">data</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">operands_array_data_get(self) -&gt; op_t (&amp;)[8]</strong></div></div>
</dd>
</dl>
</dd>
<dt id="ida_ua.outctx_base_t"><code class="flex name class">
<span>class <span class="ident">outctx_base_t</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ outctx_base_t class.</div></div>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="ida_ua.outctx_t" href="#ida_ua.outctx_t">outctx_t</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="ida_ua.outctx_base_t.default_lnnum"><code class="name">var <span class="ident">default_lnnum</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">outctx_base_t_default_lnnum_get(self) -&gt; int</strong></div></div>
</dd>
<dt id="ida_ua.outctx_base_t.insn_ea"><code class="name">var <span class="ident">insn_ea</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">outctx_base_t_insn_ea_get(self) -&gt; ea_t</strong></div></div>
</dd>
<dt id="ida_ua.outctx_base_t.outbuf"><code class="name">var <span class="ident">outbuf</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">outctx_base_t_outbuf_get(self) -&gt; qstring *</strong></div></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ida_ua.outctx_base_t.close_comment"><code class="name flex">
<span>def <span class="ident">close_comment</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">close_comment(self)</strong></div></div>
</dd>
<dt id="ida_ua.outctx_base_t.clr_gen_label"><code class="name flex">
<span>def <span class="ident">clr_gen_label</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">clr_gen_label(self)</strong></div></div>
</dd>
<dt id="ida_ua.outctx_base_t.display_voids"><code class="name flex">
<span>def <span class="ident">display_voids</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">display_voids(self) -&gt; bool</strong></div></div>
</dd>
<dt id="ida_ua.outctx_base_t.flush_buf"><code class="name flex">
<span>def <span class="ident">flush_buf</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Append contents of 'buf' to the line array. Behaves like flush_outbuf
but accepts an arbitrary buffer</div>
<div class="epy_par">
<strong class="epy_sig">flush_buf(self, buf, indent=-1) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">buf</strong> (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">indent</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_ua.outctx_base_t.flush_outbuf"><code class="name flex">
<span>def <span class="ident">flush_outbuf</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Functions to populate the output line array (lnar) Move the contents
of the output buffer to the line array (outbuf-&gt;lnar) The kernel
augments the outbuf contents with additional text like the line
prefix, user-defined comments, xrefs, etc at this call.</div>
<div class="epy_par">
<strong class="epy_sig">flush_outbuf(self, indent=-1) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">indent</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_ua.outctx_base_t.forbid_annotations"><code class="name flex">
<span>def <span class="ident">forbid_annotations</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">forbid_annotations(self) -&gt; int</strong></div></div>
</dd>
<dt id="ida_ua.outctx_base_t.force_code"><code class="name flex">
<span>def <span class="ident">force_code</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">force_code(self) -&gt; bool</strong></div></div>
</dd>
<dt id="ida_ua.outctx_base_t.gen_block_cmt"><code class="name flex">
<span>def <span class="ident">gen_block_cmt</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Generate big non-indented comment lines.</div>
<div class="epy_par">
<strong class="epy_sig">gen_block_cmt(self, cmt, color) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">cmt</strong>: comment text. may contain \n characters to denote new<div class="epy_nested">
lines. should not contain comment character (;) (C++:
const char *)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">color</strong>: color of comment text (one of
Color tags ) (C++:<div class="epy_nested">
color_t)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: overflow, lnar_maxsize has been reached</div>
</div></div>
</dd>
<dt id="ida_ua.outctx_base_t.gen_border_line"><code class="name flex">
<span>def <span class="ident">gen_border_line</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Generate thin border line. This function does nothing if generation of
border lines is disabled.</div>
<div class="epy_par">
<strong class="epy_sig">gen_border_line(self, solid=False) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">solid</strong>: generate solid border line (with =), otherwise with -<div class="epy_nested">
(C++: bool)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: overflow, lnar_maxsize has been reached</div>
</div></div>
</dd>
<dt id="ida_ua.outctx_base_t.gen_cmt_line"><code class="name flex">
<span>def <span class="ident">gen_cmt_line</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Generate one non-indented comment line, colored with 'COLOR_AUTOCMT' .</div>
<div class="epy_par">
<strong class="epy_sig">gen_cmt_line(self, format) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">format</strong>: printf() style format line. The resulting comment line<div class="epy_nested">
should not include comment character (;) (C++: const
char *)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: overflow, lnar_maxsize has been reached</div>
</div></div>
</dd>
<dt id="ida_ua.outctx_base_t.gen_collapsed_line"><code class="name flex">
<span>def <span class="ident">gen_collapsed_line</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Generate one non-indented comment line, colored with 'COLOR_COLLAPSED'
.</div>
<div class="epy_par">
<strong class="epy_sig">gen_collapsed_line(self, format) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">format</strong>: printf() style format line. The resulting comment line<div class="epy_nested">
should not include comment character (;) (C++: const
char *)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: overflow, lnar_maxsize has been reached</div>
</div></div>
</dd>
<dt id="ida_ua.outctx_base_t.gen_empty_line"><code class="name flex">
<span>def <span class="ident">gen_empty_line</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Generate empty line. This function does nothing if generation of empty
lines is disabled.</div></div>
</dd>
<dt id="ida_ua.outctx_base_t.gen_empty_line_without_annotations"><code class="name flex">
<span>def <span class="ident">gen_empty_line_without_annotations</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">gen_empty_line_without_annotations(self)</strong></div></div>
</dd>
<dt id="ida_ua.outctx_base_t.gen_printf"><code class="name flex">
<span>def <span class="ident">gen_printf</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
printf-like function to add lines to the line array.</div>
<div class="epy_par">
<strong class="epy_sig">gen_printf(self, indent, format) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">indent</strong>: indention of the line. if indent == -1, the kernel will<div class="epy_nested">
indent the line at \inf{indent}
. if indent &lt; 0, -indent
will be used for indention. The first line printed with
indent &lt; 0 is considered as the most important line at
the current address. Usually it is the line with the
instruction itself. This line will be displayed in the
cross-reference lists and other places. If you need to
output an additional line before the main line then
pass DEFAULT_INDENT instead of -1. The kernel will know
that your line is not the most important one. (C++:
int)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">format</strong>: printf style colored line to generate (C++: const char<div class="epy_nested">
*)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: overflow, lnar_maxsize has been reached</div>
</div></div>
</dd>
<dt id="ida_ua.outctx_base_t.gen_xref_lines"><code class="name flex">
<span>def <span class="ident">gen_xref_lines</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">gen_xref_lines(self) -&gt; bool</strong></div></div>
</dd>
<dt id="ida_ua.outctx_base_t.get_stkvar"><code class="name flex">
<span>def <span class="ident">get_stkvar</span></span>(<span>self, *args) &#8209;&gt;&#160;member_t&#160;*</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">get_stkvar(self, arg2, arg3, arg4, arg5) -&gt; member_t *</strong><div class="epy_nested">
arg2: op_t const &amp;
arg3: uval_t
arg4: sval_t *
arg5: int *</div>
</div></div>
</dd>
<dt id="ida_ua.outctx_base_t.init_lines_array"><code class="name flex">
<span>def <span class="ident">init_lines_array</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">init_lines_array(self, answers, maxsize)</strong><div class="epy_nested">
<strong class="epy_parameter">answers</strong> (C++: qstrvec_t
*)</div>
<div class="epy_nested">
<strong class="epy_parameter">maxsize</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_ua.outctx_base_t.multiline"><code class="name flex">
<span>def <span class="ident">multiline</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">multiline(self) -&gt; bool</strong></div></div>
</dd>
<dt id="ida_ua.outctx_base_t.only_main_line"><code class="name flex">
<span>def <span class="ident">only_main_line</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">only_main_line(self) -&gt; bool</strong></div></div>
</dd>
<dt id="ida_ua.outctx_base_t.out_addr_tag"><code class="name flex">
<span>def <span class="ident">out_addr_tag</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Output "address" escape sequence.</div>
<div class="epy_par">
<strong class="epy_sig">out_addr_tag(self, ea)</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
</div></div>
</dd>
<dt id="ida_ua.outctx_base_t.out_btoa"><code class="name flex">
<span>def <span class="ident">out_btoa</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Output a number with the specified base (binary, octal, decimal, hex)
The number is output without color codes. see also 'out_long()'</div>
<div class="epy_par">
<strong class="epy_sig">out_btoa(self, Word, radix=0)</strong><div class="epy_nested">
<strong class="epy_parameter">Word</strong> (C++: uval_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">radix</strong> (C++: char)</div>
</div></div>
</dd>
<dt id="ida_ua.outctx_base_t.out_char"><code class="name flex">
<span>def <span class="ident">out_char</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Output one character. The character is output without color codes. see
also 'out_symbol()'</div>
<div class="epy_par">
<strong class="epy_sig">out_char(self, c)</strong><div class="epy_nested">
<strong class="epy_parameter">c</strong> (C++: char)</div>
</div></div>
</dd>
<dt id="ida_ua.outctx_base_t.out_chars"><code class="name flex">
<span>def <span class="ident">out_chars</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Append a character multiple times.</div>
<div class="epy_par">
<strong class="epy_sig">out_chars(self, c, n)</strong><div class="epy_nested">
<strong class="epy_parameter">c</strong> (C++: char)</div>
<div class="epy_nested">
<strong class="epy_parameter">n</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_ua.outctx_base_t.out_colored_register_line"><code class="name flex">
<span>def <span class="ident">out_colored_register_line</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Output a colored line with register names in it. The register names
will be substituted by user-defined names ( 'regvar_t' ) Please note
that out_tagoff tries to make substitutions too (when called with
COLOR_REG)</div>
<div class="epy_par">
<strong class="epy_sig">out_colored_register_line(self, str)</strong><div class="epy_nested">
<strong class="epy_parameter">str</strong> (C++: const char *)</div>
</div></div>
</dd>
<dt id="ida_ua.outctx_base_t.out_keyword"><code class="name flex">
<span>def <span class="ident">out_keyword</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Output a string with 'COLOR_KEYWORD' color.</div>
<div class="epy_par">
<strong class="epy_sig">out_keyword(self, str)</strong><div class="epy_nested">
<strong class="epy_parameter">str</strong> (C++: const char *)</div>
</div></div>
</dd>
<dt id="ida_ua.outctx_base_t.out_line"><code class="name flex">
<span>def <span class="ident">out_line</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Output a string with the specified color.</div>
<div class="epy_par">
<strong class="epy_sig">out_line(self, str, color=0)</strong><div class="epy_nested">
<strong class="epy_parameter">str</strong> (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">color</strong> (C++: color_t)</div>
</div></div>
</dd>
<dt id="ida_ua.outctx_base_t.out_long"><code class="name flex">
<span>def <span class="ident">out_long</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Output a number with appropriate color. Low level function. Use
'out_value()' if you can. if 'suspop' is set then this function uses
'COLOR_VOIDOP' instead of 'COLOR_NUMBER' . 'suspop' is initialized:in
out_one_operand()in ..\ida\gl.cpp (before calling \ph{d_out()}
)</div>
<div class="epy_par">
<strong class="epy_sig">out_long(self, v, radix)</strong><div class="epy_nested">
<strong class="epy_parameter">v</strong> (C++: sval_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">radix</strong> (C++: char)</div>
</div></div>
</dd>
<dt id="ida_ua.outctx_base_t.out_name_expr"><code class="name flex">
<span>def <span class="ident">out_name_expr</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Output a name expression.</div>
<div class="epy_par">
<strong class="epy_sig">out_name_expr(self, x, ea, off=BADADDR) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">x</strong>: instruction operand referencing the name expression (C++:<div class="epy_nested">
const
op_t
&amp;)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">ea</strong>: address to convert to name expression (C++: ea_t)</div>
<div class="epy_nested">
<strong class="epy_parameter">off</strong>: the value of name expression. this parameter is used only<div class="epy_nested">
to check that the name expression will have the wanted
value. You may pass
BADADDR
for this parameter but I
discourage it because it prohibits checks. (C++: adiff_t)</div>
</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: true if the name expression has been produced</div>
</div></div>
</dd>
<dt id="ida_ua.outctx_base_t.out_printf"><code class="name flex">
<span>def <span class="ident">out_printf</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Functions to append text to the current output buffer (outbuf) Append
a formatted string to the output string.</div>
<div class="epy_par">
<strong class="epy_sig">out_printf(self, format)</strong><div class="epy_nested">
<strong class="epy_parameter">format</strong> (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: the number of characters appended</div>
</div></div>
</dd>
<dt id="ida_ua.outctx_base_t.out_register"><code class="name flex">
<span>def <span class="ident">out_register</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Output a character with 'COLOR_REG' color.</div>
<div class="epy_par">
<strong class="epy_sig">out_register(self, str)</strong><div class="epy_nested">
<strong class="epy_parameter">str</strong> (C++: const char *)</div>
</div></div>
</dd>
<dt id="ida_ua.outctx_base_t.out_spaces"><code class="name flex">
<span>def <span class="ident">out_spaces</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Appends spaces to outbuf until its tag_strlen becomes 'len'.</div>
<div class="epy_par">
<strong class="epy_sig">out_spaces(self, len)</strong><div class="epy_nested">
<strong class="epy_parameter">len</strong> (C++: ssize_t)</div>
</div></div>
</dd>
<dt id="ida_ua.outctx_base_t.out_symbol"><code class="name flex">
<span>def <span class="ident">out_symbol</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Output a character with 'COLOR_SYMBOL' color.</div>
<div class="epy_par">
<strong class="epy_sig">out_symbol(self, c)</strong><div class="epy_nested">
<strong class="epy_parameter">c</strong> (C++: char)</div>
</div></div>
</dd>
<dt id="ida_ua.outctx_base_t.out_tagoff"><code class="name flex">
<span>def <span class="ident">out_tagoff</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Output "turn color off" escape sequence.</div>
<div class="epy_par">
<strong class="epy_sig">out_tagoff(self, tag)</strong><div class="epy_nested">
<strong class="epy_parameter">tag</strong> (C++: color_t)</div>
</div></div>
</dd>
<dt id="ida_ua.outctx_base_t.out_tagon"><code class="name flex">
<span>def <span class="ident">out_tagon</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Output "turn color on" escape sequence.</div>
<div class="epy_par">
<strong class="epy_sig">out_tagon(self, tag)</strong><div class="epy_nested">
<strong class="epy_parameter">tag</strong> (C++: color_t)</div>
</div></div>
</dd>
<dt id="ida_ua.outctx_base_t.out_value"><code class="name flex">
<span>def <span class="ident">out_value</span></span>(<span>self, *args) &#8209;&gt;&#160;flags_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Output immediate value. Try to use this function to output all
constants of instruction operands. This function outputs a number from
x.addr or x.value in the form determined by ::uFlag. It outputs a
colored text.-1 is output with 'COLOR_ERROR' 0 is output as a number
or character or segment</div>
<div class="epy_par">
<strong class="epy_sig">out_value(self, x, outf=0) -&gt; flags_t</strong><div class="epy_nested">
<strong class="epy_parameter">x</strong> (C++: const
op_t
&amp;)</div>
<div class="epy_nested">
<strong class="epy_parameter">outf</strong> (C++: int)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: flags of the output value</div>
</div></div>
</dd>
<dt id="ida_ua.outctx_base_t.print_label_now"><code class="name flex">
<span>def <span class="ident">print_label_now</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">print_label_now(self) -&gt; bool</strong></div></div>
</dd>
<dt id="ida_ua.outctx_base_t.restore_ctxflags"><code class="name flex">
<span>def <span class="ident">restore_ctxflags</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">restore_ctxflags(self, saved_flags)</strong><div class="epy_nested">
<strong class="epy_parameter">saved_flags</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_ua.outctx_base_t.retrieve_cmt"><code class="name flex">
<span>def <span class="ident">retrieve_cmt</span></span>(<span>self, *args) &#8209;&gt;&#160;ssize_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">retrieve_cmt(self) -&gt; ssize_t</strong></div></div>
</dd>
<dt id="ida_ua.outctx_base_t.retrieve_name"><code class="name flex">
<span>def <span class="ident">retrieve_name</span></span>(<span>self, *args) &#8209;&gt;&#160;ssize_t</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">retrieve_name(self, arg2, arg3) -&gt; ssize_t</strong><div class="epy_nested">
arg2: qstring *
arg3: color_t *</div>
</div></div>
</dd>
<dt id="ida_ua.outctx_base_t.set_comment_addr"><code class="name flex">
<span>def <span class="ident">set_comment_addr</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">set_comment_addr(self, ea)</strong><div class="epy_nested">
<strong class="epy_parameter">ea</strong> (C++: ea_t)</div>
</div></div>
</dd>
<dt id="ida_ua.outctx_base_t.set_dlbind_opnd"><code class="name flex">
<span>def <span class="ident">set_dlbind_opnd</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">set_dlbind_opnd(self)</strong></div></div>
</dd>
<dt id="ida_ua.outctx_base_t.set_gen_cmt"><code class="name flex">
<span>def <span class="ident">set_gen_cmt</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">set_gen_cmt(self, on=True)</strong><div class="epy_nested">
<strong class="epy_parameter">on</strong> (C++: bool)</div>
</div></div>
</dd>
<dt id="ida_ua.outctx_base_t.set_gen_demangled_label"><code class="name flex">
<span>def <span class="ident">set_gen_demangled_label</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">set_gen_demangled_label(self)</strong></div></div>
</dd>
<dt id="ida_ua.outctx_base_t.set_gen_label"><code class="name flex">
<span>def <span class="ident">set_gen_label</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">set_gen_label(self)</strong></div></div>
</dd>
<dt id="ida_ua.outctx_base_t.set_gen_xrefs"><code class="name flex">
<span>def <span class="ident">set_gen_xrefs</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">set_gen_xrefs(self, on=True)</strong><div class="epy_nested">
<strong class="epy_parameter">on</strong> (C++: bool)</div>
</div></div>
</dd>
<dt id="ida_ua.outctx_base_t.setup_outctx"><code class="name flex">
<span>def <span class="ident">setup_outctx</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Initialization; normally used only by the kernel.</div>
<div class="epy_par">
<strong class="epy_sig">setup_outctx(self, prefix, makeline_flags)</strong><div class="epy_nested">
<strong class="epy_parameter">prefix</strong> (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">makeline_flags</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_ua.outctx_base_t.stack_view"><code class="name flex">
<span>def <span class="ident">stack_view</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">stack_view(self) -&gt; bool</strong></div></div>
</dd>
<dt id="ida_ua.outctx_base_t.term_outctx"><code class="name flex">
<span>def <span class="ident">term_outctx</span></span>(<span>self, *args) &#8209;&gt;&#160;int</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Finalize the output context.</div>
<div class="epy_par">
<strong class="epy_sig">term_outctx(self, prefix=None) -&gt; int</strong><div class="epy_nested">
<strong class="epy_parameter">prefix</strong> (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_tag">return</strong>: the number of generated lines.</div>
</div></div>
</dd>
</dl>
</dd>
<dt id="ida_ua.outctx_t"><code class="flex name class">
<span>class <span class="ident">outctx_t</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Proxy of C++ outctx_t class.</div></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="ida_ua.outctx_base_t" href="#ida_ua.outctx_base_t">outctx_base_t</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="ida_ua.outctx_t.ash"><code class="name">var <span class="ident">ash</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">outctx_t_ash_get(self) -&gt; asm_t</strong></div></div>
</dd>
<dt id="ida_ua.outctx_t.bin_ea"><code class="name">var <span class="ident">bin_ea</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">outctx_t_bin_ea_get(self) -&gt; ea_t</strong></div></div>
</dd>
<dt id="ida_ua.outctx_t.bin_state"><code class="name">var <span class="ident">bin_state</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">outctx_t_bin_state_get(self) -&gt; char</strong></div></div>
</dd>
<dt id="ida_ua.outctx_t.bin_width"><code class="name">var <span class="ident">bin_width</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">outctx_t_bin_width_get(self) -&gt; int</strong></div></div>
</dd>
<dt id="ida_ua.outctx_t.curlabel"><code class="name">var <span class="ident">curlabel</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">outctx_t_curlabel_get(self) -&gt; qstring *</strong></div></div>
</dd>
<dt id="ida_ua.outctx_t.gl_bpsize"><code class="name">var <span class="ident">gl_bpsize</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">outctx_t_gl_bpsize_get(self) -&gt; int</strong></div></div>
</dd>
<dt id="ida_ua.outctx_t.insn"><code class="name">var <span class="ident">insn</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">outctx_t_insn_get(self) -&gt; insn_t</strong></div></div>
</dd>
<dt id="ida_ua.outctx_t.ph"><code class="name">var <span class="ident">ph</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">outctx_t_ph_get(self) -&gt; processor_t</strong></div></div>
</dd>
<dt id="ida_ua.outctx_t.procmod"><code class="name">var <span class="ident">procmod</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">outctx_t_procmod_get(self) -&gt; procmod_t</strong></div></div>
</dd>
<dt id="ida_ua.outctx_t.saved_immvals"><code class="name">var <span class="ident">saved_immvals</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">outctx_t_saved_immvals_get(self) -&gt; uval_t [8]</strong></div></div>
</dd>
<dt id="ida_ua.outctx_t.wif"><code class="name">var <span class="ident">wif</span></code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">outctx_t_wif_get(self) -&gt; printop_t</strong></div></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ida_ua.outctx_t.gen_func_footer"><code class="name flex">
<span>def <span class="ident">gen_func_footer</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">gen_func_footer(self, pfn)</strong><div class="epy_nested">
<strong class="epy_parameter">pfn</strong> (C++: const
func_t
*)</div>
</div></div>
</dd>
<dt id="ida_ua.outctx_t.gen_func_header"><code class="name flex">
<span>def <span class="ident">gen_func_header</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">gen_func_header(self, pfn)</strong><div class="epy_nested">
<strong class="epy_parameter">pfn</strong> (C++: func_t
*)</div>
</div></div>
</dd>
<dt id="ida_ua.outctx_t.gen_header"><code class="name flex">
<span>def <span class="ident">gen_header</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
gen_header(self, flags=((1 &lt;&lt; 0)|(1 &lt;&lt; 1)), proc_name=None, proc_flavour=None)<div class="epy_nested">
<strong class="epy_parameter">flags</strong> (C++: int)</div>
<div class="epy_nested">
<strong class="epy_parameter">proc_name</strong> (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">proc_flavour</strong> (C++: const char *)</div>
</div></div>
</dd>
<dt id="ida_ua.outctx_t.gen_header_extra"><code class="name flex">
<span>def <span class="ident">gen_header_extra</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">gen_header_extra(self)</strong></div></div>
</dd>
<dt id="ida_ua.outctx_t.out_custom_mnem"><code class="name flex">
<span>def <span class="ident">out_custom_mnem</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Output custom mnemonic for 'insn'. E.g. if it should differ from the
one in 'ph.instruc'. This function outputs colored text. See
'out_mnem'</div>
<div class="epy_par">
<strong class="epy_sig">out_custom_mnem(self, mnem, width=8, postfix=None)</strong><div class="epy_nested">
<strong class="epy_parameter">mnem</strong>: custom mnemonic (C++: const char *)</div>
<div class="epy_nested">
<strong class="epy_parameter">width</strong>: width of field with mnemonic. if &lt; 0, then 'postfix'<div class="epy_nested">
will be output before the mnemonic, i.e. as a prefix
(C++: int)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">postfix</strong>: optional postfix added to 'mnem' (C++: const char *)</div>
</div></div>
</dd>
<dt id="ida_ua.outctx_t.out_data"><code class="name flex">
<span>def <span class="ident">out_data</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">out_data(self, analyze_only)</strong><div class="epy_nested">
<strong class="epy_parameter">analyze_only</strong> (C++: bool)</div>
</div></div>
</dd>
<dt id="ida_ua.outctx_t.out_immchar_cmts"><code class="name flex">
<span>def <span class="ident">out_immchar_cmts</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Print all operand values as commented character constants. This
function is used to comment void operands with their representation in
the form of character constants. This function outputs a colored text.</div></div>
</dd>
<dt id="ida_ua.outctx_t.out_mnem"><code class="name flex">
<span>def <span class="ident">out_mnem</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Output instruction mnemonic for 'insn' using information in
'ph.instruc' array. This function outputs a colored text. It should be
called from \ph{ev_out_insn()}
or \ph{ev_out_mnem()} handler. It will
output at least one space after the instruction. mnemonic even if the
specified 'width' is not enough.</div>
<div class="epy_par">
<strong class="epy_sig">out_mnem(self, width=8, postfix=None)</strong><div class="epy_nested">
<strong class="epy_parameter">width</strong>: width of field with mnemonic. if &lt; 0, then 'postfix'<div class="epy_nested">
will be output before the mnemonic, i.e. as a prefix
(C++: int)</div>
</div>
<div class="epy_nested">
<strong class="epy_parameter">postfix</strong>: optional postfix added to the instruction mnemonic<div class="epy_nested">
(C++: const char *)</div>
</div>
</div></div>
</dd>
<dt id="ida_ua.outctx_t.out_mnemonic"><code class="name flex">
<span>def <span class="ident">out_mnemonic</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Output instruction mnemonic using information in 'insn'. It should be
called from \ph{ev_out_insn()}
and it will call \ph{ev_out_mnem()} or
'out_mnem' . This function outputs a colored text.</div></div>
</dd>
<dt id="ida_ua.outctx_t.out_one_operand"><code class="name flex">
<span>def <span class="ident">out_one_operand</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Use this function to output an operand of an instruction. This
function checks for the existence of a manually defined operand and
will output it if it exists. It should be called from</div>
<div class="epy_par">
\ph{ev_out_insn()}<div class="epy_nested">
and it will call \ph{ev_out_operand()}. This
function outputs a colored text.</div>
</div>
<div class="epy_par">
<strong class="epy_sig">out_one_operand(self, n) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">n</strong>: number of operand (C++: int)</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 1 - operand is displayed</div>
<div class="epy_nested">
<strong class="epy_tag">retval</strong>: 0 - operand is hidden</div>
</div></div>
</dd>
<dt id="ida_ua.outctx_t.out_specea"><code class="name flex">
<span>def <span class="ident">out_specea</span></span>(<span>self, *args) &#8209;&gt;&#160;bool</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">out_specea(self, segtype) -&gt; bool</strong><div class="epy_nested">
<strong class="epy_parameter">segtype</strong> (C++: uchar)</div>
</div></div>
</dd>
<dt id="ida_ua.outctx_t.set_bin_state"><code class="name flex">
<span>def <span class="ident">set_bin_state</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
<strong class="epy_sig">set_bin_state(self, value)</strong><div class="epy_nested">
<strong class="epy_parameter">value</strong> (C++: int)</div>
</div></div>
</dd>
<dt id="ida_ua.outctx_t.setup_outctx"><code class="name flex">
<span>def <span class="ident">setup_outctx</span></span>(<span>self, *args) &#8209;&gt;&#160;void</span>
</code></dt>
<dd>
<div class="desc"><div class="epy_par">
Initialization; normally used only by the kernel.</div>
<div class="epy_par">
<strong class="epy_sig">setup_outctx(self, prefix, flags)</strong><div class="epy_nested">
<strong class="epy_parameter">prefix</strong> (C++: const char *)
flags: int</div>
</div></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="ida_ua.outctx_base_t" href="#ida_ua.outctx_base_t">outctx_base_t</a></b></code>:
<ul class="hlist">
<li><code><a title="ida_ua.outctx_base_t.close_comment" href="#ida_ua.outctx_base_t.close_comment">close_comment</a></code></li>
<li><code><a title="ida_ua.outctx_base_t.clr_gen_label" href="#ida_ua.outctx_base_t.clr_gen_label">clr_gen_label</a></code></li>
<li><code><a title="ida_ua.outctx_base_t.default_lnnum" href="#ida_ua.outctx_base_t.default_lnnum">default_lnnum</a></code></li>
<li><code><a title="ida_ua.outctx_base_t.display_voids" href="#ida_ua.outctx_base_t.display_voids">display_voids</a></code></li>
<li><code><a title="ida_ua.outctx_base_t.flush_buf" href="#ida_ua.outctx_base_t.flush_buf">flush_buf</a></code></li>
<li><code><a title="ida_ua.outctx_base_t.flush_outbuf" href="#ida_ua.outctx_base_t.flush_outbuf">flush_outbuf</a></code></li>
<li><code><a title="ida_ua.outctx_base_t.forbid_annotations" href="#ida_ua.outctx_base_t.forbid_annotations">forbid_annotations</a></code></li>
<li><code><a title="ida_ua.outctx_base_t.force_code" href="#ida_ua.outctx_base_t.force_code">force_code</a></code></li>
<li><code><a title="ida_ua.outctx_base_t.gen_block_cmt" href="#ida_ua.outctx_base_t.gen_block_cmt">gen_block_cmt</a></code></li>
<li><code><a title="ida_ua.outctx_base_t.gen_border_line" href="#ida_ua.outctx_base_t.gen_border_line">gen_border_line</a></code></li>
<li><code><a title="ida_ua.outctx_base_t.gen_cmt_line" href="#ida_ua.outctx_base_t.gen_cmt_line">gen_cmt_line</a></code></li>
<li><code><a title="ida_ua.outctx_base_t.gen_collapsed_line" href="#ida_ua.outctx_base_t.gen_collapsed_line">gen_collapsed_line</a></code></li>
<li><code><a title="ida_ua.outctx_base_t.gen_empty_line" href="#ida_ua.outctx_base_t.gen_empty_line">gen_empty_line</a></code></li>
<li><code><a title="ida_ua.outctx_base_t.gen_empty_line_without_annotations" href="#ida_ua.outctx_base_t.gen_empty_line_without_annotations">gen_empty_line_without_annotations</a></code></li>
<li><code><a title="ida_ua.outctx_base_t.gen_printf" href="#ida_ua.outctx_base_t.gen_printf">gen_printf</a></code></li>
<li><code><a title="ida_ua.outctx_base_t.gen_xref_lines" href="#ida_ua.outctx_base_t.gen_xref_lines">gen_xref_lines</a></code></li>
<li><code><a title="ida_ua.outctx_base_t.get_stkvar" href="#ida_ua.outctx_base_t.get_stkvar">get_stkvar</a></code></li>
<li><code><a title="ida_ua.outctx_base_t.init_lines_array" href="#ida_ua.outctx_base_t.init_lines_array">init_lines_array</a></code></li>
<li><code><a title="ida_ua.outctx_base_t.insn_ea" href="#ida_ua.outctx_base_t.insn_ea">insn_ea</a></code></li>
<li><code><a title="ida_ua.outctx_base_t.multiline" href="#ida_ua.outctx_base_t.multiline">multiline</a></code></li>
<li><code><a title="ida_ua.outctx_base_t.only_main_line" href="#ida_ua.outctx_base_t.only_main_line">only_main_line</a></code></li>
<li><code><a title="ida_ua.outctx_base_t.out_addr_tag" href="#ida_ua.outctx_base_t.out_addr_tag">out_addr_tag</a></code></li>
<li><code><a title="ida_ua.outctx_base_t.out_btoa" href="#ida_ua.outctx_base_t.out_btoa">out_btoa</a></code></li>
<li><code><a title="ida_ua.outctx_base_t.out_char" href="#ida_ua.outctx_base_t.out_char">out_char</a></code></li>
<li><code><a title="ida_ua.outctx_base_t.out_chars" href="#ida_ua.outctx_base_t.out_chars">out_chars</a></code></li>
<li><code><a title="ida_ua.outctx_base_t.out_colored_register_line" href="#ida_ua.outctx_base_t.out_colored_register_line">out_colored_register_line</a></code></li>
<li><code><a title="ida_ua.outctx_base_t.out_keyword" href="#ida_ua.outctx_base_t.out_keyword">out_keyword</a></code></li>
<li><code><a title="ida_ua.outctx_base_t.out_line" href="#ida_ua.outctx_base_t.out_line">out_line</a></code></li>
<li><code><a title="ida_ua.outctx_base_t.out_long" href="#ida_ua.outctx_base_t.out_long">out_long</a></code></li>
<li><code><a title="ida_ua.outctx_base_t.out_name_expr" href="#ida_ua.outctx_base_t.out_name_expr">out_name_expr</a></code></li>
<li><code><a title="ida_ua.outctx_base_t.out_printf" href="#ida_ua.outctx_base_t.out_printf">out_printf</a></code></li>
<li><code><a title="ida_ua.outctx_base_t.out_register" href="#ida_ua.outctx_base_t.out_register">out_register</a></code></li>
<li><code><a title="ida_ua.outctx_base_t.out_spaces" href="#ida_ua.outctx_base_t.out_spaces">out_spaces</a></code></li>
<li><code><a title="ida_ua.outctx_base_t.out_symbol" href="#ida_ua.outctx_base_t.out_symbol">out_symbol</a></code></li>
<li><code><a title="ida_ua.outctx_base_t.out_tagoff" href="#ida_ua.outctx_base_t.out_tagoff">out_tagoff</a></code></li>
<li><code><a title="ida_ua.outctx_base_t.out_tagon" href="#ida_ua.outctx_base_t.out_tagon">out_tagon</a></code></li>
<li><code><a title="ida_ua.outctx_base_t.out_value" href="#ida_ua.outctx_base_t.out_value">out_value</a></code></li>
<li><code><a title="ida_ua.outctx_base_t.outbuf" href="#ida_ua.outctx_base_t.outbuf">outbuf</a></code></li>
<li><code><a title="ida_ua.outctx_base_t.print_label_now" href="#ida_ua.outctx_base_t.print_label_now">print_label_now</a></code></li>
<li><code><a title="ida_ua.outctx_base_t.restore_ctxflags" href="#ida_ua.outctx_base_t.restore_ctxflags">restore_ctxflags</a></code></li>
<li><code><a title="ida_ua.outctx_base_t.retrieve_cmt" href="#ida_ua.outctx_base_t.retrieve_cmt">retrieve_cmt</a></code></li>
<li><code><a title="ida_ua.outctx_base_t.retrieve_name" href="#ida_ua.outctx_base_t.retrieve_name">retrieve_name</a></code></li>
<li><code><a title="ida_ua.outctx_base_t.set_comment_addr" href="#ida_ua.outctx_base_t.set_comment_addr">set_comment_addr</a></code></li>
<li><code><a title="ida_ua.outctx_base_t.set_dlbind_opnd" href="#ida_ua.outctx_base_t.set_dlbind_opnd">set_dlbind_opnd</a></code></li>
<li><code><a title="ida_ua.outctx_base_t.set_gen_cmt" href="#ida_ua.outctx_base_t.set_gen_cmt">set_gen_cmt</a></code></li>
<li><code><a title="ida_ua.outctx_base_t.set_gen_demangled_label" href="#ida_ua.outctx_base_t.set_gen_demangled_label">set_gen_demangled_label</a></code></li>
<li><code><a title="ida_ua.outctx_base_t.set_gen_label" href="#ida_ua.outctx_base_t.set_gen_label">set_gen_label</a></code></li>
<li><code><a title="ida_ua.outctx_base_t.set_gen_xrefs" href="#ida_ua.outctx_base_t.set_gen_xrefs">set_gen_xrefs</a></code></li>
<li><code><a title="ida_ua.outctx_base_t.stack_view" href="#ida_ua.outctx_base_t.stack_view">stack_view</a></code></li>
<li><code><a title="ida_ua.outctx_base_t.term_outctx" href="#ida_ua.outctx_base_t.term_outctx">term_outctx</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
</main>
<footer id="footer">
<p>Copyright (c) 2021 Hex-Rays SA. <a href="/terms_of_use.shtml">Terms of use</a> and <a href="/privacy_policy.shtml">privacy policy</a>.</p>
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> ???</a>.</p>
</footer>
</body>
</html>